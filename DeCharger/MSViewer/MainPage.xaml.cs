//-----------------------------------------------------------------------
// Copyright 2018 Eli Lilly and Company
//
// Licensed under the Apache License, Version 2.0 (the "License");
//
// you may not use this file except in compliance with the License.
//
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//-----------------------------------------------------------------------


using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.NetworkInformation;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Shapes;
using System.IO.IsolatedStorage;
using System.IO;
using Visifire.Charts;
using System.Diagnostics;
using SignalProcessing;
using System.Windows.Media.Imaging;
using System.Text;
using System.Collections.ObjectModel;
using System.Reflection;
using System.Xml.Linq;
using System.Threading;
using System.ComponentModel;
using System.Runtime.Serialization;
using Microsoft.Win32;
using System.Runtime.Serialization.Json;
using Xceed.Wpf.Toolkit;
using System.Deployment.Application;
using System.Collections;
using MassSpectrometry;
using Xceed.Wpf.AvalonDock.Layout.Serialization;
using Xceed.Wpf.AvalonDock.Layout;
using System.Windows.Controls.Primitives;
using System.Windows.Threading;
using System.Data;
using System.Windows.Data;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Drawing.Imaging;
using MSViewer.Controls;
using MSViewer.Classes;
using System.Data.SqlClient;
using Visifire.Commons;
using System.Configuration;
using System.Text.RegularExpressions;
using MoreLinq;
using Science.Proteomics;
using System.Threading.Tasks;
using Science.Blast;
using System.Net.Mail;
using System.IO.Packaging;
using System.Printing;
using System.Collections.Specialized;
using System.Globalization;
using Science.Chemistry;
using System.Xml;
using System.Xml.Serialization;
using Ionic.Zip;
using static Science.Proteomics.AminoAcidHelpers;
//using System.Web.Script.Serialization;
//using Newtonsoft.Json;


//using CommonClasses;
//using MSViewer;

namespace MSViewer
{


    public partial class MainWindow : Window, INotifyPropertyChanged
    {
        private bool usingParallel = true;
        private string LaunchArgument = null;
        private string ToolsDockTitleRoot = "Tools";
        private string MassValueFormat = "F4";  // floating point with 4 decimal places

        double OffsetStart = double.NaN;

        int? CurrentScanNumber = 1;

        SqlConnection db = new SqlConnection(Properties.Settings.Default.ConnectionString);

        AnnotationBar lastbar = new AnnotationBar();

        IMSProvider MainPointProvider;
        //IMSProvider mergespectrarms;
        //SignalProcessor signalProcessor = new SignalProcessor();

        List<BackgroundWorker> fileLoadWorkers = new List<BackgroundWorker>();
        int LocalAccessionIndex = 1;

        //bool ShiftIsDown = false;

        PlotArea PlotWithFocus = null;
        Spectrum CurrentSpectrum = new Spectrum();
        Spectrum ReverseCurrentSpectrum = new Spectrum();
        List<Cluster> CurrentIons = new List<Cluster>();
        List<Cluster> TempCurrentIons = new List<Cluster>();
        //double parentmass = 0;
        bool firsttimestoryboard = false; ///To check if this is the first time the story board being set.
                                          /// <summary>
                                          /// Decharged Clusters from one or more scans that are combined into a single list
                                          /// </summary>
        List<Cluster> MergedIons = new List<Cluster>();
        List<Cluster> TempMergedIons = new List<Cluster>();

        List<AminoAcidMatch> MassFlags = new List<AminoAcidMatch>();

        CancellationTokenSource cTokenSource = null;

        /// <summary>
        /// Used to set scaling based on forward or reverse spectrum is selected
        /// Null being the default value which sets the scaling based on what is
        /// maximum.
        /// True scales to the forward spectrum
        /// False scales to the reverse spectr
        /// </summary>
        bool? forwardorreverse = null;

        string assemblyname = string.Empty;

        bool fromautoscan = false; //To display spectra while autoscan.

        StringBuilder stringbuilderforBlastp = new StringBuilder();

        List<List<Cluster>> MergeCurrentIons = new List<List<Cluster>>();

        List<double?> parentmasses = new List<double?>();
        ChartMode CurrentMode = ChartMode.Mass;
        // bool merging = false; //This is to check if there is any merging going on. 
        //ObservableCollection<Sequences> Sequences = new ObservableCollection<Sequences>();

        enum scaleby
        {
            Mono,
            Primary,
            Predicted,
            Thermo
        };

        string SequenceforAutoScan = string.Empty; //Set the sequence tag while auto scaning.

        List<FindSequenceTags.SequenceTag> sqsalldenovotgs = new List<FindSequenceTags.SequenceTag>();
        List<AminoAcidIndex> aai = new List<AminoAcidIndex>();
        List<AminoAcidIndex> aaiforsequencematches = new List<AminoAcidIndex>();
        List<AminoAcidGap> aag = new List<AminoAcidGap>();
        /// <summary>
        /// Connection string for the database.
        /// </summary>
        //string cnx = "Data Source=sanger;Initial Catalog=Proteomics_dev;Integrated Security=True;Connect Timeout=15;Encrypt=False;TrustServerCertificate=False;";
        //Collection of all the MonoMasses found out for the current graph loaded
        ObservableCollection<DataPoint> CurrentMonoMasses = new ObservableCollection<DataPoint>();
        ObservableCollection<DataPoint> CurrentMonoMassesforsequences = new ObservableCollection<DataPoint>();
        List<MonoPeak> CurrentMonos = new List<MonoPeak>();
        List<MonoPeak> SecondaryCurrentMonos = new List<MonoPeak>();
        List<MonoPeak> ReverseCurrentMonos = new List<MonoPeak>();
        List<DataPoint> ReverseCurrentMonomasses = new List<DataPoint>();
        List<MonoPeak> ReverseSecondaryCurrentMonos = new List<MonoPeak>();
        //ObservableCollection<DataPoint> SecondaryCurrentMonoMasses = new ObservableCollection<DataPoint>();
        bool SelectingRange = false;
        bool monosfound = false;
        //List<FindSequenceTags.SequenceTag> currentTags = new List<FindSequenceTags.SequenceTag>();
        //List<FindSequenceTags.SequenceTag> reversesequences = new List<FindSequenceTags.SequenceTag>();
        ObservableCollection<AnnotationBar> sequencetagbars = new ObservableCollection<AnnotationBar>();
        ObservableCollection<SpectrumInfo> mgrspectra = new ObservableCollection<SpectrumInfo>();
        //ObservableCollection<SpectrumInfo> fullmgrspectra = new ObservableCollection<SpectrumInfo>();

        ListCollectionView mergeView = null;

        bool SelectingQuantRange = false;
        List<MainSequenceTagmatches> aminoacidsforsequence = new List<MainSequenceTagmatches>(); ///Using this for sequence tag matching
        Range CurrentScanRange = new Range() { Start = float.NaN, End = float.NaN };
        //List<SpectrumInfo> mspec = new List<SpectrumInfo>();
        List<RMSProvider.SpecPoint> ThermoPoint = new List<RMSProvider.SpecPoint>();
        string SequenceMatch = string.Empty;
        List<Chart> Chromatograms = new List<Chart>();
        int PixelTolerance = 6;
        double AnnotationbarScore = 0;
        //double LastSnappedXPosition = 0;
        scaleby setscale = scaleby.Primary;
        //BackgroundWorker UpdateCurrentSpectrum = new BackgroundWorker() { WorkerSupportsCancellation = true, WorkerReportsProgress = true };
        double maxofpredictedvalues = new double();
        //List<SignalProcessing.Point> predictedvalues = new List<SignalProcessing.Point>();
        //It has the masses of all the Amino Acids available
        public ObservableCollection<QuantitationItem> Items { get; private set; }
        string Pairmatch = string.Empty;
        Dictionary<double, string> MassLookup;
        //It has the combinations of all the Amino Acids available
        Dictionary<double, string> ComboMassLookup;
        Dictionary<double, string> MassLookupToUse;
        Dictionary<double, string> FlagMassLookup = new Dictionary<double, string>();

        Dictionary<double, string> ThreeComboMassLookup = new Dictionary<double, string>();

        List<SearchResult> BoundSequences = new List<SearchResult>();
        List<SearchResult> fastasequences = new List<SearchResult>();

        //List<SequenceSearch> VerifiedSequences = new List<SequenceSearch>();

        SearchResult CurrentValidatedSequence = new SearchResult();

        clsParentInfo currentparent = new clsParentInfo();

        int SqlcommandTimeout = 60; //Timeout for sql commands

        //string accessionFilter;

        string FASTAFileName = string.Empty;
        string lblFASTAFileName = string.Empty;

        SpectrumModel context = new SpectrumModel();

        bool SequenceDirectionRightToLeft = false;

        ObservableDictionary<int, PeakList> merged = new ObservableDictionary<int, PeakList>();

        double zoomWidth = 0;
        double lastScrollLocation = 50;
        System.Timers.Timer scrollTimer = new System.Timers.Timer();
        //bool CrossFader = false;
        private Range SpecRightClickSpot;

        FilterSequenceSearch filtersearch = new FilterSequenceSearch();
        FilterSequenceSearch alreadyfilteredsearch = new FilterSequenceSearch();
        private object lockObj = new object();

        public List<DataPoint> MonosforDBSequence = new List<DataPoint>();

        DispatcherTimer genTimer = new DispatcherTimer();

        /// <summary>
        /// Main instance of the View/Model for use in Data Binding throughout DeCharger
        /// </summary>
        public DeChargerViewModel DechargerVM = new DeChargerViewModel();



        public static DeChargerViewModel MainViewModel
        {
            get
            {
                return MainWindowInstance.DechargerVM;
            }
        }


        // props
        private double busyProgress;
        public double BusyProgressValue
        {
            get
            {
                return busyProgress;
            }
            set
            {
                SetField(ref busyProgress, value, "BusyProgressValue");
            }
        }

        private string busyProgressText;
        public string BusyProgressText
        {
            get
            {
                if (string.IsNullOrWhiteSpace(busyProgressText)) return "Processing...";

                return busyProgressText;
            }
            set
            {
                SetField(ref busyProgressText, value, "BusyProgressText");
            }
        }


        // props
        private double fileBusyProgress;
        public double FileBusyProgressValue
        {
            get
            {
                return fileBusyProgress;
            }
            set
            {
                SetField(ref fileBusyProgress, value, "FileBusyProgressValue");
            }
        }

        private string fileBusyProgressText;
        public string FileBusyProgressText
        {
            get
            {
                if (string.IsNullOrWhiteSpace(fileBusyProgressText)) return "Loading...";

                return fileBusyProgressText;
            }
            set
            {
                SetField(ref fileBusyProgressText, value, "FileBusyProgressText");
            }
        }

        private bool isFileBusyProgressIndeterminate;
        public bool IsFileBusyProgressIndeterminate
        {
            get
            {
                return isFileBusyProgressIndeterminate;
            }
            set
            {
                SetField(ref isFileBusyProgressIndeterminate, value, "IsFileBusyProgressIndeterminate");
            }
        }

        // ShowStopButton
        private Visibility showStopButton;

        public Visibility ShowStopButton
        {
            get
            {
                return showStopButton;
            }
            set
            {
                SetField(ref showStopButton, value, "ShowStopButton");
            }
        }

        private static MainWindow MainWindowInstance = null;

        public MainWindow()
        {
            MainWindowInstance = this;

            try
            {

                if (App.Log != null) App.Log.WriteEntry("Starting DeCharger", EventLogEntryType.Information);

                InitializeComponent();

                HideAllViews();

                if (App.Log != null) App.Log.WriteEntry("Before LoadSpecies", EventLogEntryType.Information);
                LoadSpecies();


                if (App.Log != null) App.Log.WriteEntry("Before MatchList", EventLogEntryType.Information);

                LoadMatchList();

                if (App.Log != null) App.Log.WriteEntry("Before the rest", EventLogEntryType.Information);

                dtgrdSearchSequence.RowHeight = double.NaN;
                txtSearchbox.Focus();

                string[] splittab = { "\t" };
                string[] splitline = { "\n" };

                btnSequenceSearchSource.ToolTip = db.Database;

                ApplySettings();

                AddChromatogramCursor(TIC_Chart);
                AddChromatogramCursor(BPI_Chart);
                AddChromatogramCursor(BPM_Chart);
                AddChromatogramCursor(XIC_Chart);

                AddSpectrumCursor(BottomChart);

                tabTIC.Tag = TIC_Chart;
                tabBPI.Tag = BPI_Chart;
                tabBPM.Tag = BPM_Chart;
                tabXIC.Tag = XIC_Chart;

                BottomChart.AxesX[0].Scroll += new EventHandler<AxisScrollEventArgs>(MainWindow_Scroll);

                ApplyMatchList();



                StringBuilder sbmods = new StringBuilder();


                //if (Properties.Settings.Default.UnimodModifications == "")
                {
                    var unimods = Science.Chemistry.ReadModifications.ReadMods();


                    foreach (var mod in unimods)
                    {
                        sbmods.Append(mod.InterimName + "\t" + mod.Description + "\t" + mod.Monomass + "\t" + string.Join("site", mod.Sites.GroupBy(a => a).Select(a => a.First())) + "\n");
                    }

                    Properties.Settings.Default.UnimodModifications = sbmods.ToString();

                    Properties.Settings.Default.Save();
                }

                App.uniMods = new List<Science.Chemistry.Modifications>();


                foreach (var mod in Properties.Settings.Default.UnimodModifications.Split(splitline, StringSplitOptions.RemoveEmptyEntries))
                {
                    string[] md = mod.Split(splittab, StringSplitOptions.RemoveEmptyEntries);
                    App.uniMods.Add(new Science.Chemistry.Modifications()
                    {
                        InterimName = md[0],
                        Description = md[1],
                        Monomass = Convert.ToDouble(md[2]),
                        Sites = md[3].Split(new string[] { "site" }, StringSplitOptions.RemoveEmptyEntries).ToList(),
                    });
                }


                PopulateValidateModificationList();


                if (Properties.Settings.Default.MatchTolerancePPMBasedonFileType == null)
                {
                    Properties.Settings.Default.MatchTolerancePPMBasedonFileType = new StringCollection();
                    Properties.Settings.Default.MatchTolerancePPMBasedonFileType.Add(Convert.ToString(Properties.Settings.Default.MatchTolerancePPMs));
                    Properties.Settings.Default.MatchTolerancePPMBasedonFileType.Add(Convert.ToString(Properties.Settings.Default.MatchTolerancePPMs));
                    Properties.Settings.Default.Save();
                }

                if (Properties.Settings.Default.MassTolerancePPMBasedonFileType == null)
                {
                    Properties.Settings.Default.MassTolerancePPMBasedonFileType = new StringCollection();
                    Properties.Settings.Default.MassTolerancePPMBasedonFileType.Add(Convert.ToString(Properties.Settings.Default.MassTolerancePPMs));
                    Properties.Settings.Default.MassTolerancePPMBasedonFileType.Add(Convert.ToString(Properties.Settings.Default.MassTolerancePPMs));
                    Properties.Settings.Default.Save();
                }



                PPMCalc.MassTolerancePPM = Properties.Settings.Default.MassTolerancePPM;

                //this.DataContext = CurrentMonoMasses;
                CurrentMonoMasses.CollectionChanged += new System.Collections.Specialized.NotifyCollectionChangedEventHandler(CurrentMonoMasses_CollectionChanged);


                //Allows visual feedback when drag-dropping a file.
                this.AllowDrop = true;
                this.DragOver += (s, e) => VisualStateManager.GoToState(this, "Hover", true);
                this.DragLeave += (s, e) => VisualStateManager.GoToState(this, "Normal", true);
                this.Drop += new DragEventHandler(RootElement_Drop);

                var assembly = Assembly.GetExecutingAssembly();
                string version = assembly.FullName.Split(',')[1];
                string fullversion = version.Split('=')[1];

                lblVersionAuthors.Content = "Version " + fullversion + " by Tony Major,";/// Mike Knierman and Anvesh Kodumuri";
                App.AssemblyLocation = FindCurrentAssemblyPath.GetAssemblyPath();
                Items = new ObservableCollection<QuantitationItem>();
                QuantitationListView.ItemsSource = Items;

                this.MouseRightButtonDown += new MouseButtonEventHandler(MainPage_MouseRightButtonDown);

                scrollTimer.AutoReset = false;
                scrollTimer.Interval = 500;
                scrollTimer.Elapsed += new System.Timers.ElapsedEventHandler(scrollTimer_Elapsed);

                SignalProcessor.OnProgressChange += SignalProcessor_OnProgressChange;
                displaySpecWorker.RunWorkerCompleted += bwSpec_RunWorkerCompleted;

                txtblastptag.Visibility = System.Diagnostics.Debugger.IsAttached ? System.Windows.Visibility.Visible : System.Windows.Visibility.Hidden;
                //#if DEBUG

                //#endif

                mergeView = new ListCollectionView(mgrspectra);

                // Based on: http://social.msdn.microsoft.com/Forums/en-US/915db4e8-0ccf-4c5b-97d3-b8898fcf4bac/filtering-observable-collection-using-collectionview?forum=wpf
                mergeView.Filter = (item) =>
                {
                    if (item == null) return false;
                    if (item is SpectrumInfo == false) return false;

                    // This is the filter to make the correct scans show up
                    //return ((item as SpectrumInfo).MsLevel != SpecMsLevel.MS || chkHideScansWithMS1.IsChecked.Value) && ((item as SpectrumInfo).ParentMass.HasValue || !chkHideScansWithNoMass.IsChecked.Value);
                    return (item as SpectrumInfo).IsVisible;

                    // Evaluate to true will display the item, evaluate to false will hide the item
                };

                this.grdMerge1.ItemsSource = mergeView;
                grdMerge1.DataContext = mergeView;

                if (Properties.Settings.Default.PPMErrorPlot)
                {
                    xaxisErrorPlot.Title = "Error (PPM)";
                }
                else ///if (Properties.Settings.Default.DaltonErrorPlot)
                {
                    xaxisErrorPlot.Title = "Error (AMU)";
                }

                chkHideScansWithNoMass_CheckChanged(null, null);

                genTimer.Tick += new EventHandler(UpdateGenTimeCallback);
                genTimer.Interval = new TimeSpan(0, 0, 1);

                this.DataContext = DechargerVM;

                DechargerVM.SaveCommand.ExecuteAction = x => SaveWorkspace_Click();

                DechargerVM.SaveAsCommand.ExecuteAction = x => SaveWorkspace_Click(true);


                DechargerVM.ConfigCommand.ExecuteAction = x =>
                {
                    var cw = new ConfigPage();
                    cw.Closed += cw_Closed;
                    cw.Owner = this;
                    cw.ShowDialog();
                };

                //CreateSaveCommand();

                // append beta to the title
                if (App.IsBeta) this.Title += " - Beta";
                if (App.IsAlpha) this.Title += " = Alpha";

                if (AppDomain.CurrentDomain.SetupInformation.ActivationArguments != null && AppDomain.CurrentDomain.SetupInformation.ActivationArguments.ActivationData != null && AppDomain.CurrentDomain.SetupInformation.ActivationArguments.ActivationData.Any())
                {
                    string[] activationData = AppDomain.CurrentDomain.SetupInformation.ActivationArguments.ActivationData;
                    var uri = new Uri(activationData[0]);
                    //System.Windows.MessageBox.Show(uri.LocalPath, "Path to the file.");
                    //fullText.Text = File.ReadAllText(uri.LocalPath);

                    LaunchArgument = uri.LocalPath;
                }
                else if (App.Args != null && App.Args.Any())
                {
                    LaunchArgument = App.Args[0];
                }

            }
            catch (Exception ex)
            {
                if (App.Log != null) App.Log.WriteEntry(ex.Message + " - " + ex.Source + "\n\n" + ex.StackTrace, EventLogEntryType.Error);
                //throw;
            }
            finally
            {
                //GetProperties();
                Properties.Settings.Default.PPMErrorAxisMax = Properties.Settings.Default.FragementIonTolerance;
                Properties.Settings.Default.PPMErrorAxisMin = -(Properties.Settings.Default.FragementIonTolerance);

            }
        }

        ///// <summary>
        ///// https://bitbucket.org/josephcooney/learnwpf.com.samples/src/3c821c46c1474826692010ec44eb83679ae191c1/ClickOnceFileAssociation/MainWindow.xaml.cs?at=default&fileviewer=file-view-default
        ///// </summary>
        ///// <param name="sender"></param>
        ///// <param name="e"></param>
        //private void MainWindowLoaded(object sender, RoutedEventArgs e)
        //{
        //    if (AppDomain.CurrentDomain.SetupInformation.ActivationArguments != null && AppDomain.CurrentDomain.SetupInformation.ActivationArguments.ActivationData != null && AppDomain.CurrentDomain.SetupInformation.ActivationArguments.ActivationData.Any())
        //    {
        //        string[] activationData = AppDomain.CurrentDomain.SetupInformation.ActivationArguments.ActivationData;
        //        var uri = new Uri(activationData[0]);
        //        fullText.Text = File.ReadAllText(uri.LocalPath);
        //    }
        //}



        /// <summary>
        /// Hides all the views except for the main view before a file is loaded
        /// </summary>
        void HideAllViews()
        {
            layoutanchorable3.Hide();
            layoutanchorable2.Hide();
            tabTIC.Visibility = System.Windows.Visibility.Hidden;
            tabBPI.Visibility = System.Windows.Visibility.Hidden;
            tabBPM.Visibility = System.Windows.Visibility.Hidden;
            tabXIC.Visibility = System.Windows.Visibility.Hidden;
            tabItem1.Visibility = System.Windows.Visibility.Hidden;
            tbGreenMarkers.Visibility = System.Windows.Visibility.Hidden;
            tbMatchList.Visibility = System.Windows.Visibility.Hidden;
            tbMonoMassList.Visibility = System.Windows.Visibility.Hidden;
            tbMergeSpectra.Visibility = System.Windows.Visibility.Hidden;
            tbAutoScan.Visibility = System.Windows.Visibility.Hidden;
            tbValidate.Visibility = System.Windows.Visibility.Hidden;
            tbConfirmedSequenceTab.Visibility = System.Windows.Visibility.Hidden;
        }

        /// <summary>
        /// Shows all the views in the main view after a file is loaded
        /// </summary>
        void LoadAllViews()
        {
            layoutanchorable3.Show();
            layoutanchorable2.Show();
            GrdDragDropFiles.Visibility = System.Windows.Visibility.Hidden;
            tabTIC.Visibility = System.Windows.Visibility.Visible;
            tabBPI.Visibility = System.Windows.Visibility.Visible;
            tabBPM.Visibility = System.Windows.Visibility.Visible;
            tabXIC.Visibility = System.Windows.Visibility.Visible;
            tabItem1.Visibility = System.Windows.Visibility.Visible;
            tbGreenMarkers.Visibility = System.Windows.Visibility.Visible;
            tbMatchList.Visibility = System.Windows.Visibility.Visible;
            tbMonoMassList.Visibility = System.Windows.Visibility.Visible;
            tbMergeSpectra.Visibility = System.Windows.Visibility.Visible;
            tbAutoScan.Visibility = System.Windows.Visibility.Visible;
            tbValidate.Visibility = System.Windows.Visibility.Visible;
            tbConfirmedSequenceTab.Visibility = System.Windows.Visibility.Visible;

            btnDetectParents.IsEnabled = true;
            Thickness dtgrdsearchmargin = dtgrdSearchSequence.Margin;

            dtgrdsearchmargin.Bottom = 0;
            dtgrdsearchmargin.Left = 2;
            dtgrdsearchmargin.Top = 38;
            dtgrdsearchmargin.Right = 2;

            dtgrdSearchSequence.Margin = dtgrdsearchmargin;

        }

        void EnableAllViews()
        {
            tabTIC.IsEnabled = true;
            tabBPI.IsEnabled = true;
            tabBPM.IsEnabled = true;
            tabXIC.IsEnabled = true;
            tbValidate.IsEnabled = true;
            BottomChart.IsEnabled = true;
            //tbDenovoResults.IsEnabled = true;
            tabItem1.IsEnabled = true;
            tbGreenMarkers.IsEnabled = true;
            tbMatchList.IsEnabled = true;
            tbMonoMassList.IsEnabled = true;
            tbMergeSpectra.IsEnabled = true;
            btnNext.IsEnabled = false;
            txtScanNum.IsEnabled = false;
            btnPrevious.IsEnabled = false;
        }

        void LoadMatchList()
        {
            App.strDictionary = clsStringDictionary.Deserialize(Properties.Settings.Default.MatchListProfile);

            var a = App.strDictionary;

            var b = a.Count;

            if (App.strDictionary.Count == 0)
            {
                App.strDictionary = new System.Collections.Specialized.StringDictionary();
                App.strDictionary.Add("Default", Properties.Settings.Default.MatchList);

                Properties.Settings.Default.MatchListProfile = clsStringDictionary.Serialize(App.strDictionary);
                Properties.Settings.Default.Save();
            }

            int count = App.strDictionary.Count;
            ReturnValue.returnvalue = "default";
            LoadAllCurrentMatchList();
            SelectMatchList();
        }

        private void cmbMatchList_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (cmbMatchList.Items.Count > 0)
            {
                var matchlist = App.strDictionary[((cmbMatchList.SelectedItem) as System.Windows.Controls.ComboBoxItem).Content.ToString()];
                txtMolecules.Text = matchlist;
                if (((cmbMatchList.SelectedItem) as System.Windows.Controls.ComboBoxItem).Content.ToString() == "DEFAULT")
                {
                    btnSaveMatchList.Visibility = System.Windows.Visibility.Hidden;
                    btnDeleteMatchList.Visibility = System.Windows.Visibility.Hidden;
                }
                else
                {
                    btnSaveMatchList.Visibility = System.Windows.Visibility.Visible;
                    btnDeleteMatchList.Visibility = System.Windows.Visibility.Visible;
                }
                btnSaveMatchList.IsEnabled = false;
                ApplyMatchList();
            }
        }

        private void btnNewMatchList_Click(object sender, RoutedEventArgs e)
        {
            string value = ReturnValue.returnvalue;
            Window newmatchlistvalue = new Window();
            newmatchlistvalue.Height = 140;
            newmatchlistvalue.Width = 440;
            newmatchlistvalue.Owner = this;
            newmatchlistvalue.ResizeMode = ResizeMode.NoResize;
            newmatchlistvalue.Content = new TextBoxSubmit("Enter a new Profile Name");
            newmatchlistvalue.Title = "Profile Name";
            newmatchlistvalue.WindowStartupLocation = System.Windows.WindowStartupLocation.CenterOwner;
            newmatchlistvalue.Closing += newmatchlistvalue_Closing;
            newmatchlistvalue.Activate();
            newmatchlistvalue.ShowDialog();
        }

        string returnvalue = string.Empty;

        //bool modtomatchlist = false;

        void newmatchlistvalue_Closing(object sender, CancelEventArgs e)
        {
            if (ReturnValue.returnvalue == null || ReturnValue.returnvalue == returnvalue)
                return;

            if (App.strDictionary.ContainsKey(ReturnValue.returnvalue))
            {
                System.Windows.MessageBox.Show("Entered profile name already exists");
                return;
            }

            App.strDictionary.Add(ReturnValue.returnvalue.Trim(), Properties.Settings.Default.MatchList);

            Properties.Settings.Default.MatchListProfile = clsStringDictionary.Serialize(App.strDictionary);
            Properties.Settings.Default.Save();
            App.SaveorNot = true;
            btnSaveMatchList.IsEnabled = true;
            returnvalue = ReturnValue.returnvalue;
            if (savingfromthedefaultlist)
            {
                App.strDictionary[ReturnValue.returnvalue] = txtMolecules.Text;
                Properties.Settings.Default.MatchListProfile = clsStringDictionary.Serialize(App.strDictionary);
                Properties.Settings.Default.Save();
                App.SaveorNot = true;
                ApplyMatchList();
                btnSaveMatchList.IsEnabled = false;
                savingfromthedefaultlist = false;
                //savenewmatchlist();
            }
            else
            {
                txtMolecules.Text = Properties.Settings.Default.MatchList;
            }
            LoadAllCurrentMatchList();
            SelectMatchList();
        }

        void savenewmatchlist()
        {

        }


        int indexofstringvalue(StringDictionary str, string key)
        {
            List<string> strvalues = new List<string>();

            foreach (string st in str.Keys)
            {
                strvalues.Add(st);
            }

            int indexofval = strvalues.IndexOf(key);

            return indexofval;
        }

        bool savingfromthedefaultlist = false;

        private void btnSaveMatchList_Click(object sender, RoutedEventArgs e)
        {
            if (((cmbMatchList.SelectedItem) as System.Windows.Controls.ComboBoxItem).Content.ToString() == "DEFAULT")
            {
                string value = ReturnValue.returnvalue;
                Window newmatchlistvalue = new Window();
                newmatchlistvalue.Height = 140;
                newmatchlistvalue.Width = 440;
                newmatchlistvalue.Owner = this;
                newmatchlistvalue.ResizeMode = ResizeMode.NoResize;
                newmatchlistvalue.Content = new TextBoxSubmit("Enter a new Profile Name");
                newmatchlistvalue.Title = "Profile Name";
                newmatchlistvalue.WindowStartupLocation = System.Windows.WindowStartupLocation.CenterOwner;
                newmatchlistvalue.Closing += newmatchlistvalue_Closing;
                newmatchlistvalue.Activate();
                newmatchlistvalue.ShowDialog();
                savingfromthedefaultlist = true;
            }
            else
            {
                App.strDictionary[((cmbMatchList.SelectedItem) as System.Windows.Controls.ComboBoxItem).Content.ToString()] = txtMolecules.Text;
                Properties.Settings.Default.MatchListProfile = clsStringDictionary.Serialize(App.strDictionary);
                Properties.Settings.Default.Save();
                App.SaveorNot = true;
                ApplyMatchList();
                btnSaveMatchList.IsEnabled = false;
            }
        }

        private void btnDeleteMatchList_Click(object sender, RoutedEventArgs e)
        {
            Window prompt = new Window();
            prompt.Height = 120;
            prompt.Width = 440;
            prompt.Owner = this;
            prompt.ResizeMode = ResizeMode.NoResize;
            prompt.Content = new Prompt(BooleanValues.OKorCancel, "Do you want to delete the profile?");
            prompt.Title = "Delete";
            prompt.WindowStartupLocation = System.Windows.WindowStartupLocation.CenterOwner;
            prompt.Closing += prompt_Closing;
            prompt.Activate();
            prompt.ShowDialog();
        }

        void prompt_Closing(object sender, CancelEventArgs e)
        {
            if (TrueorFalse.trueorfalse)
            {
                App.strDictionary.Remove(((cmbMatchList.SelectedItem) as System.Windows.Controls.ComboBoxItem).Content.ToString());
                Properties.Settings.Default.MatchListProfile = clsStringDictionary.Serialize(App.strDictionary);
                Properties.Settings.Default.Save();
                App.SaveorNot = true;
                LoadAllCurrentMatchList();
                ReturnValue.returnvalue = "default";
                SelectMatchList();
                TrueorFalse.trueorfalse = false;
                //ApplyMatchList();
            }
        }

        void SelectMatchList()
        {
            int index = indexofstringvalue(App.strDictionary, ReturnValue.returnvalue.Trim().ToLower());
            cmbMatchList.SelectedIndex = index;
        }

        void LoadAllCurrentMatchList()
        {
            cmbMatchList.Items.Clear();
            List<string> allkeys = new List<string>();
            App.strDictionary = clsStringDictionary.Deserialize(Properties.Settings.Default.MatchListProfile);
            foreach (var key in App.strDictionary.Keys)
            {
                allkeys.Add(key.ToString().ToUpper());
            }
            //allkeys.Reverse();
            foreach (var key in allkeys)
            {
                ComboBoxItem cmb = new ComboBoxItem();
                cmb.Content = key.ToString();
                cmbMatchList.Items.Add(cmb);
            }
        }

        void LoadSpecies()
        {
            List<Species> species = null;
            
            string[] delimiter = { "\t" };

            if (App.Log != null) App.Log.WriteEntry("Species List in settings: " + Properties.Settings.Default.Genus, EventLogEntryType.Information);


            string[] st = Properties.Settings.Default.Genus.Split(delimiter, StringSplitOptions.RemoveEmptyEntries);


            //string[] st1 = { "Bos taurus", "Homo", "Homo sapiens", "human", "Mus", "Mus musculus", "Rattus", "Rattus norvegicus", "Bos" };
            string[] defaultSpecies = { "Bos", "Homo", "Mus", "Rattus" };

            if (NetworkInterface.GetIsNetworkAvailable() && string.IsNullOrWhiteSpace(db.ConnectionString) == false)
            {
                // Test the connection with a ping because it's quicker than trying to open a connection to a 
                // server that isn't there and letting it fail.  That is the default scenario for external users
                // and I don't want the startup time to be slow for that use-case.  I could clear the connection details,
                // but Lilly is my primary use case...
                var builder = new SqlConnectionStringBuilder(db.ConnectionString);
                var dataSource = builder.DataSource.Split('\\')[0];

                var pinger = new Ping();
                var pingResponse = pinger.Send(dataSource, 500);

                if (pingResponse.Status == IPStatus.Success)
                {
                    try
                    {

                        //throw new Exception("login failed");  // uncomment to test access denied dialog

                        if (db.State == ConnectionState.Closed) db.Open();

                        using (SqlCommand cmd = new SqlCommand("select Genus, ID from Species", db))
                        {
                            using (SqlDataReader reader = cmd.ExecuteReader())
                            {
                                species = new List<Species>();

                                while (reader.Read())
                                {
                                    species.Add(new Species
                                    {
                                        Genus = reader["Genus"] != DBNull.Value ? Convert.ToString(reader["Genus"]) : "",
                                        SpeciesID = reader["ID"] != DBNull.Value ? Convert.ToInt32(reader["ID"]) : 0,
                                        IsSelected = defaultSpecies.Contains(reader["Genus"] != DBNull.Value ? Convert.ToString(reader["Genus"]) : ""),
                                        DefaultSpecies = st.Contains(reader["Genus"] != DBNull.Value ? Convert.ToString(reader["Genus"]) : "")
                                    });
                                }
                            }
                        }
                    }
                    catch (Exception ex)
                    {
                        if (((System.Data.SqlClient.SqlException)(ex)).State == 1 || ex.Message.ToLower().Contains("login failed")) // User Access denied exception
                        {
                            System.Windows.MessageBox.Show("Access denied.  Please contact your database administrator for access.  ", "User Account Problem", MessageBoxButton.OK, MessageBoxImage.Exclamation);
                        }
                        else if (ex.Message.StartsWith("The target principal name is incorrect"))
                        {
                            System.Windows.MessageBox.Show("Failed to authenticate user for database access.  User account may be locked.  ", "User Account Problem", MessageBoxButton.OK, MessageBoxImage.Exclamation);
                        }
                        else if (ex.Message.Contains("server was not found"))
                        {
                            //Do nothing, we'll just run in offline mode when there is no server present
                        }
                        else
                        {
                            throw;
                        }
                    }
                }
            }

            if (species == null)
            {
                int i = 0;
                species = new List<Species>();

                foreach (string s in st)
                {
                    species.Add(new Species
                    {
                        Genus = s,
                        IsSelected = true,
                        SpeciesID = i++,
                        DefaultSpecies = defaultSpecies.Contains(s)
                    });
                }
            }

            App.LoadSpecies = true;
            App.DistinctSpecies = species.OrderBy(a => !(a.DefaultSpecies)).ThenBy(a => a.Genus).ThenBy(a => a.IsSelected == false).ToList();
        }

        void scrollTimer_Elapsed(object sender, System.Timers.ElapsedEventArgs e)
        {
            scrollTimer.Stop();

            if (zoomWidth < 0.008) return;

            lock (scrollTimer)
            {
                try
                {

                    CurrentSpectrum.SortByMass();


                    var YMax = Math.Max(CurrentSpectrum.GetMaxYValueForXRange((double)BottomChart.AxesX[0].ViewMinimum, (double)BottomChart.AxesX[0].ViewMaximum), ReverseCurrentSpectrum.GetMaxYValueForXRange((double)BottomChart.AxesX[0].ViewMinimum, (double)BottomChart.AxesX[0].ViewMaximum));

                    if (YMax <= 0) return;

                    Debug.WriteLine("Calculating new YMax: " + YMax.ToString() + ", " + BottomChart.AxesX[0].ViewMinimum + " - " + BottomChart.AxesX[0].ViewMaximum);

                    SetScaling();

                }
                catch { }
                //}), DispatcherPriority.Background);

            }
            // Code was hanging here at the Dispatcher.Invoke, so added the Dispatcher Priority per this thread: http://stackoverflow.com/questions/16298600/dispatcher-invoke-hangs-main-window

        }


        void MainWindow_Scroll(object sender, AxisScrollEventArgs e)
        {
            scrollTimer.Stop();

            Debug.WriteLine("Scrolling: " + e.ScrollEventArgs.NewValue.ToString() + ", " + e.ScrollEventArgs.ScrollEventType.ToString());

            lastScrollLocation = e.ScrollEventArgs.NewValue;

            scrollTimer.Start();
        }


        void CurrentMonoMasses_CollectionChanged(object sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e)
        {
            dtgridMonoMasses.DataContext = CurrentMonoMasses;
            //txtMonoMasses.Text = string.Join("\n", CurrentMonoMasses.Select(m => ((double)m.XValue).ToString("0.00000") + "\t" + m.YValue.ToString("0000.0000") + "\t" + m.ZValue.ToString()));

            btnFindAA.ToolTip = CurrentMonoMasses.Count() + " MonoIsotopes detected.";
        }

        void MainPage_MouseRightButtonDown(object sender, MouseButtonEventArgs e)
        {
            e.Handled = true;
        }

        List<SpectrumInfo> specs = new List<SpectrumInfo>();

        bool loadraworagilent = true;

        bool PreviousXMLFileloaded = false;

        FileSystemInfo flsinfo;

        private void RootElement_Drop(object sender, DragEventArgs e)
        {
            RootElement_Drop(sender, e, null);
        }


        // Handle drag/drop
        private void RootElement_Drop(object sender, DragEventArgs e, string path)
        {
            loadraworagilent = true;
            PreviousXMLFileloaded = false;

            try
            {
                //if (path != null) System.Windows.MessageBox.Show(this, "path is " + path);

                //if (e.Data.GetDataPresent("FileDrop"))
                //{
                //    System.Windows.MessageBox.Show(this, "Filedrop data present");

                //    System.Windows.MessageBox.Show(this, "data is " + e.Data.GetData("FileDrop"));
                //}

                //System.Windows.MessageBox.Show(this, "files: " + string.Join(", ", (e.Data.GetData("FileDrop") as string[])));
                //System.Windows.MessageBox.Show(this, "files: " + string.Join(", ", (e.Data.GetData("FileDrop") as string[])));


                if (path != null || e.Data.GetDataPresent("FileDrop"))
                {

                    //An array of dropped-in files.
                    IEnumerable<FileSystemInfo> files = null;

                    if (path != null && File.Exists(path))
                    {
                        files = new List<FileSystemInfo>() { new FileInfo(path) };
                        if (App.Log != null) App.Log.WriteEntry("Files were passed into DeCharger via argument = " + string.Join("; ", files.Select(f => f.FullName)), EventLogEntryType.Information);
                    }
                    else if (e != null && e.Data != null)
                    {
                        files = (e.Data.GetData("FileDrop") as string[]).Where(f => Directory.Exists(f) || File.Exists(f)).Select(f => File.GetAttributes(f).HasFlag(FileAttributes.Directory) ? new DirectoryInfo(f) as FileSystemInfo : new FileInfo(f) as FileSystemInfo);

                        if (App.Log != null) App.Log.WriteEntry("Files were dragged/dropped into DeCharger = " + string.Join("; ", files.Select(f =>f.FullName)), EventLogEntryType.Information);

                    }
                    else
                    {
                        return; // no valid file was passed
                    }



                    VisualStateManager.GoToState(this, "Normal", false);

                    ClearSearchContents();
                    LoadAllViews();

                    IEnumerable<FileSystemInfo> supportedFiles = files.Where(f => ZMSProvider.CanReadFormat(f) || RMSProvider.CanReadFormat(f) || AgilentProvider.CanReadFormat(f) || mzDataProvider.CanReadFormat(f) || mzMLProvider.CanReadFormat(f) || f.Extension.ToUpper() == ".FASTA" || f.Extension.ToUpper() == ".FSA" || f.Extension.ToUpper() == ".XML" || f.Extension.ToUpper() == ".SSR");

                    var unsupportedFiles = files.Where(f => supportedFiles.Select(x => x.FullName).Contains(f.FullName) == false);

                    if (unsupportedFiles.Any())
                    {
                        System.Windows.MessageBox.Show("Files of type " + string.Join(",", unsupportedFiles.Select(f => f.Extension).Distinct()) + " are not supported and will be skipped.  ", "File Rejection", MessageBoxButton.OK, MessageBoxImage.Warning);
                    }

                    if (supportedFiles != null && supportedFiles.Any() && supportedFiles.Any(a => a.Extension.ToUpper() == ".SSR"))
                    {
                        supportedFiles = supportedFiles.OrderByDescending(a => a.Extension.ToUpper() == ".SSR").ToList();
                    }



                    if (supportedFiles != null && supportedFiles.Any() && supportedFiles.Any(f => f.Extension.ToUpper() == ".FASTA" || f.Extension.ToUpper() == ".FSA"))
                    {
                        stringbuilderforBlastp.Clear();
                        if (fileLoadWorkers.Any())
                        {
                            foreach (var aWorker in fileLoadWorkers) aWorker.CancelAsync();  // cancel any workers that are already loading a fasta file because a new file was just dropped
                            Thread.Sleep(100);  // wait for threads to cancel?  
                        }

                        App.lstFasta = new List<FASTA>();

                        lblFASTAFileName = string.Empty;
                        fastasequences.Clear();
                        BoundSequences.Clear();
                        LocalAccessionIndex = 1;
                        FASTAFileName = string.Empty;

                        fileLoadWorkers.Clear();
                    }

                    addparentmassfromMergeSpectra = false;
                    bool morethanonefile = false;
                    App.FirstTwentyFasta = new StringBuilder();

                    // Load the raw data files first, then load SSR, then FASTA
                    if (supportedFiles != null && supportedFiles.Any())
                    {
                        foreach (var aFile in supportedFiles.OrderBy(f => f.Extension.ToUpper() != ".FASTA" && f.Extension.ToUpper() != ".FSA" && f.Extension.ToUpper() != ".SSR" && f.Extension.ToUpper() != ".XML").ThenBy(f => f.Extension.ToUpper() != ".FASTA" && f.Extension.ToUpper() != ".FSA"))
                        {
                            if (aFile.Extension.ToUpper() == ".FASTA" || aFile.Extension.ToUpper() == ".FSA" || aFile.Extension.ToUpper() == ".TXT")
                            {
                                ImportFastaFileAsync(aFile.FullName);

                                System.IO.Path.GetTempFileName();
                                lblFASTAFileName += (morethanonefile ? " , " : "") + aFile.Name;
                                morethanonefile = true;

                                DechargerVM.CurrentFilesLoaded.Add(aFile.Name);

                                //isfastafile = true;
                                //break;
                            }
                            else if (ZMSProvider.CanReadFormat(aFile))
                            {
                                MainPointProvider = new ZMSProvider((aFile as FileInfo).OpenRead()) { MassTolerance = Properties.Settings.Default.MassTolerancePPM };

                                if (DechargerVM.SpectralDataFilename != aFile.Name)
                                {
                                    DechargerVM.ClearResults();
                                    UpdateWorkspaceTitle();
                                }

                                DechargerVM.SpectralDataFilename = aFile.Name;

                                break;  // we can only load one Mass Spec file
                            }
                            else if (mzDataProvider.CanReadFormat(aFile))
                            {
                                MainPointProvider = new mzDataProvider((aFile as FileInfo).OpenRead()) { MassTolerance = Properties.Settings.Default.MassTolerancePPM };

                                if (DechargerVM.SpectralDataFilename != aFile.Name)
                                {
                                    DechargerVM.ClearResults();
                                    UpdateWorkspaceTitle();
                                }

                                DechargerVM.SpectralDataFilename = aFile.Name;

                                break;  // we can only load one Mass Spec file
                            }
                            else if (mzMLProvider.CanReadFormat(aFile))
                            {
                                //TODO: Mass Tolerance is hardcoded for mzML, FIX THIS!!!!!
                                //TODO: this is a random number that should be properly set based on instrument mass accuracy!!!!!

                                MainPointProvider = new mzMLProvider((aFile as FileInfo).OpenRead()) { MassTolerance = 5 };


                                if (DechargerVM.SpectralDataFilename != aFile.Name)
                                {
                                    DechargerVM.ClearResults();
                                    UpdateWorkspaceTitle();
                                }

                                DechargerVM.SpectralDataFilename = aFile.Name;


                                //TODO: hardcoded to Thermo file type to set that masstoleranceppm and matchtoleranceppm
                                // Make this file mode detected by reading the instrument values from the file and exposing them in the IMSProvider Interface
                                // Like these: 
                                // <referenceableParamGroupList count="1">
                                // < referenceableParamGroup id = "CommonInstrumentParams" >
                                // < cvParam value = "" name = "LTQ Orbitrap Velos" accession = "MS:1001742" cvRef = "MS" />
                                // or look for an orbitrap analyzer: 
                                // <analyzer order="2">
                                //< cvParam value = "" name = "orbitrap" accession = "MS:1000484" cvRef = "MS" />
                                // 

                                DechargerVM.CurrentFileType = clsFileType.MSFileType.Thermo;
                                App.CurrentFileType = clsFileType.MSFileType.Thermo;

                                Properties.Settings.Default.MatchTolerancePPM = Convert.ToDouble(Properties.Settings.Default.MatchTolerancePPMBasedonFileType[1]);
                                Properties.Settings.Default.MassTolerancePPM = Convert.ToDouble(Properties.Settings.Default.MassTolerancePPMBasedonFileType[1]);


                                break;  // we can only load one Mass Spec file
                            }
                            else if (RMSProvider.CanReadFormat(aFile))
                            {

                                if (string.IsNullOrWhiteSpace(DechargerVM.WorkspaceFilename) == false)
                                {
                                    // We currently have a workspace loaded...

                                    switch (DecideWhetherToUnload(aFile.Name, DechargerVM.SpectralDataFilename))
                                    {
                                        case LoadCurrentFile.Load: ///If the response is to load then do nothing
                                            PreviousXMLFileloaded = true;
                                            break;
                                        case LoadCurrentFile.Unload: ///If the response is to unload then unload the current ssr xml file.
                                            App.XMLFileName = string.Empty;
                                            UnloadSequenceSearchResults();
                                            //UnloadSSRXMLFile();
                                            break;
                                        case LoadCurrentFile.Pass: ///If the response is to Pass then continue the loop without loading the current file.
                                            loadraworagilent = false;
                                            continue;
                                        default:
                                            break;
                                    }
                                }

                                Properties.Settings.Default.MatchTolerancePPM = Convert.ToDouble(Properties.Settings.Default.MatchTolerancePPMBasedonFileType[1]);
                                Properties.Settings.Default.MassTolerancePPM = Convert.ToDouble(Properties.Settings.Default.MassTolerancePPMBasedonFileType[1]);
                                //App.FileName = aFile.Name;
                                //dtgridConfirmedSequences.ItemsSource = null;
                                lblExperimentalMass.Text = "";
                                lblAutoScanNumberofScans.Content = string.Empty;
                                EnableAllViews();

                                //txtblkSequenceSearchResult.Visibility = System.Windows.Visibility.Hidden;
                                ///If there is any XML file already loaded then check if it has the same name as the file loaded. 

                                //lblTheoreticalMass.Content = "";
                                try
                                {
                                    //if (Environment.Is64BitProcess)
                                        MainPointProvider = new RMSProvider(aFile as FileInfo) { MassTolerance = Properties.Settings.Default.MassTolerancePPM };
                                    //else
                                    //    MainPointProvider = new RMSProvider32(aFile as FileInfo) { MassTolerance = Properties.Settings.Default.MassTolerancePPM };

                                    //MainPointProvider = new RMSProvider(aFile.FullName) { MassTolerance = Properties.Settings.Default.MassTolerancePPM };


                                    if (DechargerVM.SpectralDataFilename != aFile.Name)
                                    {
                                        DechargerVM.ClearResults();
                                        UpdateWorkspaceTitle();
                                    }

                                    DechargerVM.SpectralDataFilename = aFile.Name;
                                    App.FileName = aFile.Name;

                                    DechargerVM.CurrentFileType = clsFileType.MSFileType.Thermo;

                                    App.CurrentFileType = clsFileType.MSFileType.Thermo;

                                    DechargerVM.CurrentFilesLoaded.Add(aFile.Name);
                                }
                                catch (Exception)
                                {
                                    //TODO: The Exception type being caught is not specific to the thermo foudation being missing.  This should only catch the specific exception type.

                                    System.Windows.MessageBox.Show("The minimum required Thermo Foundation version is 3.0. Please update the update the Thermo Foundation to continue.", "Install Thermo Foundation.", MessageBoxButton.OK, MessageBoxImage.Asterisk);
                                }

                                break;  // we can only load one Mass Spec file                            
                            }
                            else if (AgilentProvider.CanReadFormat(aFile)) ///&& (Properties.Settings.Default.AgilentAgreed || System.Windows.MessageBox.Show(Properties.Settings.Default.AgilentEULA, "Do you agree to the following Terms?", MessageBoxButton.YesNo, MessageBoxImage.Question, MessageBoxResult.No) == MessageBoxResult.Yes)) // && System.Diagnostics.Debugger.IsAttached)
                            {


                                flsinfo = aFile;

                                if (!Properties.Settings.Default.AgilentAgreed)
                                {
                                    Window CanReadAgilentFile = new Window();
                                    CanReadAgilentFile.Height = 720;
                                    CanReadAgilentFile.Width = 710;
                                    CanReadAgilentFile.Owner = this;
                                    CanReadAgilentFile.ResizeMode = System.Windows.ResizeMode.NoResize;
                                    CanReadAgilentFile.Content = new AgilentAgreement(Properties.Settings.Default.AgilentEULA);
                                    CanReadAgilentFile.Title = "Do you agree to the following Terms?";
                                    CanReadAgilentFile.WindowStartupLocation = System.Windows.WindowStartupLocation.CenterOwner;
                                    //CanReadAgilentFile.Closing += CanReadAgilentFile_Closing;
                                    CanReadAgilentFile.Activate();
                                    CanReadAgilentFile.ShowDialog();
                                    //break;  // we can only load one Mass Spec file                            
                                }

                                if (Properties.Settings.Default.AgilentAgreed)
                                {
                                    LoadAgilentFile();
                                    break;
                                }
                            }
                            else if (aFile.Extension.ToUpper() == ".XML" || aFile.Extension.ToUpper() == ".SSR")
                            {
                                ///If the file name ends with .SSR.XML then it is a Sequence Search Results XML file.
                                if (aFile.Name.ToUpper().EndsWith(".SSR.XML") || aFile.Name.ToUpper().EndsWith(".SSR"))
                                {
                                    //DeChargerModel.WorkspaceFilename = aFile.Name;
                                    //DechargerVM.CurrentFilesLoaded.Add(aFile.Name);

                                    LoadWorkspace(aFile);

                                    // Set the AutoScan tab to the front
                                    tbAutoScan.Focus();
                                }
                                else
                                {
                                    System.Windows.MessageBox.Show("Unsupported File Type Detected.  ", "File Rejection", MessageBoxButton.OK, MessageBoxImage.Exclamation);
                                }
                            }
                            else
                            {
                                System.Windows.MessageBox.Show("Unsupported File Type Detected.  ", "File Rejection", MessageBoxButton.OK, MessageBoxImage.Exclamation);
                            }
                        }
                    }

                    if (lblFASTAFileName.Length > 45)
                    {
                        lblFASTAFileName = lblFASTAFileName.Substring(0, 43) + " ....";
                    }


                    if (supportedFiles != null && supportedFiles.Any() && supportedFiles.Any(f => RMSProvider.CanReadFormat(f) || ZMSProvider.CanReadFormat(f) || mzDataProvider.CanReadFormat(f) || mzMLProvider.CanReadFormat(f) || (AgilentProvider.CanReadFormat(f) && Properties.Settings.Default.AgilentAgreed)) && loadraworagilent)
                    {
                        tabTIC.Focus();

                        Dispatcher.Invoke((Action)(() =>
                        {
                            if (!PreviousXMLFileloaded)
                            {
                                //this.dtgridSearchResults.ItemsSource = null;
                                //this.dtgridConfirmedSequences.ItemsSource = null;
                            }

                            InitCharts(MainPointProvider);
                        }));
                    }
                    else if (supportedFiles != null && supportedFiles.Any() && supportedFiles.Any(f => f.Extension.ToUpper() == ".FASTA"))
                    {
                        tabProteinSearch.Focus();
                    }
                }

                monosfound = false;
            }
            catch (BadImageFormatException badFormatEx)
            {
                if (App.Log != null) App.Log.WriteEntry(badFormatEx.Message + " - " + badFormatEx.Source + "\n\n" + badFormatEx.StackTrace, EventLogEntryType.Error);

                if (Environment.Is64BitProcess)
                    System.Windows.MessageBox.Show(this, "This file needs to be run on a 32-bit version of Windows.  \n" + badFormatEx.Message, "Failed to open a file", MessageBoxButton.OK, MessageBoxImage.Exclamation);
                else
                    System.Windows.MessageBox.Show(this, "This file needs to be run on a 64-bit version of Windows.  \n" + badFormatEx.Message, "Failed to open a file", MessageBoxButton.OK, MessageBoxImage.Exclamation);
            }
            catch (Exception ex)
            {
                if (App.Log != null) App.Log.WriteEntry(ex.Message + " - " + ex.Source + "\n\n" + ex.StackTrace, EventLogEntryType.Error);

                System.Windows.MessageBox.Show(this, "Error while loading a file.  " + ex.Message, "Failed to open a file", MessageBoxButton.OK, MessageBoxImage.Exclamation);
            }
        }

        ///// <summary>
        ///// Unload Agilent File
        ///// </summary>
        //void UnloadAgilentFile()
        //{
        //    ClearLoadedFiles();
        //}

        ///// <summary>
        ///// Unload RAW File
        ///// </summary>
        //void UnloadRAWFile()
        //{
        //    ClearLoadedFiles();
        //}

        /// <summary>
        /// Clear All the charts and spectrum
        /// </summary>
        void ResetChartsAndGrids()
        {
            Dispatcher.Invoke((Action)(() =>
               {
                   ///Clearing all the charts.
                   XIC_Chart.Series[0].DataSource = null;
                   XIC_Chart.Tag = "";
                   foreach (var Title in XIC_Chart.Titles)
                   {
                       Title.Text = string.Empty;
                   }

                   foreach (var Title in BPI_Chart.Titles)
                   {
                       Title.Text = string.Empty;
                   }

                   foreach (var Title in BPM_Chart.Titles)
                   {
                       Title.Text = string.Empty;
                   }

                   foreach (var Title in TIC_Chart.Titles)
                   {
                       Title.Text = string.Empty;
                   }

                   foreach (var series in XIC_Chart.Series)
                   {
                       series.DataPoints.Clear();
                       series.DataSource = null;
                   }


                   foreach (var series in TIC_Chart.Series)
                   {
                       series.DataPoints.Clear();
                       series.DataSource = null;
                   }

                   foreach (var series in BPI_Chart.Series)
                   {
                       series.DataPoints.Clear();
                       series.DataSource = null;
                   }

                   foreach (var series in BPM_Chart.Series)
                   {
                       series.DataPoints.Clear();
                       series.DataSource = null;
                   }


                   ///Clearing the Spectrum
                   lblTheoreticalMass.Content = string.Empty;
                   lblExperimentalMass.Text = string.Empty;
                   lblValidationDeltaMass.Content = string.Empty;
                   txtScanNum.Text = string.Empty;
                   btnPrevious.IsEnabled = false;
                   txtScanNum.IsEnabled = false;
                   btnNext.IsEnabled = false;

                   foreach (var Titles in BottomChart.Titles)
                   {
                       Titles.Text = string.Empty;
                   }

                   btnSetManualParentMass.Visibility = System.Windows.Visibility.Hidden;
                   ThermoSlider.Visibility = System.Windows.Visibility.Hidden;
                   slider1.Visibility = System.Windows.Visibility.Hidden;
                   label1.Visibility = System.Windows.Visibility.Hidden;
                   grdDirection.Visibility = System.Windows.Visibility.Hidden;
                   lblForward.Visibility = System.Windows.Visibility.Hidden;
                   lblReverse.Visibility = System.Windows.Visibility.Hidden;
                   sldDirectionSlider.Visibility = System.Windows.Visibility.Hidden;

                   ///Clearing Validate tab
                   txtValidateSequenceWithSpectrum.Text = string.Empty;
                   lblbandyionspercent.Content = string.Empty;
                   lblbandyionpercentagehidden.Content = string.Empty;
                   dtgridBandYIons.ItemsSource = null;



                   //BottomChart.IsEnabled = false;

                   btnFindSequenceinSpectrum.IsEnabled = false;
                   btnClearSpectrumAll.IsEnabled = false;

                   Dispatcher.Invoke((Action)(() =>
                   {

                       foreach (var series in ErrorPlot.Series)
                       {
                           series.DataPoints.Clear();
                           series.DataSource = null;
                       }

                       foreach (var series in BottomChart.Series)
                       {
                           series.DataPoints.Clear();
                           series.DataSource = null;
                       }

                       tbAutoScan.Focus();
                       grdMerge1.ItemsSource = null;
                       dtgridsequences.ItemsSource = null;
                       tabTIC.IsEnabled = false;
                       tabBPI.IsEnabled = false;
                       tabBPM.IsEnabled = false;
                       tabXIC.IsEnabled = false;
                       tbValidate.IsEnabled = false;
                       BottomChart.IsEnabled = false;
                       BottomChart.Visibility = Visibility.Hidden;
                       //tbDenovoResults.IsEnabled = false;
                       tabItem1.IsEnabled = false;
                       tbGreenMarkers.IsEnabled = false;
                       tbMatchList.IsEnabled = false;
                       tbMonoMassList.IsEnabled = false;
                       tbMergeSpectra.IsEnabled = false;
                       dtgridsequences.Visibility = System.Windows.Visibility.Hidden;
                       btnFindAA.Visibility = System.Windows.Visibility.Visible;
                       btnFindAA.IsEnabled = false;
                   }));
               }));
        }


        /// <summary>
        /// Clear all the bindings associated with when a SSRXML file is loaded.
        /// </summary>
        void UnloadSequenceSearchResults()
        {
            DechargerVM.ClearResults();
            UpdateWorkspaceTitle();

            BoundSequences.Clear();
            //txtblkSequenceSearchResult.Visibility = System.Windows.Visibility.Hidden;
        }

        /// <summary>
        /// Loads a SequenceSearch Results (or Workspace) saved from an auto scan into the tool.
        /// </summary>
        /// <param name="filename"></param>
        void LoadWorkspace(FileSystemInfo file)
        {
            XmlSerializer serializer = new XmlSerializer(typeof(SearchSummary));
            var filename = App.FileName;

            DechargerVM.UseFasta = true;
            App.FASTAName = DechargerVM.SpectralDataFilename + ".fasta";

            if (MainPointProvider == null)
            {
                grdMerge1.ItemsSource = null;
                dtgridsequences.ItemsSource = null;
                tabTIC.IsEnabled = false;
                tabBPI.IsEnabled = false;
                tabBPM.IsEnabled = false;
                tabXIC.IsEnabled = false;
                //tbValidate.IsEnabled = false;
                BottomChart.IsEnabled = false;
                //tbDenovoResults.IsEnabled = false;
                tabItem1.IsEnabled = false;
                tbGreenMarkers.IsEnabled = false;
                tbMatchList.IsEnabled = false;
                tbMonoMassList.IsEnabled = false;
                tbMergeSpectra.IsEnabled = false;
            }

            // Based on: http://stackoverflow.com/questions/1625042/the-process-cannot-access-the-file-because-it-is-being-used-by-another-process
            // Based on: http://stackoverflow.com/questions/30687987/unable-to-decompress-bz2-file-has-orginal-file-using-dotnetzip-library/32850209


            //When opening as an attachment in outlook, the temp file created is Read-Only.  So we must open it as such or else, an exception is thrown.  

            //Readonly files should be detected, files opened in readonly mode should be marked in the UI and Curation saving buttons, curation deletion, and the save button should be disabled.  

            //var shareMode = FileShare.Read;

            //if ((file.Attributes & FileAttributes.ReadOnly) != FileAttributes.ReadOnly) shareMode = FileShare.ReadWrite;

            // Actually, after further thought, the files are never edited.  When a change is made, it is made in memory and when a save is attempted is when an error would be thrown with a read-only file.  The only change is to handle that
            // exception by offering to save a copy in a new location.  So show the "save as" dialog.  

            using (var fs = file.Name.ToUpper().EndsWith("SSR") ? new ZipInputStream(new FileStream(file.FullName, FileMode.Open, FileAccess.Read)) as Stream : new FileStream(file.FullName, FileMode.Open, FileAccess.Read, FileShare.Read))
            {

                if (fs is ZipInputStream)  // .SSR files are presumed to be zipped
                {
                    (fs as ZipInputStream).GetNextEntry();  // take the first file entry within the zip (additional files would be ignored by this code)
                }

                var deserializedSearchSummary = (SearchSummary)serializer.Deserialize(fs);

                if (string.IsNullOrWhiteSpace(DechargerVM.SpectralDataFilename) == false)
                {
                    switch (DecideWhetherToUnload(DechargerVM.SpectralDataFilename, deserializedSearchSummary.SpectralDataFilename))
                    {
                        case LoadCurrentFile.Load: //If the result is load, then load the current file
                            break;
                        case LoadCurrentFile.Unload: //If the result is unload, then check the file type and unload the file
                            ResetChartsAndGrids();
                            MainPointProvider = null;
                            DechargerVM.Clear();


                            break;
                        case LoadCurrentFile.Pass: // If the result is pass, then don't load or unload the file.
                            loadraworagilent = false;
                            return;
                        default:
                            break;
                    }
                }

                // Clear out any old results.  
                DechargerVM.ClearResults();



                App.SSRXMLMatchTolerancePPM = deserializedSearchSummary.CurrentSettings.MatchTolerancePPMs;
                App.XMLFileName = deserializedSearchSummary.SpectralDataFilename;
                //txtblkSequenceSearchResult.Visibility = System.Windows.Visibility.Visible;
                Properties.Settings.Default.MatchTolerancePPM = deserializedSearchSummary.CurrentSettings.MatchTolerancePPMs;
                Properties.Settings.Default.MassTolerancePPM = deserializedSearchSummary.CurrentSettings.MassTolerancePPMs;


                App.FASTAName = deserializedSearchSummary.SpectralDataFilename + ".fasta";

                if (filename == null)
                {
                    BottomChart.Titles[1].Text = "";

                }

                //txtblkSequenceSearchResult.ToolTip = "Username : " + deserializedSearchSummary.UserName + "   UserID: " + deserializedSearchSummary.UserID + "  DateTime:  " + deserializedSearchSummary.CurrentDateTime;



                switch (deserializedSearchSummary.VersionNumber)
                {
                    case 1:
                        break;
                    case 2:
                        //SetSettingsfromXML(sqsssrlst);
                        break;
                    default:
                        break;
                }

                //SetSettingsfromXML(sqsssrlst);
                ///Looping through the collection to set the Parent
                ///since the Parent couldn't be serialized.
                foreach (var sqs in deserializedSearchSummary.SearchResults)
                {
                    foreach (var crnti in sqs.CurntIons)
                    {
                        foreach (var crntp in crnti.Peaks)
                        {
                            crntp.Parent = crnti;
                        }
                    }
                }

                DechargerVM.SearchResults.AddRange(deserializedSearchSummary.SearchResults);

                App.lstFasta = GetFastafromSequenceSearch(deserializedSearchSummary.SearchResults);
                App.FASTAName = "SSR.fasta";

                // NEW RESULTS ARE NOW LOADED!! 
                DechargerVM.WorkspaceDirectory = System.IO.Path.GetDirectoryName(file.FullName);
                DechargerVM.WorkspaceFilename = file.Name; // not sure if this is right... deserializedSearchSummary.SpectralDataFilename;
                DechargerVM.CurrentFilesLoaded.Add(file.Name);
                DechargerVM.SpectralDataFilename = deserializedSearchSummary.SpectralDataFilename;
                DechargerVM.SpectralDataFileHash = deserializedSearchSummary.SpectralDataFileHash;
                DechargerVM.SearchStartTime = deserializedSearchSummary.SearchStartTime;
                DechargerVM.SearchEndTime = deserializedSearchSummary.SearchEndTime;
                //DechargerVM.CurrentFileType = deserializedSearchSummary.InstrumentType;  // default to Thermo

                UpdateWorkspaceTitle(deserializedSearchSummary.SearchEndTime);
                //dockTools.Title = ToolsDockTitleRoot + " - " + DechargerVM.WorkspaceFilename + (deserializedSearchSummary.SearchEndTime.Year > 2015 ? (" @ " + deserializedSearchSummary.SearchEndTime.ToString("g")) : string.Empty);   

                // update fasta labels in UI
                Dispatcher.Invoke(new Action(() =>
                {
                    lblDataSource.Text = deserializedSearchSummary.SpectralDataFilename + ".fasta";
                    lblFASTAFileName = deserializedSearchSummary.SpectralDataFilename + ".fasta";
                    btnSequenceSearchSource.ToolTip = deserializedSearchSummary.SpectralDataFilename + ".fasta";
                    FASTAFileName = deserializedSearchSummary.SpectralDataFilename + ".fasta";

                    string Applicationname = Assembly.GetExecutingAssembly().GetName().Name;
                    imgSequenceSearchSource.Tag = "File";
                    //imgSequenceSearchSource.Width = 80;
                    BitmapImage logo = new BitmapImage();
                    logo.BeginInit();
                    logo.UriSource = new Uri("pack://application:,,,/" + Applicationname + ";component/Icons/document_32xMD.png");
                    logo.EndInit();
                    imgSequenceSearchSource.Source = logo;
                }));
            }
        }

        /// <summary>
        /// Generate a FASTA file from SequenceSearchlist
        /// </summary>
        /// <param name="?"></param>
        /// <returns></returns>
        List<FASTA> GetFastafromSequenceSearch(IEnumerable<SearchResult> sqssearchlst)
        {
            var fastaEntries = new List<FASTA>();

            List<SearchResult> newsqssearchlst = new List<SearchResult>();

            if (sqssearchlst != null && sqssearchlst.Any())
            {
                newsqssearchlst = sqssearchlst.Where(a => a.Accession != null && a.Accession != string.Empty).GroupBy(a => a.Accession).Select(a => a.First()).ToList(); ///Grouping all the sequences based on accession as we only need to display each protein once.
            }
            if (App.lstFasta == null || App.lstFasta.Count == 0)
            {
                App.lstFasta = new List<FASTA>();
                BoundSequences = new List<SearchResult>();
            }
            App.FASTAName = "SSR.fasta";

            ///Looping through the sequence to create a new FASTA object.
            foreach (var sqssearch in newsqssearchlst)
            {
                // Assigning new FASTA value
                string guid = Convert.ToString(Guid.NewGuid());

                fastaEntries.Add(new FASTA
                {
                    Species = sqssearch.Species != null ? sqssearch.Species : string.Empty,
                    Accession = sqssearch.Accession,
                    Sequence = sqssearch.Sequence != null ? sqssearch.Sequence : string.Empty,
                    Mass = sqssearch.Sequence != null ? sequencelength(sqssearch.Sequence) : 0,
                    Description = sqssearch.Description != null ? sqssearch.Description : string.Empty,
                    SequenceID = guid
                });
                stringbuilderforBlastp.Append(">" + guid + "\n" + sqssearch.Sequence + "\n");
            }

            BoundSequences.Clear();

            foreach (var item in fastaEntries)
            {
                BoundSequences.Add(new SearchResult()
                {
                    Accession = item.Accession,
                    Description = item.Description,
                    Sequence = item.Sequence,
                    //Mass = sequencelength(item.Sequence),
                    Species = item.Species,
                    PairMatch = new List<string>(),
                    //Allthesequencetags = new List<string>(),
                    AllsqsTags = new List<FindSequenceTags.SequenceTag>(),
                    CurntIons = new List<Cluster>(),
                    //DeltaMass = 0,
                    Notagsforhighlight = true,
                    SequenceID = item.SequenceID
                });

            }
            if (BoundSequences.Count != 0)
            {
                dtgrdSearchSequence.ItemsSource = BoundSequences.Take(100).ToList();
                SearchStoryBoard();
                //lstfasta.AddRange(App.lstFasta);
            }

            BackgroundWorker bgworkerforcreatingindexeddatabase = new BackgroundWorker();
            bgworkerforcreatingindexeddatabase.DoWork += bgworkerforcreatingindexeddatabase_DoWork;
            bgworkerforcreatingindexeddatabase.RunWorkerCompleted += bgworkerforcreatingindexeddatabase_RunWorkerCompleted;
            bgworkerforcreatingindexeddatabase.RunWorkerAsync(stringbuilderforBlastp);

            return fastaEntries;
        }

        /// <summary>
        /// Set all the settings from the XML file
        /// </summary>
        /// <param name="sqssrlst"></param>
        void SetSettingsfromXML(SearchSummary sqssrlst)
        {
            Properties.Settings.Default.AgilentAgreed = sqssrlst.CurrentSettings.AgilentAgreed;
            Properties.Settings.Default.AgilentEULA = sqssrlst.CurrentSettings.AgilentEULA;
            Properties.Settings.Default.BinnedLabels = sqssrlst.CurrentSettings.BinnedLabels;
            Properties.Settings.Default.CountBlastHits = sqssrlst.CurrentSettings.CountBlastHits;
            Properties.Settings.Default.DaltonErrorPlot = sqssrlst.CurrentSettings.DaltonErrorPlot;
            Properties.Settings.Default.Emails = sqssrlst.CurrentSettings.Emails;
            Properties.Settings.Default.FragementIonTolerance = sqssrlst.CurrentSettings.FragementIonTolerance;
            Properties.Settings.Default.Genus = sqssrlst.CurrentSettings.Genus;
            Properties.Settings.Default.HaveKnownMods = sqssrlst.CurrentSettings.HaveKnownMods;
            Properties.Settings.Default.HighBin = sqssrlst.CurrentSettings.HighBin;
            Properties.Settings.Default.JumpToXIC = sqssrlst.CurrentSettings.JumpToXIC;
            Properties.Settings.Default.Labels = sqssrlst.CurrentSettings.Labels;
            Properties.Settings.Default.MassTolerancePPM = sqssrlst.CurrentSettings.MassTolerancePPM;
            Properties.Settings.Default.MassTolerancePPMBasedonFileType = sqssrlst.CurrentSettings.MassTolerancePPMBasedonFileType;
            Properties.Settings.Default.MassTolerancePPMs = sqssrlst.CurrentSettings.MassTolerancePPMs;
            Properties.Settings.Default.MatchList = sqssrlst.CurrentSettings.MatchList;
            Properties.Settings.Default.MatchListProfile = sqssrlst.CurrentSettings.MatchListProfile;
            Properties.Settings.Default.MatchTolerancePPMBasedonFileType = sqssrlst.CurrentSettings.MatchTolerancePPMBasedonFileType;
            Properties.Settings.Default.MatchTolerancePPM = sqssrlst.CurrentSettings.MatchTolerancePPM;
            Properties.Settings.Default.MatchTolerancePPMs = sqssrlst.CurrentSettings.MatchTolerancePPMs;
            Properties.Settings.Default.MaximumModifications = sqssrlst.CurrentSettings.MaximumModifications;
            Properties.Settings.Default.MinAgilentThresholdMS1 = sqssrlst.CurrentSettings.MinAgilentThresholdMS1;
            Properties.Settings.Default.MinAgilentThresholdMS2 = sqssrlst.CurrentSettings.MinAgilentThresholdMS2;
            Properties.Settings.Default.MinPeak = sqssrlst.CurrentSettings.MinPeak;
            Properties.Settings.Default.MinThresholdMS1 = sqssrlst.CurrentSettings.MinThresholdMS1;
            Properties.Settings.Default.MinThresholdMS2 = sqssrlst.CurrentSettings.MinThresholdMS2;
            Properties.Settings.Default.ModifiedAminoAcids = sqssrlst.CurrentSettings.ModifiedAminoAcids;
            Properties.Settings.Default.PPMErrorAxisMax = sqssrlst.CurrentSettings.PPMErrorAxisMax;
            Properties.Settings.Default.PPMErrorAxisMin = sqssrlst.CurrentSettings.PPMErrorAxisMin;
            Properties.Settings.Default.PPMErrorPlot = sqssrlst.CurrentSettings.PPMErrorPlot;
            Properties.Settings.Default.SearchAllSpecies = sqssrlst.CurrentSettings.SearchAllSpecies;
            Properties.Settings.Default.SequenceDetectionMode = sqssrlst.CurrentSettings.SequenceDetectionMode;
            Properties.Settings.Default.SequenceTagLength = sqssrlst.CurrentSettings.SequenceTagLength;
            Properties.Settings.Default.ShowHitsWithNoProteinID = sqssrlst.CurrentSettings.ShowHitsWithNoProteinID;
            Properties.Settings.Default.ShowMassTips = sqssrlst.CurrentSettings.ShowMassTips;
            Properties.Settings.Default.ShowOnlyFTMS = sqssrlst.CurrentSettings.ShowOnlyFTMS;
            Properties.Settings.Default.ShowThermo = sqssrlst.CurrentSettings.ShowThermo;
            Properties.Settings.Default.SortByDBHits = sqssrlst.CurrentSettings.SortByDBHits;
            Properties.Settings.Default.SortByScore = sqssrlst.CurrentSettings.SortByScore;
            Properties.Settings.Default.Species = sqssrlst.CurrentSettings.Species;
            Properties.Settings.Default.UnimodModifications = sqssrlst.CurrentSettings.UnimodModifications;
            Properties.Settings.Default.UseBlast = sqssrlst.CurrentSettings.UseBlast;
            Properties.Settings.Default.UseHybridIntensities = sqssrlst.CurrentSettings.UseHybridIntensities;
            Properties.Settings.Default.UseThoroughSearch = sqssrlst.CurrentSettings.UseThoroughSearch;
            Properties.Settings.Default.ValidationModificationsList = sqssrlst.CurrentSettings.ValidationModificationsList;
            Properties.Settings.Default.ValidationModificationsListAminoAcids = sqssrlst.CurrentSettings.ValidationModificationsListAminoAcids;

            Properties.Settings.Default.Save();
        }

        void LoadAgilentFile()
        {
            var aFile = flsinfo;/// sender as DirectoryInfo;

            //App.lstFasta = new List<FASTA>();
            //lblFASTAFileName = string.Empty;
            //lblTheoreticalMass.Content = "";
            if (string.IsNullOrWhiteSpace(DechargerVM.WorkspaceFilename) == false)
            {
                switch (DecideWhetherToUnload(DechargerVM.WorkspaceFilename, DechargerVM.SpectralDataFilename))
                {
                    case LoadCurrentFile.Load:
                        break;
                    case LoadCurrentFile.Unload:
                        App.XMLFileName = string.Empty;  // Comment out?  
                        UnloadSequenceSearchResults();
                        ///UnloadSSRXMLFile();
                        break;
                    case LoadCurrentFile.Pass:
                        loadraworagilent = false;
                        return;
                    default:
                        break;
                }
                //if (UnloadCurrentFile(DeChargerModel.WorkspaceFilename, DeChargerModel.FileName))
                //{
                //    UnloadSSRXMLFile();
                //}
            }

            EnableAllViews();
            //txtblkSequenceSearchResult.Visibility = System.Windows.Visibility.Hidden;
            lblExperimentalMass.Text = string.Empty;
            lblAutoScanNumberofScans.Content = string.Empty;
            fastasequences.Clear();
            BoundSequences.Clear();
            LocalAccessionIndex = 1;
            //App.FileName = aFile.Name;
            //FASTAFileName = string.Empty;
            //btnSequenceSearchSource.ToolTip = string.Empty;
            Properties.Settings.Default.MatchTolerancePPM = Convert.ToDouble(Properties.Settings.Default.MatchTolerancePPMBasedonFileType[0]);
            Properties.Settings.Default.MassTolerancePPM = Convert.ToDouble(Properties.Settings.Default.MassTolerancePPMBasedonFileType[0]);
            fileLoadWorkers.Clear();

            if (Properties.Settings.Default.AgilentAgreed == false)
            {
                Properties.Settings.Default.AgilentAgreed = true;
                Properties.Settings.Default.Save();
            }
            //dtgridConfirmedSequences.ItemsSource = null;
            App.CurrentFileType = clsFileType.MSFileType.Agilent;

            MainPointProvider = new AgilentProvider(aFile as DirectoryInfo, Properties.Settings.Default.MinAgilentThresholdMS1, Properties.Settings.Default.MinAgilentThresholdMS2) { MassTolerance = Properties.Settings.Default.MassTolerancePPM };

            if (DechargerVM.SpectralDataFilename != aFile.Name)
            {
                DechargerVM.ClearResults();
                if (DechargerVM.CurrentFilesLoaded.Contains(DechargerVM.SpectralDataFilename)) DechargerVM.CurrentFilesLoaded.Remove(DechargerVM.SpectralDataFilename);
                UpdateWorkspaceTitle();
            }

            DechargerVM.SpectralDataFilename = aFile.Name;
            DechargerVM.CurrentFilesLoaded.Add(DechargerVM.SpectralDataFilename);

            DechargerVM.CurrentFileType = clsFileType.MSFileType.Agilent;
        }

        /// <summary>
        /// Load, unload or pass the currentfile
        /// </summary>
        enum LoadCurrentFile
        {
            /// <summary>
            /// Load the current file because the Search results and raw data go together
            /// </summary>
            Load,
            /// <summary>
            /// Unload the conflicting files (or all files) and load the file
            /// </summary>
            Unload,
            /// <summary>
            /// Do nothing with the current file -- Load Nothing and exit
            /// </summary>
            Pass
        }


        /// <summary>
        /// If the files are different Show a MessageBox if the user wants to unload the current file.
        /// If the user wants to replace the file then return Unload the file.
        /// If both the files are same then load the current file or if the user doesn't want to unload the file then pass, which is do nothing.
        /// </summary>
        /// <param name="CurrentFileName"></param>
        /// <param name="NewFileName"></param>
        /// <returns></returns>
        LoadCurrentFile DecideWhetherToUnload(string CurrentFileName, string NewFileName)
        {
            if (CurrentFileName == NewFileName)
            {
                return LoadCurrentFile.Load;
            }
            else
            {
                var result = System.Windows.MessageBox.Show("The Spectral data file and the Results data file have conflicting data sources. Any unsaved Confirmations and Autoscans may be lost. Do you want to continue?", ///Message
                                                            "Load new file and discard current file?", ///Caption
                                                            MessageBoxButton.YesNo,
                                                            MessageBoxImage.Question,
                                                            MessageBoxResult.Yes,
                                                            MessageBoxOptions.DefaultDesktopOnly);

                if (result == MessageBoxResult.Yes)
                {
                    return LoadCurrentFile.Unload;
                }
                else
                {
                    return LoadCurrentFile.Pass;
                }
            }
        }


        /// <summary>
        /// Delete all the files in a given folder
        /// </summary>
        /// <param name="folderpath"></param>
        void DeleteFilesfromFolder(string folderpath)
        {
            System.IO.DirectoryInfo di = new DirectoryInfo(folderpath);

            foreach (FileInfo file in di.GetFiles())
            {
                file.Delete();
            }
            foreach (DirectoryInfo dir in di.GetDirectories())
            {
                dir.Delete(true);
            }
        }

        void bgworkerforcreatingindexeddatabase_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            if (e.Result != null && e.Result is Exception)
            {
                // throw the exception from the worker!  
                throw e.Result as Exception;
            }
        }

        void bgworkerforcreatingindexeddatabase_DoWork(object sender, DoWorkEventArgs e)
        {
            if (e.Argument != null && e.Argument is StringBuilder)
            {
                try
                {
                    BlastP.CreateBlastDatabase(e.Argument as StringBuilder);
                    e.Result = null;
                }
                catch (Exception ex)
                {
                    e.Result = ex;
                }
            }
            else
            {
                e.Result = new Exception("Invalid argument passed to bgworkerforcreatingindexeddatabase_DoWork");
            }

            //Dispatcher.Invoke(new Action(() =>
            //{
            //    try
            //    {
            //        BlastP.CreateBlastDatabase(stringbuilderforBlastp);
            //    }
            //    catch (Exception ex)
            //    {
            //        throw;
            //    }
            //}));
        }

        void AddChromatogramCursor(Chart aChart)
        {
            aChart.PlotArea = new PlotArea() { Tag = aChart };
            aChart.PlotArea.MouseMove += PlotArea_MouseMove;
            aChart.PlotArea.MouseMove += ChromPlotArea_MouseMove;
            aChart.PlotArea.MouseLeave += PlotArea_MouseLeave;
            aChart.PlotArea.MouseLeave += ChromPlotArea_MouseLeave;
            aChart.PlotArea.MouseEnter += PlotArea_MouseEnter;
            aChart.PlotArea.MouseLeftButtonDown += Chrom_MouseLeftButtonDown;
            aChart.PlotArea.MouseLeftButtonUp += Chrom_MouseLeftButtonUp;
            aChart.PlotArea.MouseRightButtonDown += Chrom_MouseRightButtonDown;
            aChart.PlotArea.MouseRightButtonUp += Chrom_MouseRightButtonUp;
            //aChart.PlotArea.PreviewMouseLeftButtonUp += new MouseButtonEventHandler(PlotArea_PreviewMouseLeftButtonUp);

            //aChart.MouseLeftButtonUp += new MouseButtonEventHandler(aChart_MouseLeftButtonUp);

            var t1 = new TrendLine() { Orientation = Orientation.Vertical, Opacity = 0 };
            aChart.TrendLines.Insert(0, t1);  // Red Cursor Line
            var t2 = new TrendLine() { Orientation = Orientation.Vertical, LineStyle = LineStyles.Dotted, LineColor = new SolidColorBrush(Colors.Gray), Opacity = 0 };
            aChart.TrendLines.Insert(1, t2);  // Current Scan
            var t3 = new TrendLine() { Orientation = Orientation.Vertical, LineColor = new SolidColorBrush(Colors.LightGray), Opacity = 0 };
            //            var t3 = new TrendLine() { Orientation = Orientation.Vertical, LineColor = new SolidColorBrush(Colors.AliceBlue), Opacity = 0 };
            aChart.TrendLines.Insert(2, t3);  // Selection box

            var t4 = new TrendLine() { Orientation = Orientation.Vertical, LineColor = new SolidColorBrush(Colors.LightGreen), Opacity = 0 };
            aChart.TrendLines.Insert(3, t4);  // Quantitation Selection box

            Chromatograms.Add(aChart);
        }

        void aChart_MouseLeftButtonUp(object sender, MouseButtonEventArgs e)
        {
            throw new NotImplementedException();
        }

        void PlotArea_PreviewMouseLeftButtonUp(object sender, MouseButtonEventArgs e)
        {
            throw new NotImplementedException();
        }

        void AddSpectrumCursor(Chart aChart)
        {
            aChart.PlotArea = new PlotArea() { Tag = aChart };
            aChart.PlotArea.MouseMove += PlotArea_MouseMove;
            aChart.PlotArea.MouseLeave += PlotArea_MouseLeave;
            aChart.PlotArea.MouseEnter += PlotArea_MouseEnter;
            aChart.PlotArea.MouseLeftButtonDown += Spec_MouseLeftButtonDown;
            aChart.PlotArea.MouseRightButtonDown += Spec_MouseRightButtonDown;
            var t = new TrendLine() { Orientation = Orientation.Vertical, Opacity = 0 };
            aChart.TrendLines.Insert(0, t);
            var t2 = new TrendLine() { Orientation = Orientation.Vertical, LineStyle = LineStyles.Solid, LineColor = new SolidColorBrush(Colors.Green) };
            aChart.TrendLines.Insert(1, t2);
        }

        void Spec_MouseLeftButtonDown(object sender, PlotAreaMouseButtonEventArgs e)
        {
            // Snaps the offset value to the nearest monomass or other feature

            //if (MainPointProvider == null) return;

            var viewWidth = Math.Abs((double)((sender as PlotArea).Tag as Chart).AxesX[0].ViewMaximum - (double)((sender as PlotArea).Tag as Chart).AxesX[0].ViewMinimum);
            var widthPerPixel = viewWidth / ((sender as PlotArea).Tag as Chart).AxesX[0].ActualWidth;

            var totalTolerance = PixelTolerance * widthPerPixel * 3;

            var start = ((double)e.XValue) - totalTolerance;
            var end = ((double)e.XValue) + totalTolerance;


            // Find nearest MonoMass? 
            if (CurrentMonoMasses != null && CurrentMonoMasses.Count > 0)
            {
                // Find the closest monoMZ within the tolerance...
                var candidates = CurrentMonoMasses.Where(p => (double)p.XValue > start && (double)p.XValue < end).OrderByDescending(s => Math.Abs((double)s.XValue - (double)e.XValue));
                if (candidates.Any())
                {
                    OffsetStart = (double)candidates.First().XValue;
                    return;
                }
            }

            // allow the left click to snap secondarily to reverse mono peaks
            if (ReverseCurrentMonomasses != null && ReverseCurrentMonomasses.Count > 0)
            {
                // Find the closest monoMZ within the tolerance...
                var candidates = ReverseCurrentMonomasses.Where(p => (double)p.XValue > start && (double)p.XValue < end).OrderByDescending(s => Math.Abs((double)s.XValue - (double)e.XValue));
                if (candidates.Any())
                {
                    OffsetStart = (double)candidates.First().XValue;
                    return;
                }
            }

            // allow the left click to snap to parent Mass and 0
            if (CurrentSpectrum.ParentMass.HasValue)
            {
                var ends = new List<double>(); // { 0, Molecules.Water };

                // The ends are 0 and the ParentMass, but since we don't know which end is the C terminus, we allow locking to a mass shifted by the fragment ends.  
                // Note: Different activations may require a difference mass!  We are assuming b/y ions
                ends.Add(0);
                ends.Add(Molecules.Water);

                if (CurrentSpectrum.ParentMass.HasValue)
                {
                    ends.Add(CurrentSpectrum.ParentMass.Value);
                    ends.Add(CurrentSpectrum.ParentMass.Value - Molecules.Water);
                }

                // Find the closest monoMZ within the tolerance...
                var candidates = ends.Where(p => p > start && p < end).OrderByDescending(s => Math.Abs(s - (double)e.XValue));

                if (candidates.Any())
                {
                    OffsetStart = candidates.First();
                    return;
                }
            }

            // Find nearest/intense point? 
            if (CurrentSpectrum != null && CurrentSpectrum.Count > 0)
            {
                var candidate = CurrentSpectrum.GetItemWithMaxYValueForXRange(start, end);

                if (candidate == null) return;

                if (CurrentSpectrum.IsSortedByMZ)
                    OffsetStart = candidate.MZ;
                else
                    OffsetStart = candidate.Mass;

                return;
            }

            OffsetStart = (double)e.XValue;

            return;
        }

        void Spec_MouseRightButtonDown(object sender, PlotAreaMouseButtonEventArgs e)
        {
            //SpecRightClickSpot = (double)e.XValue;

            var xvalue = (double)BottomChart.TrendLines[0].Value;
            //xvalue = (SpecRightClickSpot.Start + SpecRightClickSpot.End) / 2d;  // average

            if (xvalue == 0) xvalue = (double)e.XValue;


            var candidates = CurrentMonoMasses.Where(w => Math.Abs((double)w.XValue - xvalue) < Math.Min(zoomWidth / 12, 10)).OrderBy(i => Math.Abs((double)i.XValue - xvalue));
            var candidateIons = CurrentIons.Where(w => Math.Abs((double)w.MonoMass - xvalue) < Math.Min(zoomWidth / 12, 10)).OrderBy(i => Math.Abs((double)i.MonoMass - xvalue)); ;


            if (xvalue != 0 && candidates.Any())
            {
                // Update Menu Show/Hide based on the presence of a peak.  
                //var targetIon2 = CurrentIons.MinBy(i => Math.Abs(i.MonoMass - (double)e.XValue));
                //if (MonoMasslabel.DataPoints.Where(h => (double)h.XValue == targetIon2.MonoMass).Any())
                this.mnuShowMonoLabel.IsEnabled = true;

                var targetIon2 = candidates.First(); // CurrentMonoMasses.MinBy(i => Math.Abs((double)i.XValue - (double)e.XValue));

                if (MonoMasslabel.DataPoints.Where(h => (double)h.XValue == (double)targetIon2.XValue).Any())
                {
                    this.mnuShowMonoLabel.Header = "Hide Mono Label";
                    this.mnuShowMonoLabel.Tag = new MonoLabelAction() { Show = false, Mass = (double)targetIon2.XValue };
                }
                else
                {
                    this.mnuShowMonoLabel.Header = "Show Mono Label";
                    this.mnuShowMonoLabel.Tag = new MonoLabelAction() { Show = true, Mass = (double)targetIon2.XValue, Intensity = (float)targetIon2.YValue, Z = (int)targetIon2.ZValue };
                }
            }
            else if (xvalue != 0 && candidateIons.Any())
            {
                this.mnuShowMonoLabel.IsEnabled = true;
                this.mnuShowMonoLabel.Header = "Show Mono Label";
                this.mnuShowMonoLabel.Tag = new MonoLabelAction() { Show = true, Mass = candidateIons.First().MonoMass, Intensity = candidateIons.First().Intensity, Z = candidateIons.First().Z };
            }
            else
            {
                this.mnuShowMonoLabel.IsEnabled = false;
                this.mnuShowMonoLabel.Tag = null;
            }


            MenuItem9.IsEnabled = (CurrentMonoMasses != null && CurrentMonoMasses.Any());

            try
            {
                var viewWidth = Math.Abs((double)((sender as PlotArea).Tag as Chart).AxesX[0].ViewMaximum - (double)((sender as PlotArea).Tag as Chart).AxesX[0].ViewMinimum);
                var widthPerPixel = viewWidth / ((sender as PlotArea).Tag as Chart).AxesX[0].ActualWidth;

                var totalTolerance = PixelTolerance * widthPerPixel * 3;

                var start = ((double)e.XValue) - totalTolerance;
                var end = ((double)e.XValue) + totalTolerance;

                SpecRightClickSpot.Start = start;
                SpecRightClickSpot.End = end;

                var targets = FindBestXicTargets(start, end);

                if (targets == null)
                {
                    this.MenuItem8.IsEnabled = false;
                    this.MenuItem8.Header = "XIC Disabled (Click on peak)";
                    return;
                }

                this.MenuItem8.Header = "XIC for ";

                foreach (var aTarget in targets)
                    this.MenuItem8.Header += aTarget.Start.ToString("0.0") + " to " + aTarget.End.ToString("0.0") + "; ";

                this.MenuItem8.Header = this.MenuItem8.Header.ToString().TrimEnd(';', ' ');

                this.MenuItem8.IsEnabled = true;


            }
            catch
            {
                this.MenuItem8.IsEnabled = false;
                this.MenuItem8.Header = "XIC Disabled (Click on peak)";

                //System.Windows.MessageBox.Show("XIC Calculation Error!");
            }
        }

        internal List<Cluster> FindChargeVariants(Cluster cluster)
        {

            // Enhanced Mono Mass Detection 
            // 1. Group ions by shared peaks
            // 2. Take MonoMass of ions in group with the highest score
            // 3. Add to CurrentMonoMasses List

            //var alreadyGrouped = new List<Cluster>();
            var variants = new List<Cluster>() { cluster };

            //foreach (var anIon in CurrentIons.Where(m => m.MonoMass > cluster.MonoMass - 2.2 && m.MonoMass < cluster.MonoMass + 2.2).OrderByDescending(i => i.Score))
            foreach (var anIon in MergedIons.Where(m => m.MonoMass > cluster.MonoMass - 2.2 && m.MonoMass < cluster.MonoMass + 2.2).OrderByDescending(i => i.Score))
            {
                if (variants.Where(i => i.Z == anIon.Z).Any()) continue;
                //var currentGroup = new List<Cluster>() { anIon };

                //foreach (var anotherIon in CurrentIons.OrderByDescending(i => i.Score))
                //{
                //    if (variants.Contains(anotherIon)) continue;
                if (Cluster.SimilarClusters(anIon, cluster)) variants.Add(anIon);
                //}

                //CurrentMonoMasses.Add(new DataPoint() { XValue = anIon.MonoMass, YValue = anIon.Intensity, ZValue = anIon.Z });
                //alreadyGrouped.AddRange(currentGroup);


            }

            return variants;

            //monosfound = false;
        }

        internal Cluster FindClosestCluster(double start, double end)
        {

            var x = CurrentSpectrum.Where(p => p.Mass < end && p.Mass > start);
            //var y = x.Select(a => a)
            var y = x.Select(r => r.Parent);
            var c = y.Distinct();

            var goodClusters = new List<Cluster>();

            foreach (var cluster in c)
            {
                // find the clusters where the apex is close to the selected area
                var topIndexes = Enumerable.Range(0, cluster.IsoPattern.Length - 1).Where(i => cluster.IsoPattern[i] > 0.7);

                if (cluster.Peaks.Where(p => p.Mass > start && p.Mass < end && topIndexes.Any(r => r == p.IsoIndex)).Any()) goodClusters.Add(cluster);
            }

            //goodClusters = goodClusters.OrderByDescending(g => g.Score).Take(10).ToList();

            var d = goodClusters.OrderByDescending(s => s.Peaks.Where(a => a.IsCorePeak).OrderByDescending(t => t.Intensity).Take(5).Select(b => b.Intensity).Median());
            //var medians = c.Select(s => s.Peaks.Where(a => a.IsCorePeak));
            //var medians1 = c.Select(s => s.Peaks.Where(a => a.IsCorePeak).Select(b => b.Intensity).Median());

            //var bestFits = CurrentSpectrum.Where(p => p.Mass < end && p.Mass > start && p.IsCorePeak).Select(r => r.Parent).Distinct().OrderByDescending(s => s.Peaks.Where(a => a.IsCorePeak).Select(b => b.Intensity).Median());

            //var bestCluster = bestFits.First();

            //return bestCluster;

            return d.FirstOrDefault();
        }

        internal List<Range> FindBestXicTargets(double start, double end, bool singleRange = true)
        {
            return FindBestXicTargets(FindClosestCluster(start, end), singleRange);
        }

        string Querystring = string.Empty;

        void SearchDataGrid(string Querystr)
        {
            if ((NetworkInterface.GetIsNetworkAvailable() && db.State == ConnectionState.Open) || DechargerVM.UseFasta)
            {
                Debug.Print(DateTime.Now.ToString("hh.mm.ss.ffffff") + " SearchDataGrid: " + Querystr);

                SearchStoryBoard();

                dtgrdSearchSequence.IsEnabled = true;

                //rn = new BindableRichTextBox();
                Querystring = Querystr;

                BoundSequences.Clear();
                dtgridsequences.UnselectAll();
                if (Properties.Settings.Default.UseBlast && Querystr.Length > 4)
                {
                    Dispatcher.Invoke(new Action(() =>
                    {
                        dtgrdtxtExpectValue.Visibility = System.Windows.Visibility.Visible;
                    }));
                }
                else
                {
                    Dispatcher.Invoke(new Action(() =>
                    {
                        dtgrdtxtExpectValue.Visibility = System.Windows.Visibility.Collapsed;
                    }));
                }
                BackgroundWorker bgsearchdatagrid = new BackgroundWorker();
                bgsearchdatagrid.DoWork += bgsearchdatagrid_DoWork;
                bgsearchdatagrid.RunWorkerCompleted += bgsearchdatagrid_RunWorkerCompleted;
                bgsearchdatagrid.RunWorkerAsync();

                if (!DechargerVM.UseFasta)
                {
                    //if (fromautoscan)
                    //{
                    //    Dispatcher.Invoke(new Action(() =>
                    //    {
                    //        busyIndicator.IsBusy = true;
                    //        busyIndicator.BusyContent = "Searching the database";
                    //        this.IsFileBusyProgressIndeterminate = true;
                    //        this.ShowStopButton = System.Windows.Visibility.Collapsed;
                    //    }));
                    //}
                    //else
                    {
                        Dispatcher.Invoke(new Action(() =>
                        {
                            tabProteinSearch.Focus();
                            bsySearchDatabase.IsBusy = true;
                            bsySearchDatabase.BusyContent = "Searching the database";
                            this.FileBusyProgressText = "Searching the database";
                            this.IsFileBusyProgressIndeterminate = true;
                            this.ShowStopButton = System.Windows.Visibility.Collapsed;
                        }));
                    }
                }
                else
                {
                    //if (fromautoscan)
                    //{
                    //    Dispatcher.Invoke(new Action(() =>
                    //    {
                    //        busyIndicator.IsBusy = true;
                    //        busyIndicator.BusyContent = "Searching the File";
                    //        this.IsFileBusyProgressIndeterminate = true;
                    //        this.ShowStopButton = System.Windows.Visibility.Collapsed;
                    //    }));
                    //}
                    //else
                    {
                        Dispatcher.Invoke(new Action(() =>
                        {
                            tabProteinSearch.Focus();
                            bsySearchDatabase.IsBusy = true;
                            bsySearchDatabase.BusyContent = "Searching the File";
                            this.FileBusyProgressText = "Searching the File";
                            this.IsFileBusyProgressIndeterminate = true;
                            this.ShowStopButton = System.Windows.Visibility.Collapsed;
                        }));
                    }
                }
            }
            else
            {
                System.Windows.MessageBox.Show("There is no Protein Database available.  Please drag/drop a FASTA file or if you are using an SQL Server, please check your network connection and database.", "No Protein Data Source");
            }

            Debug.Print(DateTime.Now.ToString("hh.mm.ss.ffffff") + " SearchDataGrid Complete: " + Querystr);
        }

        void bgsearchdatagrid_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            Debug.Print(DateTime.Now.ToString("hh.mm.ss.ffffff") + " bgsearchdatagrid_RunWorkerCompleted");

            if (e.Result == null)
            {
                if (fromautoscan)
                    busyIndicator.IsBusy = false;
                bsySearchDatabase.IsBusy = false;
                return;
            }
            else if (e.Result is string)
            {
                if (fromautoscan)
                    busyIndicator.IsBusy = false;
                bsySearchDatabase.IsBusy = false;
                System.Windows.MessageBox.Show(e.Result as string);
                return;
            }
            else if (e.Result is IEnumerable<SearchResult>)
            {
                BoundSequences = (e.Result as IEnumerable<SearchResult>).ToList();
                DisplayDescription();
                if (BoundSequences.Any() == false)
                {
                    imgSearchInfo.Visibility = System.Windows.Visibility.Hidden;
                    imgSearchWarning.Visibility = System.Windows.Visibility.Hidden;
                }
                else if (BoundSequences.Count > 100)
                {
                    imgSearchInfo.Visibility = System.Windows.Visibility.Hidden;
                    imgSearchWarning.Visibility = System.Windows.Visibility.Visible;
                    imgSearchWarning.ToolTip = "Displaying the first 100 sequences out of " + BoundSequences.Count + " sequences" + ((Properties.Settings.Default.SearchAllSpecies || DechargerVM.UseFasta) ? string.Empty : "\n*Species Filter Applied");
                    dtgrdSearchSequence.ItemsSource = BoundSequences.Take(100).ToList();
                }
                else
                {
                    imgSearchWarning.Visibility = System.Windows.Visibility.Hidden;
                    imgSearchInfo.Visibility = System.Windows.Visibility.Visible;
                    imgSearchInfo.ToolTip = "Displaying all " + BoundSequences.Count + " sequences" + ((Properties.Settings.Default.SearchAllSpecies || DechargerVM.UseFasta) ? string.Empty : "\n*Species Filter Applied");
                    dtgrdSearchSequence.ItemsSource = BoundSequences;
                }

                bsySearchDatabase.IsBusy = false;
            }

            if (fromautoscan)
            {
                fromautoscan = false;
                busyIndicator.IsBusy = false;
                dtgrdSearchSequence.SelectedIndex = 0;
                btnShowDBSequence_Click(null, null);
            }

        }

        //BindableRichTextBox rn = new BindableRichTextBox();
        bool searchseq = false;
        /// <summary>
        /// Searches for a particular pattern in the database based 
        /// on sequence and filter.
        /// Filter can be either Accession or Description.
        /// Need to add the Scientific name.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void bgsearchdatagrid_DoWork(object sender, DoWorkEventArgs e)
        {
            string[] splitstring = { "[", "!", "@", "$", " ", ",", ".", ";", "{", "}", "/", "]", "or", "OR", "and", "AND" };
            ///Splitting the search term into different strings using the regex
            //string[] searchtext = Regex.Split(Querystring, @"[!@#$ ,.;}{/]");
            string[] searchtext = Querystring.Split(splitstring, StringSplitOptions.RemoveEmptyEntries);
            string sequenceforsearch = string.Empty;
            //Dispatcher.Invoke(new Action(() =>
            //{
            //    dtgridsequences.UnselectAll();
            //}));

            string filter = string.Empty;
            bool sequenceset = false;

            ///Separating the Sequence and filter.
            ///If the term contains only the amino acids entered and is capitalized then
            ///it is a sequence. If not otherwise its part of the filter.
            foreach (string st in searchtext)
            {
                if (Regex.IsMatch(st, @"^[AC-IK-NP-TV-WY*]+$") && !sequenceset)
                {
                    sequenceset = true;
                    sequenceforsearch = st;
                }
                else
                {
                    if (st.Contains("*"))
                    {
                        filter += "\"" + st + "\"" + " ";
                    }
                    else
                    {
                        filter += st + " ";
                    }
                }
            }

            //Dispatcher.Invoke(new Action(() =>
            //    {

            //If the sequence length is less that 3 then ask the user to enter a longer sequence
            if (sequenceforsearch.Length < 3 && filter == string.Empty)
            {
                if (DechargerVM.UseFasta)
                {
                    if (Properties.Settings.Default.UseBlast)
                    {
                        List<string> blastsequences = new List<string>();
                        blastsequences.Add(sequenceforsearch);
                        bool count = false;
                        e.Result = SearchforSequence(sequenceforsearch, sqsalldenovotgs, CurrentIons, currentparent.ParentZ != null ? currentparent.ParentZ.Value : 0, currentparent.ScanNumber, ref count, CurrentSpectrum.ParentIon != null ? CurrentSpectrum.ParentIon.MonoMass : 0, false, blastsequences); ///.Where(a => a.Sequence.Length >= Properties.Settings.Default.SequenceTagLength).ToList()
                    }
                    else
                    {
                        bool count = false;
                        e.Result = SearchforSequence(sequenceforsearch, sqsalldenovotgs, CurrentIons, currentparent.ParentZ != null ? currentparent.ParentZ.Value : 0, currentparent.ScanNumber, ref count, CurrentSpectrum.ParentIon != null ? CurrentSpectrum.ParentIon.MonoMass : 0); ///.Where(a => a.Sequence.Length >= Properties.Settings.Default.SequenceTagLength).ToList()
                    }
                    //Dispatcher.Invoke(new Action(() =>
                    //    {
                    //        BoundSequences = tempSequence.ToList();
                    //        dtgrdSearchSequence.ItemsSource = BoundSequences;///.OrderByDescending(a => a.TagHits);
                    //    }));

                    //Dispatcher.Invoke(new Action(() =>
                    //    {
                    //        dtgrdSearchSequence.DataContext = app.lstFasta.GetRange(0, 100);
                    //    }));
                    return;
                }
                else
                {
                    e.Result = "Sequence should be at least three characters long.";
                    //Dispatcher.Invoke(new Action(() =>
                    //{
                    //    System.Windows.MessageBox.Show("Sequence should be at least three characters long.");
                    //}));
                    return;
                }
            }
            ///Replacing the spaces with or for the filter.
            if (filter != string.Empty)
            {
                filter = filter.Replace(" ", " or ");
                filter = filter.Remove(filter.LastIndexOf(" or "), 4);
            }
            //If no sequence is entered asking the user to enter one.
            if (Querystring == "" || Querystring == null)
            {
                //TODO: If a FASTA file is loaded show all entries when given a blank search

                e.Result = "Please enter a sequence to search.";

                //Dispatcher.Invoke(new Action(() =>
                //    {
                //        System.Windows.MessageBox.Show("Please enter a sequence to search.");
                //    }));
                return;
            }
            //        Dispatcher.Invoke(new Action(() =>
            //{
            //If there is only a sequence then search using that particular term.
            if (Querystring != "" && Querystring != null && sequenceforsearch != "" && sequenceforsearch != null && searchtext.Count() == 1)
            {

                Dispatcher.Invoke(new Action(() =>
                {
                    ComboBox cmb = FindVisualChildByName<ComboBox>(dtgrdSearchSequence, "cmbSpecies");
                    if (cmb != null)
                    {
                        cmb.Items.Clear();
                        cmb.Items.Add("All Species");
                    }

                    //dbsequences.Clear();
                    //dtgrdSearchSequence.ItemsSource = null;
                    searchseq = false;

                    //currentTags = dtgridsequences.DataContext as IEnumerable<FindSequenceTags.SequenceTag>;
                }));

                Debug.Print(DateTime.Now.ToString("hh.mm.ss.ffffff") + " Before SearchforSequence");
                //Dispatcher.Invoke(new Action(() =>
                //{
                //    dtgrdSearchSequence.ItemsSource = null;
                //}));

                IEnumerable<SearchResult> tempSequence = new List<SearchResult>();

                try
                {
                    if (!NetworkInterface.GetIsNetworkAvailable() && !DechargerVM.UseFasta)
                    {
                        e.Result = "No network connectivity. Use FASTA for search";

                        //Dispatcher.Invoke(new Action(() => System.Windows.MessageBox.Show("Please check your network connection", "No network connectivity")));
                        return;
                    }

                    if (Properties.Settings.Default.UseBlast && DechargerVM.UseFasta)
                    {
                        List<string> blastsequences = new List<string>();
                        blastsequences.Add(sequenceforsearch);
                        bool count = false;
                        tempSequence = SearchforSequence(sequenceforsearch, sqsalldenovotgs, CurrentIons, currentparent.ParentZ == null ? 0 : currentparent.ParentZ.Value, currentparent.ScanNumber, ref count, CurrentSpectrum.ParentIon != null ? CurrentSpectrum.ParentIon.MonoMass : 0, false, blastsequences); //.Where(a => a.Sequence.Length >= Properties.Settings.Default.SequenceTagLength).ToList()
                    }
                    else
                    {
                        if (fromautoscan)
                        {
                            bool count = false;
                            tempSequence = SearchforSequence(sequenceforsearch, sqsalldenovotgs, CurrentIons, currentparent.ParentZ == null ? 0 : currentparent.ParentZ.Value, currentparent.ScanNumber, ref count, CurrentSpectrum.ParentIon != null ? CurrentSpectrum.ParentIon.MonoMass : 0);
                            //var ttsequence = SearchforSequence(ReverseString.ReverseStr(sequenceforsearch), sqsalldenovotgs, CurrentIons, CurrentSpectrum.ParentIon != null ? CurrentSpectrum.ParentIon.MonoMass : 0).ToList();
                            var ttsequence = tempSequence.ToList();
                            //ttsequence.AddRange(tempSequence);
                            tempSequence = SortSequenceSearch(ttsequence, CurrentSpectrum.ParentIon.MonoMass);
                        }
                        else
                        {
                            bool count = false;
                            tempSequence = SearchforSequence(sequenceforsearch, sqsalldenovotgs, CurrentIons, currentparent.ParentZ == null ? 0 : currentparent.ParentZ.Value, currentparent.ScanNumber, ref count, CurrentSpectrum.ParentIon != null ? CurrentSpectrum.ParentIon.MonoMass : 0); ///.Where(a => a.Sequence.Length >= Properties.Settings.Default.SequenceTagLength).ToList()
                        }
                    }
                    //tempSequence = new List<SequenceSearch>(dbsequences);

                    var uniqspecies = tempSequence.Select(a => a.Species).Distinct().OrderBy(a => a).ToList();

                    Dispatcher.Invoke(new Action(() =>
                    {
                        //if (!returnfunction)
                        //{
                        ComboBox cmb = FindVisualChildByName<ComboBox>(dtgrdSearchSequence, "cmbSpecies");
                        if (cmb != null)
                        {
                            cmb.Items.Clear();
                            cmb.Items.Add("All Species");
                            foreach (var species in uniqspecies)
                            {
                                cmb.Items.Add(species);
                            }
                            cmb.SelectedIndex = 0;
                        }
                        txtSearchbox.Text = Querystring;
                        if (CurrentSpectrum.ParentIon == null)
                        {
                            dtgrdSStxtDeltaMass.Visibility = System.Windows.Visibility.Collapsed;
                            dtgrdSStxtMass.Visibility = System.Windows.Visibility.Visible;
                        }
                        else
                        {
                            dtgrdSStxtDeltaMass.Visibility = System.Windows.Visibility.Visible;
                            dtgrdSStxtMass.Visibility = System.Windows.Visibility.Collapsed;
                        }
                        //}
                    }));
                }
                catch (WarningException w)
                {
                    Dispatcher.Invoke(new Action(() => System.Windows.MessageBox.Show(this, w.Message, "General Warning", MessageBoxButton.OK, MessageBoxImage.Exclamation)));
                }
                catch (Exception ex)
                {
                    System.Windows.MessageBox.Show("Message: " + ex.Message + " Error :" + ex.InnerException);
                }
                finally
                {
                    Dispatcher.Invoke(new Action(() => bsySearchDatabase.IsBusy = false));
                }

                Debug.Print(DateTime.Now.ToString("hh.mm.ss.ffffff") + " After SearchforSequence");

                e.Result = tempSequence.OrderByDescending(a => a.YellowandGreenTagHits);

                //Dispatcher.Invoke(new Action(() =>
                //{
                //    dtgrdSearchSequence.ItemsSource = tempSequence.OrderByDescending(a => a.TagHits); // SearchforSequence(sequenceforsearch, sqsalltags, CurrentIons);.Where(a => a.TagHits > 0)
                //}));
                Debug.Print(DateTime.Now.ToString("hh.mm.ss.ffffff") + " After bind to ItemSource");
            }
            else if (Querystring != "" && Querystring != null && sequenceforsearch != "" && sequenceforsearch != null && searchtext.Count() > 1)
            {
                //Dispatcher.Invoke(new Action(() =>
                //{
                //    dtgrdSearchSequence.ItemsSource = null;
                //}));
                IEnumerable<MSViewer.SearchResult> tempSequence = SearchforSequenceandfilter(sequenceforsearch, filter, sqsalldenovotgs, CurrentIons, CurrentSpectrum.ParentIon != null ? CurrentSpectrum.ParentIon.MonoMass : 0); // IF there are both sequence and filter use this method  ///.Where(a => a.Sequence.Length >= Properties.Settings.Default.SequenceTagLength).ToList()

                e.Result = tempSequence.OrderByDescending(a => Math.Abs(a.YellowandGreenTagHits));

                //Dispatcher.Invoke(new Action(() =>
                //{
                //    BoundSequences = tempSequence.OrderByDescending(a => Math.Abs(a.TagHits)).ToList();
                //    dtgrdSearchSequence.ItemsSource = BoundSequences;  // SearchforSequenceandfilter(sequenceforsearch, filter, sqsalltags, CurrentIons); // IF there are both sequence and filter use this method.Where(a => a.TagHits > 0)
                //}));
            }
            else if (Querystring != "" && Querystring != null && (sequenceforsearch == "" || sequenceforsearch == null))
            {
                //Dispatcher.Invoke(new Action(() =>
                //                         {
                //                             dtgrdSearchSequence.ItemsSource = null;
                //                         }));
                e.Result = Searchforfilter(filter, sqsalldenovotgs, CurrentIons, CurrentSpectrum.ParentIon != null ? CurrentSpectrum.ParentIon.MonoMass : 0).OrderByDescending(a => Math.Abs(a.YellowandGreenTagHits)); //If only filter is present then use this method ///.ToList().Where(a => a.Sequence.Length >= Properties.Settings.Default.SequenceTagLength).ToList()
                //BoundSequences = tempSequence.OrderByDescending(a => Math.Abs(a.TagHits)).ToList();

                //Dispatcher.Invoke(new Action(() =>
                //{

                //    dtgrdSearchSequence.ItemsSource = tempSequence.OrderByDescending(a => Math.Abs(a.TagHits)).ToList(); ;/// Searchforfilter(filter, sqsalltags, CurrentIons); //If only filter is present then use this method Where(a => a.TagHits > 0).
                //}));
            }
            //}));

            //}));
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="searchTags">Primary amino acid sequence search targets</param>
        /// <param name="allTags">All tags -- used to score prospective protein matches</param>
        /// <param name="spec">Spectral data -- used to score prospective protein matches</param>
        /// <param name="useBlast">Use blast to perform a similarity search</param>
        /// <returns></returns>
        IEnumerable<SearchResult> SearchForProteins(IEnumerable<string> searchTags, IEnumerable<FindSequenceTags.SequenceTag> allTags, SuperSpectrum spec, bool useBlast = true, CancellationToken cToken = default(CancellationToken), bool throwUIExceptions = false)
        {
            if (DechargerVM.UseFasta)
            {
                // Search the proteins in the local FASTA file
                return PerformLocalSearch(searchTags, allTags, spec, useBlast, cToken, throwUIExceptions);
            }
            else
            {
                // Search the Relational Database on the network
                return SearchDatabaseServer(searchTags, allTags, spec, useBlast, cToken, throwUIExceptions);
            }
        }

        IEnumerable<SearchResult> PerformLocalSearch(IEnumerable<string> searchTags, IEnumerable<FindSequenceTags.SequenceTag> allTags, SuperSpectrum spec, bool useBlast = true, CancellationToken cToken = default(CancellationToken), bool throwUIExceptions = false)
        {

            if (cToken.IsCancellationRequested) throw new OperationCanceledException();

            //TODO: Where is the species filtering?  Answer: The user specifies species by virtue of which FASTA files are loaded into the tool...

            var results = new List<SearchResult>();
            var allTagsList = allTags.ToList();
            //string selectedSpecies = "'" + string.Join(",", App.DistinctSpecies.Where(a => a.IsSelected).Select(a => a.SpeciesID)) + "'";

            // All de novo tags should be leucine neutral because from MS analysis, we cannot differentiate L and I.  
            searchTags = searchTags.Select(t => t.MakeLeucineNeutral()).AddReverse();

            //                if (Properties.Settings.Default.UseBlast && aSearchTag.Length >= Properties.Settings.Default.SequenceTagLength && BlastSequences != null)
            if (useBlast)
            {
                //TODO: move this into the Blast classes -- this is blast specific file formatting and should not be here.  
                // maybe we use the query sequence as the query ID since it should be unique.  Is there a character limit to the ID??  

                Dictionary<Guid, string> hashcodesforblastsequences = new Dictionary<Guid, string>();
                StringBuilder stringbuilderlocal = new StringBuilder();
                Guid localhashcode = new Guid();
                string reversestring = string.Empty;
                Guid.NewGuid();

                foreach (var s in searchTags)
                {
                    localhashcode = Guid.NewGuid();
                    hashcodesforblastsequences.Add(localhashcode, s);
                    stringbuilderlocal.Append(">" + localhashcode + "\n" + s + "\n");
                    //reversestring = ReverseString.Reverse(s);
                    //localhashcode = Guid.NewGuid();
                    //hashcodesforblastsequences.Add(localhashcode, reversestring);
                    //stringbuilderlocal.Append(">" + localhashcode + "\n" + reversestring + "\n");
                }

                var queryresult = BlastP.BlastQueryResults(stringbuilderlocal);

                results = (from FASTA f in App.lstFasta
                            join clsBlastpResults cbp in queryresult on f.SequenceID equals cbp.SubjectSequenceID
                            select new SearchResult
                            {
                                ScanNumbers = string.Join(",", spec.ScanNumbers), // App.ParentDetails.ScanNumber != null ? App.ParentDetails.ScanNumber : "",
                                ParentZ = spec.ParentIon.Z,
                                Accession = f.Accession,
                                Description = f.Description,
                                Sequence = f.Sequence,
                                Species = f.Species,
                                PairMatch = hashcodesforblastsequences[Guid.Parse(cbp.QuerySequenceID)].Split(' ').ToList(), /// sequenceforsearch,
                                //Allthesequencetags = allsequencetags,
                                //Mass = 0,
                                //DeltaMass = 0,
                                sequencesfordbmatching = null,
                                CurntIons = spec.Ions,
                                AllsqsTags = allTagsList,
                                ParentMass = spec.ParentIon.MonoMass,
                                //DontShowall = Dontshowall,
                                //BlastTag = f.Sequence.Substring(cbp.SequenceStart - 1, cbp.SequenceEnd - (cbp.SequenceStart - 1)),
                                BlastTagStart = cbp.SequenceStart, // - 1
                                BlastTagEnd = cbp.SequenceEnd,
                                ExpectValue = cbp.Expectvalue,
                                BlastedTagForTopProtein = hashcodesforblastsequences[Guid.Parse(cbp.QuerySequenceID)], // aSearchTag,
                                BlastQueryStart = cbp.QueryStart,
                                BlastQueryEnd = cbp.QueryEnd,
                                RetentionTime = spec.RetentionTime.ToString()
                            }).ToList();

            }
            else
            {
                // Local exact match search against local proteins  
                foreach (var aSearchTag in searchTags)
                {
                    if (cToken.IsCancellationRequested) throw new OperationCanceledException();

                    //string rvsrsequence = ReverseString.Reverse(aSearchTag);

                    // Filter FASTA List by species then by the specified sequence string
                    var hits = from FASTA Protein in App.lstFasta
                               let start = Protein.ModifiedSequenceforJ.IndexOf(aSearchTag)
                               where start != -1  //(f.ModifiedSequenceforJ.Contains(aSearchTag)) // || f.ModifiedSequenceforJ.Contains(rvsrsequence))
                               select new { Protein, Start = start + 1 };

                    foreach (var aHit in hits)
                    {
                        results.Add(new SearchResult()
                        {
                            ScanNumbers = string.Join(",", spec.ScanNumbers), // App.ParentDetails.ScanNumber != null ? App.ParentDetails.ScanNumber : "",
                            ParentZ = spec.ParentIon.Z,
                            Accession = aHit.Protein.Accession,
                            Description = aHit.Protein.Description,
                            Sequence = aHit.Protein.Sequence,
                            Species = aHit.Protein.Species,
                            PairMatch = new List<string>() { aSearchTag },
                            //Allthesequencetags = allsequencetags,
                            //Mass = aHit.Protein.Mass,
                            //DeltaMass = Math.Abs(spec.ParentIon.MonoMass - aHit.Protein.Mass),
                            sequencesfordbmatching = null,
                            CurntIons = spec.Ions,
                            AllsqsTags = allTagsList,
                            ParentMass = spec.ParentIon.MonoMass,
                            //tStart = aHit.Protein.ModifiedSequenceforJ.IndexOf(aSearchTag) , // - 1
                            //tEnd = aHit.Protein.SequenceEnd,
                            //DontShowall = Dontshowall,
                            TagForTopProtein = aSearchTag,
                            RetentionTime = spec.RetentionTime.ToString()
                        });

                        //totalseqcount = true;
                    }
                }
            }

            //TODO: distinct by accession???
            return results;
        }

        /// <summary>
        /// Searches the database server for the provided search tags in both forward and reverse directions
        /// </summary>
        /// <param name="searchTags"></param>
        /// <param name="allTags"></param>
        /// <param name="spec"></param>
        /// <returns></returns>
        IEnumerable<SearchResult> SearchDatabaseServer(IEnumerable<string> searchTags, IEnumerable<FindSequenceTags.SequenceTag> allTags, SuperSpectrum spec, bool preferBlast = true, CancellationToken cToken = default(CancellationToken), bool throwUIExceptions = false)
        {
            var results = new List<SearchResult>();
            string selectedSpecies = "'" + string.Join(",", App.DistinctSpecies.Where(a => a.IsSelected).Select(a => a.SpeciesID)) + "'";

            using (var cmd = db.CreateCommand())
            {
                cmd.CommandTimeout = SqlcommandTimeout; ///Setting the SQL server commandtimeout to avoid any query which takes a long time

                var tagParam = new SqlParameter();
                tagParam.ParameterName = "@SequenceTag";
                tagParam.DbType = DbType.AnsiString;
                cmd.Parameters.Add(tagParam);
                cmd.CommandType = CommandType.Text;

                foreach (var aSearchTag in searchTags)
                {
                    if (cToken.IsCancellationRequested) throw new OperationCanceledException();

                    if (Properties.Settings.Default.ExpressSearch &&
                        results.Any() &&
                        results.Min(r => r.ExpectValue) < 0.00001 && 
                        results.MinBy(r => r.ExpectValue).MatchCount > aSearchTag.Length) continue;  // if we match tags that are a GREAT MATCH, we assume this protein is identified with the existing 

                    cmd.CommandText = " SELECT COUNT(*) FROM [dbo].[FindProteinsByIsobaricSequenceforCountforSearchbySpeciesforSearchlimit]('" + aSearchTag + "', " + (Properties.Settings.Default.SearchAllSpecies ? "NULL" : selectedSpecies) + " ) ";

                    if (db.State == ConnectionState.Closed) db.Open();

                    cmd.Parameters.Clear();
                    var scalarResult = cmd.ExecuteScalar();

                    if (Convert.ToString(scalarResult) != "")
                    {
                        int totalcount = scalarResult != DBNull.Value ? Convert.ToInt32(scalarResult) : 0;
                        if (totalcount >= 5000)
                        {
                            // Too many results returned. 

                            if (throwUIExceptions)
                                throw new WarningException("Please refine the search.  Too many results were returned!");
                            else
                                continue;  // move on to the next sequence
                        }
                    }

                    // Blast when requested, except when tags are shorter than 4.  Exact match can do 4, but no less with a typical protein database
                    bool executingAsBlast = preferBlast && aSearchTag.Length > 4;
                    
                    if (executingAsBlast)
                        // Server executed BLAST
                        cmd.CommandText = "EXEC BlastpBySpecies3 @SequenceTag , " + spec.ParentIon.MonoMass + ", " + (Properties.Settings.Default.SearchAllSpecies ? "NULL" : selectedSpecies);
                    else
                        // Exact string match
                        cmd.CommandText = "SELECT * FROM [dbo].[FindProteinsByIsobaricSequencebySpecies2](@SequenceTag , " + spec.ParentIon.MonoMass + ", " + (Properties.Settings.Default.SearchAllSpecies ? "NULL" : selectedSpecies) + " ) ORDER BY DeltaMass ASC OPTION (RECOMPILE)";

                    tagParam.Value = aSearchTag;
                    cmd.Parameters.Add(tagParam);
                    //try
                    //{
                    using (var dr = cmd.ExecuteReader())  // the blast call can take 1.2 seconds or more per call!  Exact match is about 0.2 seconds per call.  
                    {
                        int i = 0;
                        string accession;

                        var allTagsList = allTags.ToList();

                        while (dr.Read())
                        {
                            if (cToken.IsCancellationRequested) throw new OperationCanceledException();


                            if (i++ > 10000)  // give up if we have too many results!
                            {
                                Debug.Print("Too many results returned from the database!!");

                                if (throwUIExceptions)
                                    throw new WarningException("Please refine the search.  Too many results were returned!");
                                else
                                    continue;
                            }

                            accession = Convert.ToString(dr["Acc"]).Trim();
                            if (results.Where(r => r.Accession == accession).Any()) continue;  // if this is a duplicate accession, skip it.  

                            results.Add(new SearchResult()
                            {
                                ScanNumbers = string.Join(",", spec.ScanNumbers), // App.ParentDetails.ScanNumber != null ? App.ParentDetails.ScanNumber : "",
                                ParentZ = spec.ParentIon.Z, // App.ParentDetails.ParentZ != null ? (int)App.ParentDetails.ParentZ : 0,
                                Accession = dr["Acc"] as string, //dr["Acc"] != DBNull.Value ? Convert.ToString(dr["Acc"]) : "",
                                Description = dr["Des"] as string,  //dr["Des"] != DBNull.Value ? Convert.ToString(dr["Des"]) : "",
                                Sequence = dr["Seq"] as string, //  dr["Seq"] != DBNull.Value ? Convert.ToString(dr["Seq"]) : "",
                                Species = dr["SciName"] as string, // != DBNull.Value ? Convert.ToString(dr["SciName"]) : "",
                                PairMatch = new List<string>() { aSearchTag },
                                //Allthesequencetags = allTags.Select(t =>t.Sequence).ToList(), // allTagsList,
                                //Mass = dr["Mass"] as double? ?? 0, // != DBNull.Value ? Math.Round(Convert.ToDouble(dr["Mass"]), 4) : 0,
                                //DeltaMass = dr["DeltaMass"] as double? ?? 0, // != DBNull.Value ? Math.Round(Convert.ToDouble(dr["DeltaMass"]), 4) : 0,
                                sequencesfordbmatching = null,
                                CurntIons = spec.Ions,
                                AllsqsTags = allTagsList,
                                ParentMass = spec.ParentIon.MonoMass,
                                DontShowall = false,
                                ExpectValue = executingAsBlast ? dr["eVal"] as double? ?? 1 : 1,
                                //QueryTag = aSearchTag,
                                //IsBlastResult = executingAsBlast,
                                BlastedTagForTopProtein = executingAsBlast ? aSearchTag : null,
                                BlastTagStart = executingAsBlast ? dr["tagStart"] as int? ?? 0 : 0,
                                BlastTagEnd = executingAsBlast ? dr["tagEnd"] as int? ?? 0: 0,  // executingAsBlast ? (dr["tagEnd"] != DBNull.Value ? Convert.ToInt32(dr["tagEnd"]) : 0) : 0,
                                BlastQueryStart = executingAsBlast ? dr["queryStart"] as int? ?? 0 : 0,  //executingAsBlast ? (dr["queryStart"] != DBNull.Value ? Convert.ToInt32(dr["queryStart"]) : 0) : 0,
                                BlastQueryEnd = executingAsBlast ? dr["queryEnd"] as int? ?? 0 : 0,  //executingAsBlast ? (dr["queryEnd"] != DBNull.Value ? Convert.ToInt32(dr["queryEnd"]) : 0) : 0,
                                RetentionTime = spec.RetentionTime.ToString()
                            });
                        }
                    }
                }
            }

            return results;
            //return results.DistinctBy(r => r.Accession); 
        }


        IEnumerable<SearchResult> SearchforSequence(string sequence, IEnumerable<FindSequenceTags.SequenceTag> currentTags, SuperSpectrum spec) //IEnumerable<Cluster> ions, int ParentZ, string ScanNumbers, ref bool totalcount, double parentMass = 0, bool Dontshowall = false, List<string> BlastSequences = null)
        {
            bool dummy = false;

            return SearchforSequence(sequence, currentTags, spec.Ions, spec.ParentIon.Z, string.Join(",",spec.ScanNumbers), ref dummy, spec.ParentIon.MonoMass, true); 
        }

        /// <summary>
        /// Finding sequences or highlighting them based on different sources
        /// </summary>
        /// <param name="sequence"></param>
        IEnumerable<SearchResult> SearchforSequence(string sequence, IEnumerable<FindSequenceTags.SequenceTag> currentTags, IEnumerable<Cluster> ions, int ParentZ, string ScanNumbers, ref bool totalcount, double parentMass = 0, bool Dontshowall = false, IEnumerable<string> BlastSequences = null)
        {
            ///The default value being false we search using the database
            if (!DechargerVM.UseFasta)
            {
                return SortSequenceSearch(SearchforSequenceUsingDatabase(sequence, currentTags, ions, parentMass, ParentZ, ScanNumbers, ref totalcount, null, Dontshowall), parentMass);
            }
            else
            {
                if (Properties.Settings.Default.UseBlast)
                {
                    return SortSequenceSearch(SearchforSequenceUsingDatabase(sequence, currentTags, ions, parentMass, ParentZ, ScanNumbers, ref totalcount, App.lstFasta, Dontshowall, currentTags.Select(t => t.Sequence)), parentMass);
                }
                else
                {
                    return SortSequenceSearch(SearchforSequenceUsingDatabase(sequence, currentTags, ions, parentMass, ParentZ, ScanNumbers, ref totalcount, App.lstFasta, Dontshowall), parentMass);
                }
            }
        }

        SearchResult SearchforSequenceforList(string sequence, IEnumerable<FindSequenceTags.SequenceTag> currentTags, IEnumerable<Cluster> ions, int ParentZ, string ScanNumbers, ref bool totalcount, double parentMass = 0, bool Dontshowall = false, List<string> BlastSequences = null, string sequencesearchtextfromauto = null)
        {
            ///The default value being false we search using the database
            if (!DechargerVM.UseFasta)
            {
                return SortSequenceSearchforList(SearchforSequenceUsingDatabase(sequence, currentTags, ions, parentMass, ParentZ, ScanNumbers, ref totalcount, null, Dontshowall), parentMass);
                //return SortSequenceSearchforList(SearchforOneSequenceUsingDatabase(sequence, currentTags, ions, parentMass, ParentZ, ScanNumbers, ref totalcount, null, Dontshowall, null, sequencesearchtextfromauto), parentMass);
            }
            else
            {
                if (Properties.Settings.Default.UseBlast)
                {
                    return SortSequenceSearchforList(SearchforSequenceUsingDatabase(sequence, currentTags, ions, parentMass, ParentZ, ScanNumbers, ref totalcount, App.lstFasta, Dontshowall, BlastSequences), parentMass);
                }
                else
                {
                    return SortSequenceSearchforList(SearchforSequenceUsingDatabase(sequence, currentTags, ions, parentMass, ParentZ, ScanNumbers, ref totalcount, App.lstFasta, Dontshowall), parentMass);
                }
            }
        }

        /// <summary>
        /// Finding sequences or highlighting them based on different sources
        /// </summary>
        /// <param name="sequence"></param>
        /// <param name="currentTags"></param>
        /// <param name="ions"></param>
        /// <returns></returns>
        IEnumerable<SearchResult> SearchforSequenceandfilter(string sequence, string filter, IEnumerable<FindSequenceTags.SequenceTag> currentTags, IEnumerable<Cluster> ions, double ParentMass)
        {
            ///If the source is database
            if (!DechargerVM.UseFasta)
            {
                return SortSequenceSearch(SearchforSequenceandfilterusingDBorFasta(sequence, filter, currentTags, ions, ParentMass), ParentMass); ///.OrderByDescending(a => a.TagHits);///.Take(100);
            }
            ///If the source is the FASTA file
            else
            {
                return SortSequenceSearch(SearchforSequenceandfilterusingDBorFasta(sequence, filter, currentTags, ions, ParentMass, App.lstFasta), ParentMass);///.OrderByDescending(a => a.TagHits);///.Take(100);
            }
        }

        /// <summary>
        /// Finding sequences and highlighting them based on different sources
        /// </summary>
        /// <param name="filter"></param>
        /// <param name="currentTags"></param>
        /// <param name="ions"></param>
        /// <returns></returns>
        IEnumerable<SearchResult> Searchforfilter(string filter, IEnumerable<FindSequenceTags.SequenceTag> currentTags, IEnumerable<Cluster> ions, double ParentMass)
        {
            ///If the source is database
            if (!DechargerVM.UseFasta)
            {
                bool count = false;

                if (ParentMass == 0)
                {
                    return SearchforfilterusingDBorFasta(filter, currentTags, ions, ParentMass, ref count);
                }
                return SortSequenceSearchforFilter(SearchforfilterusingDBorFasta(filter, currentTags, ions, ParentMass, ref count), ParentMass);
            }
            ///If the source is the FASTA file
            else
            {
                bool count = false;
                if (ParentMass == 0)
                {
                    return SearchforfilterusingDBorFasta(filter, currentTags, ions, ParentMass, ref count, App.lstFasta);
                }
                return SortSequenceSearchforFilter(SearchforfilterusingDBorFasta(filter, currentTags, ions, ParentMass, ref count, App.lstFasta), ParentMass);
            }
        }

        int NumberofDatabasehitsforSequenceSearch(string sequence)
        {
            int count = 0;
            using (SqlCommand cmd = db.CreateCommand())
            {
                cmd.CommandTimeout = SqlcommandTimeout; ///Setting the SQL server commandtimeout to avoid any query which takes a long time

                string allspecies = "'" + string.Join(",", App.DistinctSpecies.Where(a => a.IsSelected == true).Select(a => a.SpeciesID).ToList()) + "'";
                //if (!Properties.Settings.Default.UseBlast)
                {
                    cmd.CommandText = " SELECT COUNT(*) FROM [dbo].[FindProteinsByIsobaricSequenceforCountforSearchbySpeciesforSearchlimit]('" + sequence + "', " + (Properties.Settings.Default.SearchAllSpecies ? "NULL" : allspecies) + " ) ";
                }
                //else
                //{
                //    cmd.CommandText = " SELECT COUNT(*) FROM [dbo].[BlastpBySpecies4]('" + sequence + "', " + "0 ," + (Properties.Settings.Default.SearchAllSpecies ? "NULL" : allspecies) + ", '-evalue 5000 -ungapped -max_target_seqs 101 -comp_based_stats 0 -task blastp-short' " + ") ";
                //}
                //System.Windows.MessageBox.Show("SQL Command: " + cmd.CommandText);

                if (db.State == ConnectionState.Closed) db.Open();

                var scalarResult = cmd.ExecuteScalar();

                if (Convert.ToString(scalarResult) != "")
                {
                    count = scalarResult != DBNull.Value ? Convert.ToInt32(scalarResult) : 0;
                }
            }
            return count;
        }

        /// <summary>
        /// Search the database just using the sequence
        /// </summary>
        /// <param name="sequence"></param>
        //IEnumerable<SequenceSearch> SearchforSequenceUsingDatabase(string sequence, IEnumerable<FindSequenceTags.SequenceTag> currentTags, IEnumerable<Cluster> ions, double parentMass, ref int totalseqcount, List<FASTA> fastaEntries = null, bool Dontshowall = false, List<string> BlastSequences = null)
        List<SearchResult> SearchforSequenceUsingDatabase(string sequence, IEnumerable<FindSequenceTags.SequenceTag> currentTags, IEnumerable<Cluster> ions, double parentMass, int ParentZ, string ScanNumbers, ref bool totalseqcount, List<FASTA> fastaEntries = null, bool Dontshowall = false, IEnumerable<string> BlastSequences = null)///, string sequencesearchitem = null)
        {
            //TODO: Refactor someday.  There is a lot of duplicated code in here.  




            string filename = App.FileName;
            var tempdbsequences = new List<SearchResult>();
            totalseqcount = false;
            Debug.Print(DateTime.Now.TimeOfDay + " SearchforSequence: " + sequence);

            if (!NetworkInterface.GetIsNetworkAvailable() && DechargerVM.UseFasta == false)
            {
                throw new Exception("No Internet connectivity, please check your network connection. ");
            }

            string[] accessions = new string[10000];
            double tempyellowgreenhits = 0;
            sequence = sequence.Replace("*", "%").Replace("I", "L");

            int i = 0;

            string[] sequenceseparator = { "%" };
            List<string> sequenceforsearch = sequence.ToUpper().Split(sequenceseparator, StringSplitOptions.RemoveEmptyEntries).ToList();
            List<string> allsequencetags = new List<string>();

            int lengthofsequenceforsearch = sequenceforsearch.Count;

            List<FindSequenceTags.SequenceTag> sqsfordbsrch = currentTags.ToList();/// == null ? new List<FindSequenceTags.SequenceTag>() : currentTags.Where(a => a.DatabaseHits != "0").ToList();

            var crntins = ions.OrderBy(a => a.MonoMass).ToList();

            //var rvrscrntins = (from d in crntins.Where(a => a.MonoMass <= parentMass)
            //                   select new Cluster
            //                   {
            //                       ConsolidatedCharges = d.ConsolidatedCharges,
            //                       Description = d.Description,
            //                       IsoPattern = d.IsoPattern,
            //                       IsoScale = d.IsoScale,
            //                       MonoOffset = d.MonoOffset,
            //                       Peaks = d.Peaks,
            //                       Score = d.Score,
            //                       Z = d.Z
            //                   });


            if (currentTags != null && currentTags.Any())
            {
                allsequencetags = currentTags.Select(a => a.Sequence).ToList(); //.Where(a => a.DatabaseHits != "0")
                allsequencetags = allsequencetags.Distinct().ToList();
            }
            else
            {
                allsequencetags.Add("");
            }

            if (!DechargerVM.UseFasta)
            {
                //using (SqlConnection cn = new SqlConnection(Properties.Settings.Default.ConnectionString))
                //{
                using (SqlCommand cmd = db.CreateCommand())
                {
                    cmd.CommandTimeout = SqlcommandTimeout; ///Setting the SQL server commandtimeout to avoid any query which takes a long time

                    string allspecies = "'" + string.Join(",", App.DistinctSpecies.Where(a => a.IsSelected == true).Select(a => a.SpeciesID).ToList()) + "'";

                    cmd.CommandText = " SELECT COUNT(*) FROM [dbo].[FindProteinsByIsobaricSequenceforCountforSearchbySpeciesforSearchlimit]('" + sequence + "', " + (Properties.Settings.Default.SearchAllSpecies ? "NULL" : allspecies) + " ) ";

                    //System.Windows.MessageBox.Show("SQL Command: " + cmd.CommandText);

                    if (db.State == ConnectionState.Closed) db.Open();

                    var scalarResult = cmd.ExecuteScalar();

                    if (Convert.ToString(scalarResult) != "")
                    {
                        int totalcount = scalarResult != DBNull.Value ? Convert.ToInt32(scalarResult) : 0;
                        if (totalcount >= 5000)
                        {
                            throw new WarningException("Please refine the search.  Too many results were returned!");
                        }
                    }

                    SqlParameter param1 = new SqlParameter();
                    param1.ParameterName = "@SequenceTag";
                    param1.DbType = DbType.AnsiString;

                    if (Properties.Settings.Default.UseBlast && sequence.Length > 4)/// Properties.Settings.Default.SequenceTagLength)
                    {
                        cmd.CommandText = "EXEC BlastpBySpecies3 @SequenceTag , " + parentMass + ", " + (Properties.Settings.Default.SearchAllSpecies ? "NULL" : allspecies);
                        param1.Value = sequence;/// +" " + new string(sequence.Reverse().ToArray());  // since blast only searches forward, we include the tag reversed as well
                    }
                    else
                    {
                        cmd.CommandText = "SELECT * FROM [dbo].[FindProteinsByIsobaricSequencebySpecies2](@SequenceTag , " + parentMass + ", " + (Properties.Settings.Default.SearchAllSpecies ? "NULL" : allspecies) + " ) ORDER BY DeltaMass ASC OPTION (RECOMPILE)";
                        param1.Value = sequence;
                    }

                    //try
                    //{
                    //    if (App.ParentDetails == null)
                    //    {
                    //        App.ParentDetails = new clsParentInfo
                    //        {
                    //            ParentZ = 0,
                    //            ScanNumber = ""
                    //        };
                    //    }
                    //}
                    //catch (Exception)
                    //{
                    //}
                    //finally
                    //{
                    //    App.ParentDetails = new clsParentInfo
                    //    {
                    //        ParentZ = 0,
                    //        ScanNumber = ""
                    //    };
                    //}

                    cmd.Parameters.Add(param1);
                    cmd.CommandType = CommandType.Text;
                    string tempaccession = string.Empty;
                    bool boolcontinue = false;
                    var temp = new SearchResult();
                    double tempDeltaMassVersusProtein = 0;
                    try
                    {
                        using (SqlDataReader dr = cmd.ExecuteReader())
                        {
                            while (dr.Read())
                            {
                                if (i++ > 10000)
                                    throw new WarningException("Please refine the search.  Too many results were returned!");

                                tempaccession = Convert.ToString(dr["Acc"]);

                                if (i != 1)
                                {
                                    for (int j = 1; j < i; j++)
                                    {
                                        if (accessions[j] == tempaccession)
                                        {
                                            boolcontinue = true;
                                            continue;
                                        }
                                    }
                                }

                                if (boolcontinue)
                                {
                                    boolcontinue = false;
                                    continue;
                                }

                                accessions[i] = tempaccession;

                                temp = new SearchResult()
                                {
                                    ScanNumbers = ScanNumbers, // App.ParentDetails.ScanNumber != null ? App.ParentDetails.ScanNumber : "",
                                    ParentZ = ParentZ, // App.ParentDetails.ParentZ != null ? (int)App.ParentDetails.ParentZ : 0,
                                    Accession = tempaccession,  //dr["Acc"] != DBNull.Value ? Convert.ToString(dr["Acc"]) : "", ///tempaccession,
                                    Description = dr["Des"] != DBNull.Value ? Convert.ToString(dr["Des"]) : "",
                                    Sequence = dr["Seq"] != DBNull.Value ? Convert.ToString(dr["Seq"]) : "",
                                    Species = dr["SciName"] != DBNull.Value ? Convert.ToString(dr["SciName"]) : "",
                                    PairMatch = sequenceforsearch,
                                    //Allthesequencetags = allsequencetags != null ? allsequencetags : new List<string>(),
                                    //Mass = dr["Mass"] != DBNull.Value ? Math.Round(Convert.ToDouble(dr["Mass"]), 4) : 0,
                                    //DeltaMass = dr["DeltaMass"] != DBNull.Value ? Math.Round(Convert.ToDouble(dr["DeltaMass"]), 4) : 0,
                                    sequencesfordbmatching = null,
                                    CurntIons = crntins != null ? crntins : new List<Cluster>(),
                                    AllsqsTags = new List<MSViewer.FindSequenceTags.SequenceTag>(sqsfordbsrch),
                                    ParentMass = parentMass,
                                    DontShowall = Dontshowall,
                                    ExpectValue = (Properties.Settings.Default.UseBlast && sequence.Length > 4) ? Convert.ToDouble(dr["eVal"]) : 0,
                                    //BlastTag = (Properties.Settings.Default.UseBlast && sequence.Length > 4) ? Convert.ToString(dr["Seq"]).Substring(Convert.ToInt32(dr["tagStart"]) - 1, (Convert.ToInt32(dr["tagEnd"]) - (Convert.ToInt32(dr["tagStart"]) - 1))).Replace("I", "L") : string.Empty,
                                    BlastedTagForTopProtein = sequence,
                                    BlastTagStart = (Properties.Settings.Default.UseBlast && sequence.Length > 4) ? (dr["tagStart"] != DBNull.Value ? Convert.ToInt32(dr["tagStart"]) - 1 : 0) : 0,
                                    BlastTagEnd = (Properties.Settings.Default.UseBlast && sequence.Length > 4) ? (dr["tagEnd"] != DBNull.Value ? Convert.ToInt32(dr["tagEnd"]) : 0) : 0,
                                    BlastQueryStart = (Properties.Settings.Default.UseBlast && sequence.Length > 4) ? (dr["queryStart"] != DBNull.Value ? Convert.ToInt32(dr["queryStart"]) : 0) : 0,
                                    BlastQueryEnd = (Properties.Settings.Default.UseBlast && sequence.Length > 4) ? (dr["queryEnd"] != DBNull.Value ? Convert.ToInt32(dr["queryEnd"]) : 0) : 0,
                                    RetentionTime = MainPointProvider != null ? CalculateRetentionTime(ScanNumbers) : ""
                                };

                                double tempvalue = temp.YellowandGreenTagHits;

                                if ((Properties.Settings.Default.UseBlast && sequence.Length >= Properties.Settings.Default.SequenceTagLength))
                                {
                                    tempdbsequences.Add(temp);
                                }
                                else
                                {
                                    tempdbsequences.Add(temp);
                                }

                                totalseqcount = true;
                            }
                        }
                    }
                    catch (SqlException ex)
                    {
                        if (ex.Message.ToUpper().Contains("TIMEOUT"))
                        {
                            tempdbsequences = DatabaseResults(cmd, sequenceforsearch, sequence, allsequencetags, crntins, sqsfordbsrch, parentMass, Dontshowall, totalseqcount, i);
                        }
                    }

                    if (Properties.Settings.Default.UseBlast && sequence.Length >= Properties.Settings.Default.SequenceTagLength)
                    {
                        param1.Value = new string(Enumerable.Reverse(sequence).ToArray());
                    }

                    sequenceforsearch.Clear();
                    sequenceforsearch.Add(ReverseString.Reverse(sequence));

                    sequence = ReverseString.Reverse(sequence);

                    boolcontinue = false;
                    try
                    {
                        using (SqlDataReader dr = cmd.ExecuteReader())
                        {
                            while (dr.Read())
                            {
                                if (i++ > 10000)
                                    throw new WarningException("Please refine the search.  Too many results were returned!");

                                tempaccession = dr["Acc"] != DBNull.Value ? Convert.ToString(dr["Acc"]) : "";

                                if (i != 1)
                                {
                                    for (int j = 1; j < i; j++)
                                    {
                                        if (accessions[j] == tempaccession)
                                        {
                                            boolcontinue = true;
                                            continue;
                                        }
                                    }
                                }

                                if (boolcontinue)
                                {
                                    boolcontinue = false;
                                    continue;
                                }

                                accessions[i] = tempaccession;

                                temp = new SearchResult()
                                {
                                    ScanNumbers = ScanNumbers,/// App.ParentDetails.ScanNumber,
                                    ParentZ = ParentZ, /// App.ParentDetails.ParentZ != null ? (int)App.ParentDetails.ParentZ : 0,
                                    Accession = tempaccession,/// dr["Acc"] != DBNull.Value ? Convert.ToString(dr["Acc"]) : "", /// 
                                    Description = dr["Des"] != DBNull.Value ? Convert.ToString(dr["Des"]) : "",
                                    Sequence = dr["Seq"] != DBNull.Value ? Convert.ToString(dr["Seq"]) : "",
                                    Species = dr["SciName"] != DBNull.Value ? Convert.ToString(dr["SciName"]) : "",
                                    PairMatch = sequenceforsearch, /// sequenceforsearch,
                                    //Allthesequencetags = allsequencetags,
                                    //Mass = dr["Mass"] != DBNull.Value ? Math.Round(Convert.ToDouble(dr["Mass"]), 4) : 0,
                                    //DeltaMass = dr["DeltaMass"] != DBNull.Value ? Math.Round(Convert.ToDouble(dr["DeltaMass"]), 4) : 0,
                                    sequencesfordbmatching = null, //aminoacidsforsequence,
                                    CurntIons = crntins,
                                    AllsqsTags = new List<MSViewer.FindSequenceTags.SequenceTag>(sqsfordbsrch),
                                    ParentMass = parentMass,
                                    DontShowall = Dontshowall,
                                    ExpectValue = (Properties.Settings.Default.UseBlast && sequence.Length > 4) ? Convert.ToDouble(dr["eVal"]) : 0,
                                    //BlastTag = (Properties.Settings.Default.UseBlast && sequence.Length > 4) ? ReverseString.Reverse(Convert.ToString(dr["Seq"]).Substring(Convert.ToInt32(dr["tagStart"]) - 1, (Convert.ToInt32(dr["tagEnd"]) - (Convert.ToInt32(dr["tagStart"]) - 1))).Replace("I", "L")) : string.Empty,
                                    BlastedTagForTopProtein = sequence,
                                    BlastTagStart = (Properties.Settings.Default.UseBlast && sequence.Length > 4) ? (dr["tagStart"] != DBNull.Value ? Convert.ToInt32(dr["tagStart"]) - 1 : 0) : 0,
                                    BlastTagEnd = (Properties.Settings.Default.UseBlast && sequence.Length > 4) ? (dr["tagEnd"] != DBNull.Value ? Convert.ToInt32(dr["tagEnd"]) : 0) : 0,
                                    BlastQueryStart = (Properties.Settings.Default.UseBlast && sequence.Length > 4) ? (dr["queryStart"] != DBNull.Value ? Convert.ToInt32(dr["queryStart"]) : 0) : 0,
                                    BlastQueryEnd = (Properties.Settings.Default.UseBlast && sequence.Length > 4) ? (dr["queryEnd"] != DBNull.Value ? Convert.ToInt32(dr["queryEnd"]) : 0) : 0,
                                    RetentionTime = MainPointProvider != null ? CalculateRetentionTime(ScanNumbers) : string.Empty
                                };

                                if (Properties.Settings.Default.UseBlast && sequence.Length >= Properties.Settings.Default.SequenceTagLength)
                                {
                                    tempdbsequences.Add(temp);
                                }
                                else
                                {
                                    tempdbsequences.Add(temp);
                                }

                                totalseqcount = true;
                            }
                        }
                    }
                    catch (SqlException ex)
                    {
                        if (ex.Message.ToUpper().Contains("TIMEOUT"))
                        {
                            tempdbsequences = DatabaseResults(cmd, sequenceforsearch, sequence, allsequencetags, crntins, sqsfordbsrch, parentMass, Dontshowall, totalseqcount, i);
                        }
                    }
                    if (Properties.Settings.Default.UseBlast && sequence.Length > 4)
                    {
                        return tempdbsequences;
                        //tempdbsequences = tempdbsequences.Where(a => a.VerifyBlastTag).ToList();
                    }
                }

            }
            else
            {
                // Using FASTA in this ELSE
                //try
                //{
                //    if (App.ParentDetails == null)
                //    {
                //        App.ParentDetails = new clsParentInfo
                //        {
                //            ParentZ = 0,
                //            ScanNumber = ""
                //        };
                //    }
                //}
                //catch (Exception)
                //{
                //}
                //finally
                //{
                //    App.ParentDetails = new clsParentInfo
                //    {
                //        ParentZ = 0,
                //        ScanNumber = ""
                //    };
                //}
                string rvsrsequence = ReverseString.Reverse(sequence);

                if (Properties.Settings.Default.UseBlast && sequence.Length >= Properties.Settings.Default.SequenceTagLength && BlastSequences != null && BlastSequences.Any())
                {
                    Dictionary<Guid, string> hashcodesforblastsequences = new Dictionary<Guid, string>();
                    StringBuilder stringbuilderlocal = new StringBuilder();
                    Guid localhashcode = new Guid();
                    string reversestring = string.Empty;
                    Guid.NewGuid();
                    foreach (string s in BlastSequences)
                    {
                        localhashcode = Guid.NewGuid();
                        hashcodesforblastsequences.Add(localhashcode, s);
                        stringbuilderlocal.Append(">" + localhashcode + "\n" + s + "\n");
                        reversestring = ReverseString.Reverse(s);
                        localhashcode = Guid.NewGuid();
                        hashcodesforblastsequences.Add(localhashcode, reversestring);
                        stringbuilderlocal.Append(">" + localhashcode + "\n" + reversestring + "\n");
                    }

                    var queryresult = BlastP.BlastQueryResults(stringbuilderlocal);

                    var sqs = new List<SearchResult>();

                    sqs = (from FASTA f in App.lstFasta
                           join clsBlastpResults cbp in queryresult on f.SequenceID equals cbp.SubjectSequenceID
                           select new SearchResult
                           {
                               ScanNumbers = ScanNumbers,// App.ParentDetails.ScanNumber,
                               ParentZ = ParentZ,/// App.ParentDetails.ParentZ != null ? (int)App.ParentDetails.ParentZ : 0,
                               Accession = f.Accession,
                               Description = f.Description,
                               Sequence = f.Sequence,
                               Species = f.Species,
                               PairMatch = hashcodesforblastsequences[Guid.Parse(cbp.QuerySequenceID)].Split(' ').ToList(), /// sequenceforsearch,
                               //Allthesequencetags = allsequencetags,
                               //Mass = 0,
                               //DeltaMass = 0,
                               sequencesfordbmatching = null,
                               CurntIons = crntins,
                               AllsqsTags = new List<FindSequenceTags.SequenceTag>(sqsfordbsrch),
                               ParentMass = parentMass,
                               DontShowall = Dontshowall,
                               //BlastTag = f.Sequence.Substring(cbp.SequenceStart - 1, cbp.SequenceEnd - (cbp.SequenceStart - 1)),
                               BlastTagStart = cbp.SequenceStart - 1,
                               BlastTagEnd = cbp.SequenceEnd,
                               ExpectValue = cbp.Expectvalue,
                               BlastedTagForTopProtein = sequence,
                               BlastQueryStart = cbp.QueryStart,
                               BlastQueryEnd = cbp.QueryEnd,
                               RetentionTime = MainPointProvider != null ? CalculateRetentionTime(ScanNumbers) : ""
                           }).ToList();

                    if (sqs.Any())
                    {

                        sqs = sqs.OrderByDescending(a => a.YellowandGreenTagHits).ToList();

                        return sqs.DistinctBy(a => a.Accession).Where(a => a.PPM != double.NaN).ToList();
                        //return sqs.DistinctBy(a => a.Accession + a.YellowandGreenTagHits).Where(a => a.PPM != double.NaN).ToList();
                        //return sqs.DistinctBy(a => a.Accession + a.YellowandGreenTagHits).Where(a => a.VerifyBlastTag && a.PPM != double.NaN).ToList();
                    }
                }
                else
                {
                    // Filter FASTA List by species then by the specified sequence string
                    var sqs = from FASTA f in App.lstFasta
                              where (sequenceforsearch.Any() == false || (f.ModifiedSequenceforL.Contains(sequence) || f.ModifiedSequenceforL.Contains(rvsrsequence)))
                              select f;

                    if (sequence == "")
                    {
                        foreach (FASTA fst in sqs)
                        {
                            tempdbsequences.Add(new SearchResult()
                            {
                                ScanNumbers = ScanNumbers,/// App.ParentDetails.ScanNumber,
                                ParentZ = ParentZ,/// App.ParentDetails.ParentZ != null ? (int)App.ParentDetails.ParentZ : 0,
                                Accession = fst.Accession,
                                Description = fst.Description,
                                Sequence = fst.Sequence,
                                Species = fst.Species,
                                PairMatch = sequenceforsearch,
                                //Allthesequencetags = allsequencetags,
                                //Mass = fst.Mass,
                                //DeltaMass = Math.Abs(parentMass - fst.Mass),
                                sequencesfordbmatching = null,
                                CurntIons = crntins,
                                AllsqsTags = new List<MSViewer.FindSequenceTags.SequenceTag>(sqsfordbsrch),
                                ParentMass = parentMass,
                                DontShowall = Dontshowall,
                                BlastedTagForTopProtein = sequence,
                                RetentionTime = MainPointProvider != null ? CalculateRetentionTime(ScanNumbers) : ""
                            });


                            totalseqcount = true;
                        }
                        return tempdbsequences;
                    }

                    if (sequenceforsearch.Any())
                    {
                        foreach (FASTA fst in sqs)
                        {
                            if (i++ > 10000)
                                throw new WarningException("Please refine the search.  Too many results were returned!");

                            tempdbsequences.Add(new SearchResult()
                            {
                                ScanNumbers = ScanNumbers,/// App.ParentDetails.ScanNumber,
                                ParentZ = ParentZ,/// App.ParentDetails.ParentZ != null ? (int)App.ParentDetails.ParentZ : 0,
                                Accession = fst.Accession,
                                Description = fst.Description,
                                Sequence = fst.Sequence,
                                Species = fst.Species,
                                PairMatch = sequenceforsearch,
                                //Allthesequencetags = allsequencetags,
                                //Mass = fst.Mass,
                                //DeltaMass = Math.Abs(parentMass - fst.Mass),
                                sequencesfordbmatching = null,
                                CurntIons = crntins,
                                AllsqsTags = new List<MSViewer.FindSequenceTags.SequenceTag>(sqsfordbsrch),
                                ParentMass = parentMass,
                                DontShowall = Dontshowall,
                                BlastedTagForTopProtein = sequence,
                                RetentionTime = ScanNumbers != null ? CalculateRetentionTime(ScanNumbers) : ""
                            });

                            totalseqcount = true;
                        }
                    }
                    else
                    {
                        foreach (FASTA fst in sqs)
                        {
                            if (i++ > 10000)
                                throw new WarningException("Please refine the search.  Too many results were returned!");

                            tempdbsequences.Add(new SearchResult
                            {
                                ScanNumbers = ScanNumbers,/// App.ParentDetails.ScanNumber,
                                ParentZ = ParentZ,// App.ParentDetails.ParentZ != null ? (int)App.ParentDetails.ParentZ : 0,
                                Accession = fst.Accession,
                                Description = fst.Description,
                                Sequence = fst.Sequence,
                                //Mass = fst.Mass,
                                Species = fst.Species,
                                PairMatch = new List<string>(),
                                //Allthesequencetags = new List<string>(),
                                AllsqsTags = new List<FindSequenceTags.SequenceTag>(),
                                CurntIons = new List<Cluster>(),
                                //DeltaMass = 0,
                                Notagsforhighlight = true,
                                DontShowall = Dontshowall,
                                BlastedTagForTopProtein = sequence,
                                RetentionTime = MainPointProvider != null ? CalculateRetentionTime(ScanNumbers) : ""
                            });

                            totalseqcount = true;
                        }
                    }
                }
            }

            return tempdbsequences;
        }

        bool NetworkIssues = false;

        /// <summary>
        /// Get RetentionTime for either single or multiple scans.
        /// In case of multiple scans, concatinate the retention times using ","
        /// </summary>
        /// <param name="ScanNumbers"></param>
        /// <returns></returns>
        string CalculateRetentionTime(string ScanNumbers)
        {
            return CalculateRetentionTime(ScanNumbers.Split(new [] { "," }, StringSplitOptions.RemoveEmptyEntries).Select(s => int.Parse(s)));
        }

        /// <summary>
        /// Get RetentionTime for either single or multiple scans.
        /// In case of multiple scans, concatinate the retention times using ","
        /// </summary>
        /// <param name="ScanNumbers"></param>
        /// <returns></returns>
        string CalculateRetentionTime(IEnumerable<int> ScanNumbers)
        {
            return string.Join(",", ScanNumbers.Select(sn => MainPointProvider.RetentionTime(sn)));
        }



        List<SearchResult> DatabaseResults(SqlCommand cmd, List<string> sequenceforsearch, string sequence, List<string> allsequencetags, List<SignalProcessing.Cluster> crntins, List<FindSequenceTags.SequenceTag> sqsfordbsrch, double parentMass, bool Dontshowall, bool totalseqcount, int i)
        {
            List<SearchResult> tempdbsequences = new List<SearchResult>();
            int j = 0;
            bool foundresults = false;
            do
            {
                try
                {
                    using (SqlDataReader dr = cmd.ExecuteReader())
                    {
                        while (dr.Read())
                        {
                            if (i++ > 10000) throw new WarningException("Please refine the search.  Too many results were returned!");
                            sequenceforsearch.Clear();
                            sequenceforsearch.Add(sequence);///Convert.ToString(param1.Value));
                            tempdbsequences.Add(new SearchResult()
                            {
                                //ScanNumbers = txtScanNum.Text,
                                ScanNumbers = App.ParentDetails.ScanNumber,
                                ParentZ = App.ParentDetails.ParentZ != null ? (int)App.ParentDetails.ParentZ : 0,
                                Accession = dr["Acc"] != DBNull.Value ? Convert.ToString(dr["Acc"]) : "",
                                Description = dr["Des"] != DBNull.Value ? Convert.ToString(dr["Des"]) : "",
                                Sequence = dr["Seq"] != DBNull.Value ? Convert.ToString(dr["Seq"]) : "",
                                Species = dr["SciName"] != DBNull.Value ? Convert.ToString(dr["SciName"]) : "",
                                PairMatch = sequenceforsearch, /// sequenceforsearch,
                                //Allthesequencetags = allsequencetags,
                                //Mass = dr["Mass"] != DBNull.Value ? Math.Round(Convert.ToDouble(dr["Mass"]), 4) : 0,
                               // DeltaMass = dr["DeltaMass"] != DBNull.Value ? Math.Round(Convert.ToDouble(dr["DeltaMass"]), 4) : 0,
                                sequencesfordbmatching = null, //aminoacidsforsequence,
                                CurntIons = crntins,
                                AllsqsTags = new List<MSViewer.FindSequenceTags.SequenceTag>(sqsfordbsrch),
                                ParentMass = parentMass,
                                DontShowall = Dontshowall,
                                ExpectValue = Properties.Settings.Default.UseBlast ? Convert.ToDouble(dr["eVal"]) : 0,
                                //BlastTag = Properties.Settings.Default.UseBlast ? ReverseString.Reverse(Convert.ToString(dr["Seq"]).Substring(Convert.ToInt32(dr["tagStart"]) - 1, (Convert.ToInt32(dr["tagEnd"]) - (Convert.ToInt32(dr["tagStart"]) - 1))).Replace("I", "L")) : string.Empty
                            });
                            totalseqcount = true;
                        }
                    }
                    foundresults = true;
                }
                catch (Exception ex)
                {
                    j++;
                    if (j == 2 && !NetworkIssues)
                    {
                        NetworkIssues = true;
                        var responsevalue = false;
                        Dispatcher.Invoke(new Action(() =>
                        {
                            var response = System.Windows.MessageBox.Show(this, "Failed to retrieve a response from the database. Results will be incomplete. Do you want to continue? ", "Do you want to continue?", MessageBoxButton.YesNo, MessageBoxImage.Error);

                            if (response == MessageBoxResult.No)
                            {
                                if (cTokenSource != null)
                                {
                                    cTokenSource.Cancel();
                                    btnGenerateSearchSummary.IsEnabled = false;
                                    responsevalue = true;
                                    return;
                                }
                            }
                        }));
                        if (responsevalue) return new List<SearchResult>();
                    }
                }
            }
            while ((j < 2) && !foundresults);

            return tempdbsequences;
        }

        /// <summary>
        /// Search the database using both sequence and filter
        /// </summary>
        /// <param name="sequence"></param>
        /// <param name="filter"></param>
        IEnumerable<SearchResult> SearchforSequenceandfilterusingDBorFasta(string sequence, string filter, IEnumerable<FindSequenceTags.SequenceTag> currentTags, IEnumerable<Cluster> ions, double parentMass, List<FASTA> fastaEntries = null)
        {
            bool returnfunction = false;
            string[] filters = Regex.Split(filter.Trim(), @"[!@#$ ,.;}{/]");
            sequence = sequence.Replace("*", "%");

            var tempdbsequences = new List<SearchResult>();

            Pairmatch = sequence.Replace("I", "L");
            string[] accessions = new string[10000];


            int i = 0;
            string[] sequenceseparator = { "%" };

            List<string> sequenceforsearch = sequence.ToUpper().Split(sequenceseparator, StringSplitOptions.RemoveEmptyEntries).ToList();
            List<string> allsequencetags = new List<string>();

            List<FindSequenceTags.SequenceTag> sqsfordbsrch = currentTags == null ? new List<FindSequenceTags.SequenceTag>() : currentTags.Where(a => a.DatabaseHits != "0").ToList();
            List<Cluster> crntins = new List<Cluster>();
            crntins = ions.OrderBy(a => a.MonoMass).ToList();
            if (currentTags != null && currentTags.Any())
            {
                allsequencetags = currentTags.Where(a => a.DatabaseHits != "0").Select(a => a.Sequence).ToList();
                allsequencetags.AddRange(sequenceforsearch);
                allsequencetags = allsequencetags.Distinct().ToList();
                foreach (string s in sequenceforsearch)
                {
                    allsequencetags.Remove(allsequencetags.Where(a => a == s.ToUpper()).First());
                }
                foreach (string s in sequenceforsearch)
                {
                    allsequencetags.Add(s.ToUpper().Replace('I', 'L'));
                }
            }
            else
            {
                allsequencetags.Add("");
            }

            char[] reversechar = Pairmatch.ToCharArray();
            List<string> emptystring = new List<string>();
            emptystring.Add("");
            Array.Reverse(reversechar);
            string reversemainsequencetag = new string(reversechar);
            string errorsequence = string.Empty;
            string tempaccession = string.Empty;
            bool boolcontinue = false;
            try
            {
                if (!DechargerVM.UseFasta)
                {
                    //using (SqlConnection cn = new SqlConnection(Properties.Settings.Default.ConnectionString))
                    //{
                    using (SqlCommand cmd = db.CreateCommand())
                    {
                        cmd.CommandTimeout = SqlcommandTimeout;

                        string allspecies = "'" + string.Join(",", App.DistinctSpecies.Where(a => a.IsSelected == true).Select(a => a.SpeciesID).ToList()) + "'";

                        cmd.CommandText = " SELECT COUNT(*) FROM [dbo].[FindProteinsByIsobaricSequenceforCountforSearchbySpecies]('" + sequence + "', " + (Properties.Settings.Default.SearchAllSpecies ? "NULL" : allspecies) + " ) ";

                        if (db.State == ConnectionState.Closed) db.Open();

                        var scalarResult = cmd.ExecuteScalar();

                        if (Convert.ToString(scalarResult) != "")
                        {
                            int totalcount = scalarResult != DBNull.Value ? Convert.ToInt32(scalarResult) : 0;
                            if (totalcount >= 5000)
                            {
                                Dispatcher.Invoke(new Action(() =>
                                {
                                    System.Windows.MessageBox.Show("Please refine the search.", "Too many results!");
                                    bsySearchDatabase.IsBusy = false;
                                }));
                                returnfunction = true;
                                return tempdbsequences;
                            }
                        }

                        cmd.CommandText = "SELECT * FROM [dbo].[FindProteinsByIsobaricSequenceWithFilterbySpecies3](@SequenceTag, N'" + filter + "', " + parentMass + " , " + (Properties.Settings.Default.SearchAllSpecies ? "NULL" : allspecies) + " ) ORDER BY [RANK] DESC, DeltaMass ASC OPTION (RECOMPILE)";

                        int number = 0;
                        SqlParameter param = new SqlParameter();
                        param.ParameterName = "@SequenceTag";
                        param.Value = sequence;

                        cmd.Parameters.Add(param);

                        cmd.CommandType = CommandType.Text;
                        //cn.Open();


                        using (SqlDataReader dr = cmd.ExecuteReader())
                        {
                            while (dr.Read())
                            {
                                if (i++ > 10000) throw new WarningException("Please refine the search.  Too many results were returned!");
                                number++;
                                string seqo = Convert.ToString(dr["Seq"]).Replace('I', 'L');

                                tempaccession = dr["Acc"] != DBNull.Value ? Convert.ToString(dr["Acc"]) : "";
                                //bool localbool = false;
                                //foreach (string se in seqo.ToSymbols())
                                //{
                                //    if (!AminoAcidHelpers.AminoAcidMass2.Keys.Contains(se))
                                //    {
                                //        localbool = true;
                                //        break;
                                //    }
                                //}

                                //if (localbool)
                                //{
                                //    continue;
                                //}

                                if (i != 1)
                                {
                                    for (int j = 1; j < i; j++)
                                    {
                                        if (accessions[j] == tempaccession)
                                        {
                                            boolcontinue = true;
                                            continue;
                                        }
                                    }
                                }

                                if (boolcontinue)
                                {
                                    boolcontinue = false;
                                    continue;
                                }


                                ///var anchorTag = sqsfordbsrch.Where(t => t.Sequence == sequenceforsearch[0] || t.ReverseSequence == sequenceforsearch[0]).OrderByDescending(s => s.Score).First();
                                //double deltamassusingparentandzeroion = DeltaMassUsingParentandZeroIon(dr["Seq"] != DBNull.Value ? Convert.ToString(dr["Seq"]) : "", anchorTag, parentMass); // -18.010565;
                                //double deltamassusingparentandzeroion = DeltaMassUsingParentandZeroIon(dr["Seq"] != DBNull.Value ? Convert.ToString(dr["Seq"]) : "", sequenceforsearch, sqsfordbsrch, parentMass) - 18.010565;

                                tempdbsequences.Add(new SearchResult
                                {
                                    Accession = dr["Acc"] != DBNull.Value ? Convert.ToString(dr["Acc"]) : "",
                                    Description = dr["Des"] != DBNull.Value ? Convert.ToString(dr["Des"]) : "",
                                    Sequence = dr["Seq"] != DBNull.Value ? Convert.ToString(dr["Seq"]) : "",
                                    Species = dr["SciName"] != DBNull.Value ? Convert.ToString(dr["SciName"]) : "",
                                    PairMatch = sequenceforsearch,
                                    //Allthesequencetags = allsequencetags,
                                    //Mass = dr["Mass"] != DBNull.Value ? Math.Round(Convert.ToDouble(dr["Mass"]), 4) : 0,
                                    //DeltaMass = dr["DeltaMass"] != DBNull.Value ? Math.Round(Convert.ToDouble(dr["DeltaMass"]), 4) : 0,
                                    sequencesfordbmatching = aminoacidsforsequence,
                                    CurntIons = crntins,
                                    AllsqsTags = sqsfordbsrch,
                                    ParentMass = parentMass,
                                    //DeltaMassUsingParentandZeroIon = deltamassusingparentandzeroion, ///Subtracting the exact mass of water
                                    //PPM = Math.Abs(PPM.CalculatePPM(Convert.ToDouble(dr["Mass"]), deltamassusingparentandzeroion)),
                                    TagFound = true,
                                    //AnchorTag = anchorTag
                                });
                            }
                        }
                        //cn.Close();
                        // }
                    }
                }
                else
                {
                    string rvsrsequence = ReverseString.Reverse(sequence);

                    //List<String> allspecies = new List<string>();

                    List<String> reverseSequenceforsearch = new List<string>();

                    foreach (string ss in sequenceforsearch)
                    {
                        reverseSequenceforsearch.Add(ReverseString.Reverse(ss));
                    }

                    //.Where(x => (allSpecies || App.DistinctSpecies.Where(c => c.IsSelected && c.species == x.Species).Any())
                    sequenceforsearch.AddRange(reverseSequenceforsearch);

                    //allspecies = App.DistinctSpecies.Where(a => a.IsSelected == true).Select(a => a.species).ToList();

                    // Filter FASTA List by species then by the specified sequence string
                    var sqs = from FASTA f in App.lstFasta
                              where ///(Properties.Settings.Default.SearchAllSpecies)/// || allspecies.Contains(f.Species.ToLower()))&&
                                     sequenceforsearch.Count == 0 || (f.ModifiedSequenceforL.Contains(sequence) || f.ModifiedSequenceforL.Contains(rvsrsequence) || f.Description.IndexOf(filter, StringComparison.OrdinalIgnoreCase) >= 0 || f.Accession.IndexOf(filter, StringComparison.OrdinalIgnoreCase) >= 0)
                              select f;

                    foreach (FASTA f in sqs)
                    {
                        if (i++ > 10000) throw new WarningException("Please refine the search.  Too many results were returned!");
                        string seqo = f.ModifiedSequenceforL;
                        bool localbool = false;
                        foreach (string se in seqo.ToSymbols())
                        {
                            if (!AminoAcidHelpers.AminoAcidMass2.Keys.Contains(se))
                            {
                                localbool = true;
                                break;
                            }
                        }

                        if (localbool)
                        {
                            continue;
                        }

                        //double deltamassusingparentandzeroion = DeltaMassUsingParentandZeroIon(f.Sequence, sequenceforsearch, sqsfordbsrch, parentmass) - 18.010565;
                        tempdbsequences.Add(new SearchResult
                        {
                            Accession = f.Accession,
                            Description = f.Description,
                            Sequence = f.Sequence,
                            Species = f.Species,
                            PairMatch = sequenceforsearch,
                            //Allthesequencetags = allsequencetags,
                            //Mass = f.Mass,
                            //DeltaMass = Math.Abs(parentMass - f.Mass),
                            sequencesfordbmatching = aminoacidsforsequence,
                            CurntIons = crntins,
                            AllsqsTags = sqsfordbsrch,
                            ParentMass = parentMass,
                            //DeltaMassUsingParentandZeroIon = deltamassusingparentandzeroion, ///Subtracting the exact mass of water
                            //PPM = Math.Abs(PPM.CalculatePPM(f.Mass, deltamassusingparentandzeroion)),
                            TagFound = true
                        });
                    }
                }
            }
            catch (Exception ex)
            {
                System.Windows.MessageBox.Show(ex.Message, "Proteomics database error.");
            }
            finally
            {
                var uniqspecies = tempdbsequences.Select(a => a.Species).Distinct().OrderBy(a => a).ToList();
                tempdbsequences = tempdbsequences.OrderByDescending(a => a.YellowandGreenTagHits).ToList(); //.Where(a => a.TagHits > 0 || a.Notagsforhighlight == true)
                Dispatcher.Invoke(new Action(() =>
                {
                    if (!returnfunction)
                    {
                        ComboBox cmb = FindVisualChildByName<ComboBox>(dtgrdSearchSequence, "cmbSpecies");
                        if (cmb != null)
                        {
                            cmb.Items.Clear();
                            cmb.Items.Add("All Species");
                            foreach (var species in uniqspecies)
                            {
                                cmb.Items.Add(species);
                            }
                            cmb.SelectedIndex = 0;
                        }
                        txtSearchbox.Text = Querystring;
                        if (parentMass == 0)
                        {
                            dtgrdSStxtDeltaMass.Visibility = System.Windows.Visibility.Collapsed;
                            dtgrdSStxtMass.Visibility = System.Windows.Visibility.Visible;
                        }
                        else
                        {
                            dtgrdSStxtDeltaMass.Visibility = System.Windows.Visibility.Visible;
                            dtgrdSStxtMass.Visibility = System.Windows.Visibility.Collapsed;
                        }
                    }
                }));
            }

            return tempdbsequences;///.Where(a => a.TagHits > 0 || a.Notagsforhighlight == true).OrderByDescending(a => a.TagHits).ToList();
        }
        /// <summary>
        /// Find the protein and highlight the sequences
        /// </summary>
        /// <param name="filter"></param>
        /// <param name="currentTags"></param>
        /// <param name="ions"></param>
        /// <param name="fastaEntries"></param>
        /// <returns></returns>
        IEnumerable<SearchResult> SearchforfilterusingDBorFasta(string filter, IEnumerable<FindSequenceTags.SequenceTag> currentTags, IEnumerable<Cluster> ions, double parentMass, ref bool count, List<FASTA> fastaEntries = null)
        {
            var tempdbsequences = new List<SearchResult>();
            bool returnfunction = false;
            //Dispatcher.Invoke(new Action(() =>
            //{
            //    ComboBox cmb = FindVisualChildByName<ComboBox>(dtgrdSearchSequence, "cmbSpecies");
            //    if (cmb != null)
            //    {
            //        cmb.Items.Clear();
            //        cmb.Items.Add("All Species");
            //    }
            //    dbsequences.Clear();
            //    dtgrdSearchSequence.ItemsSource = null;
            //    searchseq = false;
            //}));

            count = false;

            string[] spst = { "\t" };

            List<string> allsequencetags = new List<string>();
            List<Cluster> crntins = new List<Cluster>();
            crntins = ions.OrderBy(a => a.MonoMass).ToList();
            List<FindSequenceTags.SequenceTag> sqsfordbsrch = new List<FindSequenceTags.SequenceTag>();


            if (currentTags != null && currentTags.Any())
            {
                sqsfordbsrch = currentTags.Where(a => a.DatabaseHits != "0").ToList();
                allsequencetags = currentTags.Where(a => a.DatabaseHits != "0").Select(a => a.Sequence).ToList();
                allsequencetags = allsequencetags.Distinct().ToList();
            }
            else
            {
                allsequencetags.Add("");
            }

            List<string> emptystringlist = new List<string>();
            char[] reversechar = Pairmatch.ToCharArray();
            List<string> emptystring = new List<string>();
            emptystring.Add("");


            try
            {
                if (!DechargerVM.UseFasta)
                {
                    //using (SqlConnection cn = new SqlConnection(Properties.Settings.Default.ConnectionString))
                    // {
                    using (SqlCommand cmd = db.CreateCommand())
                    {
                        cmd.CommandTimeout = SqlcommandTimeout;

                        string allspecies = "'" + string.Join(",", App.DistinctSpecies.Where(a => a.IsSelected == true).Select(a => a.SpeciesID).ToList()) + "'";

                        cmd.CommandText = "SELECT * FROM [dbo].[FindProteinsByFilterbySpecies](N'" + filter + "' ,'" + parentMass + "' , " + (Properties.Settings.Default.SearchAllSpecies ? "NULL" : allspecies) + " )  ORDER BY [RANK] DESC, DeltaMass ASC";

                        int number = 0;

                        cmd.CommandType = CommandType.Text;
                        cmd.CommandTimeout = 10;

                        if (db.State == ConnectionState.Closed) db.Open();

                        int i = 0;

                        using (SqlDataReader dr = cmd.ExecuteReader())
                        {
                            while (dr.Read())
                            {
                                count = true;
                                if (i > 10000)
                                {
                                    Dispatcher.Invoke(new Action(() =>
                                    {
                                        System.Windows.MessageBox.Show("Please refine the search.", "Too many results.");
                                        bsySearchDatabase.IsBusy = false;
                                    }));
                                    returnfunction = true;
                                    return tempdbsequences;
                                }
                                i++;
                                number++;
                                string seqo = Convert.ToString(dr["Seq"]).Replace('I', 'L');
                                bool localbool = false;
                                foreach (var se in seqo.ToSymbols())
                                {
                                    if (!AminoAcidHelpers.AminoAcidMass2.Keys.Contains(se))
                                    {
                                        localbool = true;
                                        break;
                                    }
                                }

                                if (localbool)
                                {
                                    continue;
                                }
                                tempdbsequences.Add(new SearchResult
                                {
                                    Accession = dr["Acc"] != DBNull.Value ? Convert.ToString(dr["Acc"]) : "",
                                    Description = dr["Des"] != DBNull.Value ? Convert.ToString(dr["Des"]) : "",
                                    Sequence = dr["Seq"] != DBNull.Value ? Convert.ToString(dr["Seq"]) : "",
                                    Species = dr["SciName"] != DBNull.Value ? Convert.ToString(dr["SciName"]) : "",
                                    PairMatch = emptystringlist,
                                    //Allthesequencetags = allsequencetags,
                                    //Mass = dr["Mass"] != DBNull.Value ? Math.Round(Convert.ToDouble(dr["Mass"]), 2) : 0,
                                    //DeltaMass = dr["DeltaMass"] != DBNull.Value ? Math.Round(Convert.ToDouble(dr["DeltaMass"]), 2) : 0,
                                    sequencesfordbmatching = aminoacidsforsequence,
                                    CurntIons = crntins,
                                    AllsqsTags = sqsfordbsrch,
                                    ParentMass = parentMass,
                                    //PPM = Math.Abs(PPM.CalculatePPM(Convert.ToDouble(dr["Mass"]), Convert.ToDouble(dr["DeltaMass"]))),
                                    TagFound = false
                                });
                            }
                        }
                        //cn.Close();
                        //}
                    }
                }
                else
                {
                    //List<string> allspecies = App.DistinctSpecies.Where(a => a.IsSelected == true).Select(a => a.species.ToLower()).ToList(); || allspecies.Contains(f.Species.ToLower())(Properties.Settings.Default.SearchAllSpecies ) && 

                    // Comparing using OrdinalIgnoreCase because of assumed Performance advantage: https://rhale78.wordpress.com/2011/05/16/string-equality-and-performance-in-c/
                    // http://stackoverflow.com/questions/492799/difference-between-invariantculture-and-ordinal-string-comparison

                    var sqs = from FASTA f in App.lstFasta
                              where f.Description.IndexOf(filter, StringComparison.OrdinalIgnoreCase) >= 0 || f.Accession.IndexOf(filter, StringComparison.OrdinalIgnoreCase) >= 0
                              select f;

                    int i = 0;
                    foreach (FASTA f in sqs)
                    {
                        if (i++ > 10000) throw new WarningException("Please refine the search.  Too many results were returned!");
                        string seqo = f.ModifiedSequenceforL;
                        bool localbool = false;
                        foreach (string se in seqo.ToSymbols())
                        {
                            if (!AminoAcidHelpers.AminoAcidMass2.Keys.Contains(se))
                            {
                                localbool = true;
                                break;
                            }
                        }

                        if (localbool)
                        {
                            continue;
                        }

                        List<string> emptystrings = new List<string>();
                        emptystring.Add(string.Empty);
                        count = true;

                        tempdbsequences.Add(new SearchResult
                        {
                            Accession = f.Accession,
                            Description = f.Description,
                            Sequence = f.Sequence,
                            Species = f.Species,
                            PairMatch = emptystringlist,
                            //Allthesequencetags = allsequencetags,
                            //Mass = f.Mass,
                            //DeltaMass = Math.Abs(parentMass - f.Mass),
                            sequencesfordbmatching = aminoacidsforsequence,
                            CurntIons = crntins,
                            AllsqsTags = sqsfordbsrch,
                            ParentMass = parentMass,
                            //PPM = Math.Abs(PPM.CalculatePPM(f.Mass, Math.Abs(parentmass - f.Mass))),
                            TagFound = false
                        });
                    }
                }
            }
            catch (Exception ex)
            {
                System.Windows.MessageBox.Show(ex.Message, "Proteomics database error.");
            }
            finally
            {
                var uniqspecies = tempdbsequences.Select(a => a.Species).Distinct().OrderBy(a => a).ToList();
                //tempdbsequences = tempdbsequences.ToList();
                Dispatcher.Invoke(new Action(() =>
                {
                    if (!returnfunction)
                    {
                        ComboBox cmb = FindVisualChildByName<ComboBox>(dtgrdSearchSequence, "cmbSpecies");
                        if (cmb != null)
                        {
                            cmb.Items.Clear();
                            cmb.Items.Add("All Species");
                            foreach (var species in uniqspecies)
                            {
                                cmb.Items.Add(species);
                            }
                            cmb.SelectedIndex = 0;
                        }

                        txtSearchbox.Text = Querystring;
                        if (parentMass == 0)
                        {
                            dtgrdSStxtDeltaMass.Visibility = System.Windows.Visibility.Collapsed;
                            dtgrdSStxtMass.Visibility = System.Windows.Visibility.Visible;
                        }
                        else
                        {
                            dtgrdSStxtDeltaMass.Visibility = System.Windows.Visibility.Visible;
                            dtgrdSStxtMass.Visibility = System.Windows.Visibility.Collapsed;
                        }
                    }
                }));
            }

            return tempdbsequences.OrderByDescending(a => Math.Abs(a.YellowandGreenTagHits)).ToList(); //.Where(a => a.TagHits > 0 || a.Notagsforhighlight == true)
        }

        /// <summary>
        /// Using http://social.msdn.microsoft.com/Forums/vstudio/en-US/3237cb62-3a6a-4663-9f1e-7894cb24c674/access-a-control-placed-inside-header-template-of-a-datagrid-in-wpf?forum=wpf
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="parent"></param>
        /// <param name="name"></param>
        /// <returns></returns>
        public static T FindVisualChildByName<T>(DependencyObject parent, string name) where T : DependencyObject
        {
            for (int i = 0; i < VisualTreeHelper.GetChildrenCount(parent); i++)
            {
                var child = VisualTreeHelper.GetChild(parent, i);
                string controlName = child.GetValue(Control.NameProperty) as string;
                if (controlName == name)
                {
                    return child as T;
                }
                else
                {
                    T result = FindVisualChildByName<T>(child, name);
                    if (result != null)
                        return result;
                }
            }
            return null;
        }

        internal List<Range> FindBestXicTargets(Cluster cluster, bool singleRange = true)
        {
            if (cluster == null) return null;

            var topIndexes = Enumerable.Range(0, cluster.IsoPattern.Length - 1).Where(i => cluster.IsoPattern[i] > 0.33);

            if (singleRange)
            {

                var anchorPeak = cluster.Peaks.Where(p => p.IsCorePeak).OrderBy(y => y.Delta).First();

                var min = anchorPeak.MZ + (((topIndexes.First() - anchorPeak.IsoIndex) - 0.5) * (SignalProcessor.ProtonMass / cluster.Z));
                var max = anchorPeak.MZ + (((topIndexes.Last() - anchorPeak.IsoIndex) + 0.5) * (SignalProcessor.ProtonMass / cluster.Z));

                //var min = cluster.Peaks.Where(p => p.IsoIndex == topIndexes.First()).First().MZ - ((SignalProcessor.NeutronMass / cluster.Z) / 2);
                //var max = cluster.Peaks.Where(p => p.IsoIndex == topIndexes.Last()).First().MZ + ((SignalProcessor.NeutronMass / cluster.Z) / 2);

                return new List<Range> { new Range() { Start = min, End = max } };
            }

            var xicList = new List<Range>();

            foreach (var anIndex in topIndexes)
                xicList.Add(new Range()
                {
                    Start = cluster.Peaks.Where(p => p.IsoIndex == anIndex).First().MZ - ((SignalProcessor.ProtonMass / cluster.Z) / 4),
                    End = cluster.Peaks.Where(p => p.IsoIndex == anIndex).First().MZ - ((SignalProcessor.ProtonMass / cluster.Z) / 4)
                });

            return xicList;
        }

        double currentspectrumxaxisminvalue = 0.0;

        internal Chart CurrentChromatogram
        {
            get { return (tabControl1.SelectedItem as TabItem).Tag as Chart; }
        }

        void Chrom_MouseLeftButtonDown(object sender, PlotAreaMouseButtonEventArgs e)
        {

            Debug.WriteLine("mouse down");
            if (MainPointProvider == null) return;

            var selection = ((sender as PlotArea).Tag as Chart).TrendLines[2];

            selection.StartValue = e.XValue;
            selection.EndValue = e.XValue;
            //currentspectrumxaxisminvalue = Convert.ToDouble(e.XValue);
            SelectingRange = true;
        }

        void Chrom_MouseRightButtonDown(object sender, PlotAreaMouseButtonEventArgs e)
        {

            Debug.WriteLine("right mouse down");
            if (MainPointProvider == null) return;

            var selection = ((sender as PlotArea).Tag as Chart).TrendLines[3];

            selection.StartValue = e.XValue;
            selection.EndValue = e.XValue;

            SelectingQuantRange = true;
        }

        void Chrom_MouseLeftButtonUp(object sender, PlotAreaMouseButtonEventArgs e)
        {

            Debug.WriteLine("mouse up");

            var selection = ((sender as PlotArea).Tag as Chart).TrendLines[2];
            if (selection.StartValue == null && selection.EndValue == null) return;

            //zoomthespectrum(sender, (double)(e.XValue), currentspectrumxaxisminvalue);
            var pixelsSelected = 0d;

            if (selection.StartValue != null)
            {
                var selectionWidth = Math.Abs((double)e.XValue - (double)selection.StartValue);
                var viewWidth = Math.Abs((double)((sender as PlotArea).Tag as Chart).AxesX[0].ViewMaximum - (double)((sender as PlotArea).Tag as Chart).AxesX[0].ViewMinimum);
                var pixelPerWidth = ((sender as PlotArea).Tag as Chart).AxesX[0].ActualWidth / viewWidth;

                pixelsSelected = selectionWidth * pixelPerWidth;
            }

            if (pixelsSelected < PixelTolerance)
            {
                // Single point selected
                //var newScanIndex = x.ScanIndex((float)(double)selection.EndValue);
                CurrentScanRange.Start = CurrentScanRange.End = (float)(double)selection.EndValue;

                DisplayNewSpectrum(CurrentScanRange);
            }
            else
            {
                // Range selected
                //var startScanIndex = x.ScanIndex((float)(double)selection.StartValue);
                //var endScanIndex = x.ScanIndex((float)(double)e.XValue);
                CurrentScanRange.Start = Math.Min((double)selection.StartValue, (double)e.XValue);
                CurrentScanRange.End = Math.Max((double)selection.StartValue, (double)e.XValue);

                //DisplayNewSpectrum(CurrentScanRange, "Full ms ");
                DisplayNewSpectrum(CurrentScanRange, string.Empty, SpecMsLevel.MS);  // only sum MS1 scans
            }

            SelectingRange = false;
        }

        void zoomthespectrum(object sender, double axismaximum, double axisminimum)
        {
            Dispatcher.Invoke(new Action(() =>
                    {
                        ((sender as PlotArea).Tag as Chart).AxesX[0].AxisMinimum = axisminimum;
                        ((sender as PlotArea).Tag as Chart).AxesX[0].AxisMaximum = axismaximum;
                    }));
        }

        void Chrom_MouseRightButtonUp(object sender, PlotAreaMouseButtonEventArgs e)
        {

            Debug.WriteLine("mouse up");

            var chromChart = (sender as PlotArea).Tag as Chart;

            var selection = (chromChart).TrendLines[3];
            if (selection.StartValue == null && selection.EndValue == null) return;

            var pixelsSelected = 0d;

            if (selection.StartValue != null)
            {
                var selectionWidth = Math.Abs((double)e.XValue - (double)selection.StartValue);
                var viewWidth = Math.Abs((double)chromChart.AxesX[0].ViewMaximum - (double)chromChart.AxesX[0].ViewMinimum);
                var pixelPerWidth = chromChart.AxesX[0].ActualWidth / viewWidth;

                pixelsSelected = selectionWidth * pixelPerWidth;

            }

            if (selection.StartValue != null && selection.EndValue != null && SelectingQuantRange && chromChart.Series[0].DataSource != null && chromChart.Series[0].DataSource is MassSpectrometry.Chromatogram)
            {
                // Calculate Area under the Curve and add to the PeakAreas list
                var chrom = chromChart.Series[0].DataSource as MassSpectrometry.Chromatogram;

                if (chromChart.Tag is Cluster)
                {
                    var targetIon = chromChart.Tag as Cluster;

                    if (chkMultiCharge.IsChecked.HasValue && chkMultiCharge.IsChecked.Value && this.MainPointProvider is RMSProvider) // || this.MainPointProvider is RMSProvider32))
                    {
                        var r = this.MainPointProvider;

                        var targetClusters = FindChargeVariants(targetIon);

                        foreach (var aCluster in targetClusters.OrderByDescending(c => c.Intensity))
                        {
                            var targetRange = FindBestXicTargets(aCluster);
                            Chromatogram points;

                            //if (r is RMSProvider)
                            //{
                                points = (r as RMSProvider).ExtractIon(targetRange);
                            //}
                            //else
                            //{
                            //    points = (r as RMSProvider32).ExtractIon(targetRange);
                            //}
                            var area = points.CalculateArea((double)selection.StartValue, (double)selection.EndValue);

                            Items.Add(new QuantitationItem() { Area = area.ToString("0.0"), RtStart = ((double)selection.StartValue).ToString("0.00"), RtEnd = ((double)selection.EndValue).ToString("0.00"), Mass = aCluster.MonoMass.ToString("0.000"), Z = aCluster.Z.ToString("0"), XicMzStart = targetRange.First().Start.ToString("0.00"), XicMzEnd = targetRange.First().End.ToString("0.00") });
                        }
                    }
                    else
                    {
                        var area = chrom.CalculateArea((double)selection.StartValue, (double)selection.EndValue);

                        Items.Add(new QuantitationItem() { Area = area.ToString("0.0"), RtStart = ((double)selection.StartValue).ToString("0.00"), RtEnd = ((double)selection.EndValue).ToString("0.00"), Mass = targetIon.MonoMass.ToString("0.000"), Z = targetIon.Z.ToString("0"), XicMzStart = chromChart.Titles[0].Text.Split(' ')[2].Trim(), XicMzEnd = chromChart.Titles[0].Text.Split(' ')[4].Trim() });
                    }

                }
            }

            SelectingQuantRange = false;
        }

        double sequencetagmass = 0.0;

        List<SpectrumInfo> GetSpecList(Range values)
        {
            var endScanIndex = MainPointProvider.ScanIndex(values.End);
            var currentScanIndex = MainPointProvider.ScanIndex(values.Start);
            var returnList = new List<SpectrumInfo>();

            while (currentScanIndex <= endScanIndex)
            {
                returnList.Add(new SpectrumInfo() { ScanNumber = currentScanIndex, Title = MainPointProvider.Title(currentScanIndex), RetentionTime = MainPointProvider.RetentionTime(currentScanIndex), MsLevel = MainPointProvider.MsLevel(currentScanIndex) });

                if (MainPointProvider.NextScan(currentScanIndex).HasValue)
                    currentScanIndex = MainPointProvider.NextScan(currentScanIndex).Value;
                else
                    break;
            }

            return returnList;
        }

        private BackgroundWorker displaySpecWorker = new BackgroundWorker() { WorkerSupportsCancellation = true };

        /// <summary>
        /// When there is no File loaded, then load from Sequence Searches
        /// </summary>
        /// <param name="sqssearches"></param>
        void DisplayNewSpectrumNoFile(SearchResult sqssearches)
        {
            BackgroundWorker bgworkerdisplaynewspectrumnofile = new BackgroundWorker();
            bgworkerdisplaynewspectrumnofile.RunWorkerCompleted += bgworkerdisplaynewspectrumnofile_RunWorkerCompleted;

            var scans = sqssearches.allspectrums;

            bgworkerdisplaynewspectrumnofile.DoWork += (s, args) =>
            {
                lock (lockObj)
                {
                    Dispatcher.Invoke(new Action(() =>
                    {
                        var worker = s as BackgroundWorker;
                        if (scans == null || scans.Count == 0) //If it is an empty list then return
                        {
                            return;
                        }
                        List<int?> ParentZ = new List<int?>();
                        List<string> ScanNumbers = new List<string>();

                        ClearFilters();
                        CurrentIons.Clear(); //Clear all the Ions from the previous spectrum.
                        sqsalldenovotgs.Clear(); //Clear all the sequence tags.

                        foreach (var aScan in scans)
                        {
                            ParentZ.Add(aScan.ParentZ);
                            ParentZ.Add(aScan.ParentZ);
                            ScanNumbers.Add(Convert.ToString(aScan.ScanNumber));
                        }

                        CurrentSpectrum.ParentIon = scans[0].ParentIon;
                        CurrentSpectrum.ParentMass = scans[0].ParentMass;

                        ParentZ = new List<int?>();

                        DechargerVM.ActivationType = string.Empty;
                        App.ActivationType = string.Empty;
                        for (int i = 0; i < sqssearches.allspectrums.Count; i++)
                        {
                            DechargerVM.ActivationType += "," + sqssearches.allspectrums[i].Activation;
                            App.ActivationType += "," + sqssearches.allspectrums[i].Activation;
                        }

                        //CurrentSpectrum.ParentCharge = crntscan.ParentZ;

                        App.ParentDetails = new clsParentInfo
                        {
                            ParentZ = ParentZ.Max(),
                            ScanNumber = string.Join(",", ScanNumbers)
                        };

                        CurrentSpectrum.ScanNumber = scans[0].ScanNumber;
                        currentparent.ParentZ = ParentZ.Max();
                        currentparent.ScanNumber = string.Join(",", ScanNumbers);

                        //PopulateRedandGreenMarkers(null, false, false, true);

                        tabItem1.IsEnabled = true;
                        tbGreenMarkers.IsEnabled = true;
                        tbMatchList.IsEnabled = true;
                        tbMonoMassList.IsEnabled = true;

                        //btnNext.IsEnabled = false;
                        //txtScanNum.IsEnabled = false;
                        //btnPrevious.IsEnabled = false;

                        RedMarkersSeries.DataPoints.Clear();
                        GreenMarkersSeries.DataPoints.Clear();
                        RedMarkersSeriesBright.DataPoints.Clear();
                        RedMarkersSeriesLite.DataPoints.Clear();
                        GreenMarkersSeriesBright.DataPoints.Clear();
                        GreenMarkersSeriesLite.DataPoints.Clear();

                        PopulateRedandGreenMarkers(null, false, false, true);
                        lblExperimentalMass.Text = "";
                        CurrentSpectrum.Title = sqssearches.ScanTitle;
                        TempCurrentIons.Clear();
                        TempMergedIons.Clear();
                        CTerminusLine.DataPoints.Clear();

                        TempMergedIons.AddRange(sqssearches.CurntIons);

                        TempCurrentIons = TempMergedIons;

                        //TempMergedIons.AddRange(MainPointProvider.DetectIons(aScan.ScanNumber, 1, aScan.ParentZ.Value).Where(ion => ion.Score > minScore));  // only run charge detector up to Parent Charge

                        //TempCurrentIons = SignalProcessor.ConsolidateIons(TempMergedIons, true);

                        if (!worker.CancellationPending)
                        {
                            // Now, consolidate all those ions where they are the same ion
                            //TempCurrentIons = SignalProcessor.ConsolidateIons(TempMergedIons, true);
                            args.Result = scans;
                            Debug.Print("DoWork Complete.  " + s.GetHashCode());
                        }
                        else
                        {
                            args.Cancel = true;
                            args.Result = null;

                            Debug.Print("DoWork Cancelled.  " + s.GetHashCode());
                        }
                    }));
                }
            };

            bgworkerdisplaynewspectrumnofile.RunWorkerAsync();
        }

        void bgworkerdisplaynewspectrumnofile_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            double min = 0;
            double max = 0;
            try
            {
                if (e.Cancelled) /// || (displaySpecWorker != null && sender.GetHashCode() != displaySpecWorker.GetHashCode()))
                    return;

                if (e.Result is Exception) return;
                if (e.Result == null || !(e.Result is IEnumerable<SpectrumInfo>)) return;
                lock (lockObj)
                {
                    var scans = e.Result as IEnumerable<SpectrumInfo>;

                    Dispatcher.Invoke(new Action(() =>
                    {
                        //BottomChart.Series[0].DataPoints.Clear();
                        BottomChart.Series[0].DataSource = null;
                        //ThermoFischer.DataPoints.Clear();
                        ThermoFischer.DataSource = null;
                        BottomChart.Series[4].DataPoints.Clear();
                        BottomChart.Series[5].DataPoints.Clear();
                        AnnotationBars1.DataPoints.Clear();
                        AnnotationBars2.DataPoints.Clear();
                        AnnotationBars3.DataPoints.Clear();
                        GrayBarSeries.DataPoints.Clear();
                        RedBarSeries.DataPoints.Clear();
                        AnnotationBarsBlue.DataPoints.Clear();
                        ReverseSeries.DataPoints.Clear();
                    }));

                    Dispatcher.Invoke(new Action(() =>
                    {
                        BottomChart.IsEnabled = true;
                        CurrentMonoMasses.Clear();
                        ReverseCurrentMonomasses.Clear();
                        MonoMassesfordbSequence.DataSource = null;
                        //CurrentIons.Clear();
                        //MergedIons.Clear();
                        MergeCurrentIons.Clear();
                        WaterLossSeries.DataPoints.Clear();
                        AmmoniaLossSeries.DataPoints.Clear();
                        CurrentSpectrum.Clear();
                        ReverseCurrentSpectrum.Clear();
                        ThermoPoint.Clear();
                        btnFindAA.IsEnabled = true;
                        //parentmass = 0;
                        CurrentMode = ChartMode.Mass;
                        CurrentSpectrum.ParentIon = null;
                        //sequencemerge = false;
                        // Reset any Y-Axis scaling                        
                        this.BottomChart.AxesY[0].AxisMaximum = null;
                        zoomWidth = 0;
                        ParentMonoSeries.DataSource = null;
                        ZeroSeries.DataSource = null;

                        MonoMasslabel.DataPoints.Clear();
                    }));
                    CurrentIons = TempCurrentIons;
                    MergedIons = TempMergedIons;

                    foreach (var aCluster in CurrentIons)
                    {
                        CurrentSpectrum.AddRange(aCluster.Peaks);
                    }

                    if (scans.Where(s => s.ParentIon != null).Any())
                    {
                        // We have at least 1 MS2 scan with a parent!
                        Dispatcher.Invoke(new Action(() =>
                        {
                            CurrentSpectrum.ParentIon = scans.Where(s => s.ParentMass == scans.Select(t => t.ParentMass).Median()).FirstOrDefault().ParentIon;
                            CurrentSpectrum.ParentIon.Description = "Parent Ion\nMass = " + CurrentSpectrum.ParentIon.MonoMass.ToString("0.0000");
                            ParentMass = CurrentSpectrum.ParentIon.MonoMass;
                            ParentMonoSeries.DataSource = new Cluster[] { CurrentSpectrum.ParentIon };
                            ZeroMonomass zm = new ZeroMonomass();
                            zm.Intensity = CurrentSpectrum.ParentIon.Intensity;
                            zm.MonoMass = 0;
                            ZeroSeries.DataSource = new ZeroMonomass[] { zm };
                            setdbmonointensity = CurrentSpectrum.ParentIon.Intensity;
                        }));
                    }

                    if (scans.Count() == 1)  // Single Scan
                    {

                        if (addparentmassfromMergeSpectra)
                        {
                            var crntspc = mgrspectra.Where(a => a.ScanNumber == Convert.ToInt16(App.ScanNumber != null ? App.ScanNumber : "0")).Any() ? mgrspectra.Where(a => a.ScanNumber == Convert.ToInt16(App.ScanNumber != null ? App.ScanNumber : "0")).First() : new SpectrumInfo();
                            if (crntspc.MsLevel == SpecMsLevel.MSMS)
                            {
                                CurrentSpectrum.ParentIon = crntspc.ParentIon;
                                CurrentSpectrum.ParentMass = crntspc.ParentMass;
                            }
                        }

                        CurrentScanNumber = scans.First().ScanNumber;
                        CurrentSpectrum.ScanNumber = scans.First().ScanNumber;
                        scannumbers = Convert.ToString(scans.First().ScanNumber);

                        Dispatcher.Invoke(new Action(() =>
                        {
                            // set single spectrum title information
                            //CurrentSpectrum.Title = MainPointProvider.Title(CurrentScanNumber.Value);
                            //CurrentSpectrum.Title = MainPointProvider.Title(CurrentScanNumber.Value);
                            if (scans.First().ParentMass.HasValue)
                            {
                                //CurrentSpectrum.Title += " (" + scans.First().ParentMass.Value.ToString("0.000") + ") ";

                                Dispatcher.Invoke(new Action(() =>
                                {
                                    lblExperimentalMass.Text = Convert.ToString(scans.First().ParentMass.Value.ToString(MassValueFormat));
                                }));
                                //parentmass = Convert.ToDouble(scans.First().ParentMass.Value);
                            }
                            else if (addparentmassfromMergeSpectra)
                            {
                                foreach (var aScan in scans)
                                {
                                    var crntscan = mgrspectra.Where(a => a.ScanNumber == aScan.ScanNumber).First();
                                    if (crntscan.MsLevel == SpecMsLevel.MSMS)
                                    {
                                        CurrentSpectrum.ParentIon = crntscan.ParentIon;
                                        CurrentSpectrum.ParentMass = crntscan.ParentMass;
                                    }
                                    //CurrentSpectrum.ParentCharge = crntscan.ParentZ;
                                }
                                if (CurrentSpectrum.ParentIon != null)
                                {
                                    ParentMonoSeries.DataSource = new Cluster[] { CurrentSpectrum.ParentIon };
                                    //CurrentSpectrum.Title += " (" + CurrentSpectrum.ParentIon.MonoMass.ToString("0.000") + ") ";
                                    Dispatcher.Invoke(new Action(() =>
                                    {
                                        lblExperimentalMass.Text = Convert.ToString(CurrentSpectrum.ParentIon.MonoMass.ToString(MassValueFormat));
                                    }));
                                    ZeroMonomass zm = new ZeroMonomass();
                                    zm.Intensity = CurrentSpectrum.ParentIon.Intensity;
                                    zm.MonoMass = 0;
                                    ZeroSeries.DataSource = new ZeroMonomass[] { zm };
                                    setdbmonointensity = CurrentSpectrum.ParentIon.Intensity;
                                    //CurrentSpectrum.Title = "Consolidated MS2 Scans: " + string.Join(", ", scans.Select(s => s.ScanNumber)) + " (" + CurrentSpectrum.ParentIon.MonoMass.ToString("0.000") + ")";
                                }
                                else
                                {
                                    BottomChart.Titles[1].Text = "Scan " + CurrentScanNumber.ToString() + ", " + DechargerVM.SpectralDataFilename; ///App.XMLFileName;/// +", " + MainPointProvider.Filename;
                                }
                            }
                            BottomChart.Titles[1].Text = "Scan " + CurrentScanNumber.ToString() + ", " + DechargerVM.SpectralDataFilename; ///App.XMLFileName; /// +", " + MainPointProvider.Filename;
                        }));
                    }

                    else  // Multiple Scans
                    {
                        // set multiple scan title information
                        scans = scans.OrderBy(s => s.ScanNumber);

                        CurrentScanNumber = 0;

                        BottomChart.Titles[1].Text = "Merged" + ", " + App.XMLFileName;
                        //CurrentSpectrum.ScanNumber = string.Join(",", scans.Select(a => a.ScanNumbers));

                        Dispatcher.Invoke(new Action(() =>
                        {
                            // set spectrum title information
                            if (scans.All(s => s.MsLevel == SpecMsLevel.MS))
                            {
                                //CurrentSpectrum.Title = "Sum of MS Scans for " + scans.First().RetentionTime.Value.ToString("0.000") + " to " + scans.Last().RetentionTime.Value.ToString("0.000") + " minutes";
                            }
                            else if (scans.All(s => s.MsLevel == SpecMsLevel.MSMS))
                            {
                                if (CurrentSpectrum.ParentIon != null)
                                {
                                    //  CurrentSpectrum.Title = "Consolidated MS2 Scans: " + string.Join(", ", scans.Select(s => s.ScanNumber)) + " (" + CurrentSpectrum.ParentIon.MonoMass.ToString("0.000") + ")";
                                    Dispatcher.Invoke(new Action(() =>
                                    {
                                        lblExperimentalMass.Text = Convert.ToString(scans.First().ParentMass.Value.ToString(MassValueFormat));
                                    }));
                                }
                                else
                                {
                                    //CurrentSpectrum.Title = "Consolidated MS2 Scans: " + string.Join(", ", scans.Select(s => s.ScanNumber)) + " (" + "No ParentMass Detected" + ")";
                                }
                                //parentmass = CurrentSpectrum.ParentIon.MonoMass;
                                //CurrentParentMass = scans.Select(s => s.ParentMass).Median();
                            }
                            else
                            {
                                //CurrentSpectrum.Title = "Mix of MS1 and MS2 Scans: " + string.Join(", ", scans.Select(s => s.ScanNumber)); // +" (" + string.Join(", ", scans.Select(s => s.ParentMass.ToString())) + ")";
                                //CurrentParentMass = scans.Select(s => s.ParentMass).Median();
                            }
                            scannumbers = string.Join(", ", scans.Select(s => s.ScanNumber));
                            //   BottomChart.Titles[1].Text = "Merged, " + MainPointProvider.Filename;
                        }));
                    }

                    CurrentMode = ChartMode.Mass;


                    //foreach (var anIon in MergedIons)
                    //    if (anIon.Intensity > 9347 && anIon.Intensity < 9348)
                    //        Debug.Print("Suspect Ion");

                    // Decharged Mass Spectrum
                    Dispatcher.Invoke(new Action(() =>
                    {
                        txtScanNum.Text = (scans.Count() > 1) ? "Merged" : CurrentScanNumber.ToString();
                    }));


                    int width = (int)BottomChart.AxesX[0].ActualWidth;
                    if (CurrentSpectrum.Count >= 1)  // some spectra could have no points
                    {
                        if (CurrentMode == ChartMode.Mass)
                        {
                            CurrentSpectrum.SortByMass();

                            min = CurrentSpectrum.MinBy(p => p.Mass).Mass;
                            max = sequencetagmass = CurrentSpectrum.ParentIon != null ? CurrentSpectrum.ParentIon.MonoMass : CurrentSpectrum.MaxBy(p => p.Mass).Mass;

                            //if (CurrentSpectrum.ParentIon
                            //if (MainPointProvider.ScanType(scans.First().ScanNumber) == "MS2")
                            //if (MainPointProvider.MsLevel(scans.First().ScanNumber) == SpecMsLevel.MSMS)
                            {
                                min = 0;

                                if (max <= CurrentSpectrum.ParentMass)
                                    max = CurrentSpectrum.ParentMass.Value;
                            }

                            if (CurrentSpectrum.ParentIon != null)
                            {
                                if (max <= CurrentSpectrum.ParentMass)
                                    max = CurrentSpectrum.ParentMass.Value;
                            }

                            min = min - (max - min) * 0.035;  // This gives us a buffer on the ends of the X axis
                            max = max + (max - min) * 0.035;  // This gives us a buffer on the ends of the X axis
                            Dispatcher.Invoke(new Action(() =>
                            {
                                CurrentSpectrum.Add(new ClusterPeak() { Mass = min, Intensity = 0 });
                                CurrentSpectrum.Add(new ClusterPeak() { Mass = max, Intensity = 0 });

                                BottomChart.AxesX[0].AxisMinimum = min;
                                BottomChart.AxesX[0].AxisMaximum = max;

                                Debug.WriteLine("Point Count: " + CurrentSpectrum.Range(min, max, (int)BottomChart.AxesX[0].ActualWidth * (Properties.Settings.Default.HighBin ? 2 : 1)).Count());

                                //foreach (var item in collection)
                                //{
                                //    BottomChart.Series[0].DataPoints.Add()
                                //}

                                BottomChart.Series[0].DataSource = CurrentSpectrum.Range(min, max, (int)BottomChart.AxesX[0].ActualWidth * (Properties.Settings.Default.HighBin ? 2 : 1));



                                //if (MainPointProvider.ScanType(scans.First().ScanNumber) == "MS2" && CurrentSpectrum.ParentMass != null)
                                if (CurrentSpectrum.ParentIon != null)
                                {
                                    var reverseions = (from d in CurrentSpectrum.Where(a => a.Mass <= CurrentSpectrum.ParentMass)
                                                       select new ClusterPeak
                                                       {
                                                           Parent = d.Parent,
                                                           Intensity = d.Intensity,
                                                           MZ = d.MZ,
                                                           //Z = d.Z,
                                                           Delta = d.Delta,
                                                           IsCorePeak = d.IsCorePeak,
                                                           Mass = CurrentSpectrum.ParentMass.Value - d.Mass
                                                       });
                                    ReverseCurrentSpectrum = new Spectrum(reverseions);
                                    ReverseSeries.DataSource = ReverseCurrentSpectrum.Range(min, max, (int)BottomChart.AxesX[0].ActualWidth * (Properties.Settings.Default.HighBin ? 2 : 1));
                                }

                                //if (mergespectra)
                                //{
                                //    var reverseions = (from d in CurrentSpectrum.Where(a => a.Mass <= CurrentSpectrum.ParentIon.MonoMass)
                                //                       select new ClusterPeak
                                //                       {
                                //                           Parent = d.Parent,
                                //                           Intensity = d.Intensity,
                                //                           MZ = d.MZ,
                                //                           //Z = d.Z,
                                //                           Delta = d.Delta,
                                //                           IsCorePeak = d.IsCorePeak,
                                //                           Mass = CurrentSpectrum.ParentIon.MonoMass - d.Mass
                                //                       });
                                //    ReverseCurrentSpectrum = new PeakList(reverseions);
                                //    ReverseSeries.DataSource = ReverseCurrentSpectrum.Range(min, max, (int)BottomChart.AxesX[0].ActualWidth * (Properties.Settings.Default.HighBin ? 2 : 1));
                                //    mergespectra = false;
                                //}

                                grdDirection.Visibility = ReverseSeries.DataPoints.Count() > 0 ? Visibility.Visible : Visibility.Hidden;

                                //if (Properties.Settings.Default.ShowThermo)/// && MainPointProvider is RMSProvider)
                                //    ThermoFischer.DataSource = ThermoPoint;

                                BottomChart.Series[7].DataPoints.Clear();

                                BottomChart.AxesX[0].AxisMinimum = min;
                                BottomChart.AxesX[0].AxisMaximum = max;

                                //try
                                //{
                                //    BottomChart.AxesX[0].Zoom(min, max, min, max);
                                //}
                                //catch (Exception ex)
                                //{
                                //    BottomChart.AxesX[0].Zoom(min, max, min, max);
                                //}

                                BottomChart.AxesX[0].Title = "Mass (amu)";
                            }));
                        }
                        else if (!Properties.Settings.Default.ShowOnlyFTMS)/// || !(MainPointProvider is RMSProvider))
                        {
                            CurrentSpectrum.SortByMZ();

                            min = CurrentSpectrum.MinBy(p => p.MZ).MZ;
                            max = CurrentSpectrum.MaxBy(p => p.MZ).MZ;

                            //if (MainPointProvider.ScanType(scans.First().ScanNumber) == "MS2")
                            //if (MainPointProvider.MsLevel(scans.First().ScanNumber) == SpecMsLevel.MSMS)
                            {
                                min = 0;

                                if (max <= CurrentSpectrum.ParentMass.Value)
                                    max = CurrentSpectrum.ParentMass.Value;

                            }

                            if (CurrentSpectrum.ParentIon != null)
                            {
                                if (max <= CurrentSpectrum.ParentIon.MonoMass)
                                    max = CurrentSpectrum.ParentIon.MonoMass;
                            }

                            min = min - (max - min) * 0.035;  // This gives us a buffer on the ends of the X axis
                            max = max + (max - min) * 0.035;  // This gives us a buffer on the ends of the X axis
                            Dispatcher.Invoke(new Action(() =>
                            {
                                CurrentSpectrum.Add(new ClusterPeak() { MZ = min, Intensity = 0 });
                                CurrentSpectrum.Add(new ClusterPeak() { MZ = max, Intensity = 0 });

                                BottomChart.AxesX[0].AxisMinimum = min;
                                BottomChart.AxesX[0].AxisMaximum = max;

                                BottomChart.Series[7].DataSource = CurrentSpectrum.Range(min, max, (int)BottomChart.AxesX[0].ActualWidth * (Properties.Settings.Default.HighBin ? 2 : 1));
                                BottomChart.Series[0].DataPoints.Clear();

                                BottomChart.AxesX[0].Zoom(min, max, min, max);

                                BottomChart.AxesX[0].AxisMinimum = min;
                                BottomChart.AxesX[0].AxisMaximum = max;

                                BottomChart.AxesX[0].Title = "m/z (amu)";
                            }));
                        }
                    }
                    else
                    {
                        BottomChart.AxesX[0].AxisMinimum = 0d;
                        BottomChart.AxesX[0].AxisMaximum = 1d;
                    }
                    Dispatcher.Invoke(new Action(() =>
                    {
                        TIC_Chart.IsEnabled = true;
                        BPI_Chart.IsEnabled = true;
                        BPM_Chart.IsEnabled = true;
                        XIC_Chart.IsEnabled = true;

                        BottomChart.IsEnabled = true;

                        //btnNext.IsEnabled = true;
                        //btnPrevious.IsEnabled = true;
                        //txtScanNum.IsEnabled = true;

                        BottomChart.Titles[0].Text = CurrentSpectrum.Title;
                        BottomChart.Visibility = Visibility.Visible;

                        //btnFindAA.IsEnabled = CurrentSpectrum.ParentIon != null || CurrentSpectrum.Title.ToLower().Contains("ms2");  // enable Find Sequence Tags button only when we have an MS2 scan loaded!

                        dtgridsequences.Visibility = System.Windows.Visibility.Collapsed;
                        ClearSequenceMatch();
                        txtMatchSequence.IsEnabled = false;
                        btnMatch.IsEnabled = false;
                    }));
                    if (!fromautoscan)
                    {
                        btnFindAA.Visibility = System.Windows.Visibility.Visible;
                    }

                    monosfound = false;

                    SetScaling();
                }
            }
            finally
            {
                //Work around for bug in chart control where peaks don't show up.
                //Zooming seems to fix it.
                //if (CurrentSpectrum.ParentMass != null && fromvalidateautoscan)
                //{
                //    Dispatcher.Invoke(new Action(() =>
                //    {
                //        X1_OnZoom(X1, -10, (CurrentSpectrum.ParentMass.Value + 10));
                //    }));
                //}
                busyTic.IsBusy = false;
                if (fromautoscan)
                {
                    btnFindAA.RaiseEvent(new RoutedEventArgs(Button.ClickEvent));
                }

                if (fromautovalidate)
                {
                    btnShowBions_Click(null, null);
                    btnShowYions_Click(null, null);
                }

                fromautovalidate = false;
                if (!fromautoscan && !fromvalidateautoscan)
                {
                    Dispatcher.Invoke(new Action(() =>
                    {
                        ClearMonos_Click(null, null);
                        ClearAminoAcids_Click();
                        ClearRed_Click();
                        AmmoniaLossSeries.DataPoints.Clear();
                        MonoMassesfordbSequence.Visibility = System.Windows.Visibility.Hidden;
                        dtgridsequences.DataContext = null;
                        dtgridsequences.Visibility = System.Windows.Visibility.Collapsed;
                        ClearSequenceMatch();
                        txtMatchSequence.IsEnabled = false;
                        btnMatch.IsEnabled = false;
                        btnFindAA.Visibility = System.Windows.Visibility.Visible;
                        MonoMassesfordbSequence.DataSource = null;
                        txtSearchbox.Text = string.Empty;

                    }));

                }
                if (fromvalidateautoscan)
                {
                    this.busySpectrum.IsBusy = false;
                    fromvalidateautoscan = false;
                }

                //if (fromautoscan)
                //{
                //    btnFindAA.RaiseEvent(new RoutedEventArgs(Button.ClickEvent));
                //}

                //TODO: is this necessary?  
                Dispatcher.Invoke(new Action(() =>
                {
                    this.BottomChart.AxesY[0].AxisMaximum = CurrentIons.MaxBy(a => a.Intensity).Intensity;
                }));
                //Properties.Settings.Default.MatchTolerancePPM = 5.0;
                //Properties.Settings.Default.MassTolerancePPM = 5.0;
            }
        }

        /// <summary>
        /// Display Spectrum in main chart
        /// </summary>
        /// <param name="value">Retention Time in minutes</param>
        internal void DisplayNewSpectrum(float value)
        {
            DisplayNewSpectrum(new Range() { Start = value, End = value });
        }

        internal void DisplayNewSpectrum(Range values, string filter = "", SpecMsLevel level = SpecMsLevel.All)
        {
            DisplayNewSpectrum(GetSpecList(values), filter, level);
        }

        public double ParentMass = 0.00;

        internal void DisplayNewSpectrum(IEnumerable<SpectrumInfo> scans, string filter = "", SpecMsLevel level = SpecMsLevel.All)
        {
            try
            {

                if (scans == null) return;  // nothing to plot!
                ClearFilters();
                CurrentIons.Clear(); //Clear all the Ions from the previous spectrum.
                sqsalldenovotgs.Clear(); //Clear all the sequence tags.

                // Apply the Filter
                if (!string.IsNullOrWhiteSpace(filter)) scans = scans.Where(s => s.Title.Contains(filter));

                if (level != SpecMsLevel.All) scans = scans.Where(s => s.MsLevel == level);
                btnSetManualParentMass.Visibility = System.Windows.Visibility.Hidden;
                if (!scans.Any()) return;  // nothing to plot! 
                List<int?> ParentZ = new List<int?>();
                List<string> ScanNumbers = new List<string>();
                List<string> activations = new List<string>();

                //TODO: Refactor this, especially the activation stuff!   

                Spectrum.ActivationOverride = Properties.Settings.Default.ActivationOverride;
                DechargerVM.ActivationType = string.Empty;
                App.CurrentScanActivationType = string.Empty;

                if (scans.All(s => s.MsLevel == SpecMsLevel.MSMS))  // if all the scans are MS2, handle the parent and activations....
                {
                    if (scans.Any(a => a.ParentIon == null))
                    {
                        int totalscanscount = scans.Count();
                        for (int i = 0; i < totalscanscount; i++)
                        {
                            var aScan = scans.ElementAt(i);

                            MainPointProvider.SetParentInfo(aScan, Properties.Settings.Default.PrecursorFromProductEnabled);

                            activations.Add(MainPointProvider.GetActivationType(aScan.ScanNumber));
                            DechargerVM.ActivationType += activations[activations.Count - 1];
                            App.CurrentScanActivationType += activations[activations.Count - 1];

                            ParentZ.Add(aScan.ParentZ);
                            ScanNumbers.Add(Convert.ToString(aScan.ScanNumber));

                            if (addparentmassfromMergeSpectra)
                            {
                                if (mgrspectra.Where(a => a.ScanNumber == aScan.ScanNumber).Any())
                                {
                                    var crntscan = mgrspectra.Where(a => a.ScanNumber == aScan.ScanNumber).First();
                                    if (crntscan.ParentIon != null)
                                    {
                                        scans.ElementAt(i).ParentIon = crntscan.ParentIon;
                                        scans.ElementAt(i).ParentMass = crntscan.ParentMass;
                                        CurrentSpectrum.ParentIon = crntscan.ParentIon;
                                        CurrentSpectrum.ParentMass = crntscan.ParentMass;
                                        //CurrentSpectrum.ParentCharge = crntscan.ParentZ;
                                        ParentZ = new List<int?>();
                                        ParentZ.Add(crntscan.ParentZ);
                                    }
                                }
                            }
                        }

                        //foreach (var aScan in scans.Where(s => s.ParentIon == null))
                        //{
                        //    MainPointProvider.SetParentInfo(aScan);
                        //    ParentZ.Add(aScan.ParentZ);
                        //    ScanNumbers.Add(Convert.ToString(aScan.ScanNumber));
                        //    if (addparentmassfromMergeSpectra)
                        //    {
                        //        if (mgrspectra.Where(a => a.ScanNumber == aScan.ScanNumber).Any())
                        //        {
                        //            var crntscan = mgrspectra.Where(a => a.ScanNumber == aScan.ScanNumber).First();
                        //            if (crntscan.ParentIon != null)
                        //            {
                        //                CurrentSpectrum.ParentIon = crntscan.ParentIon;
                        //                CurrentSpectrum.ParentMass = crntscan.ParentMass;
                        //                //CurrentSpectrum.ParentCharge = crntscan.ParentZ;
                        //                ParentZ = new List<int?>();
                        //                ParentZ.Add(crntscan.ParentZ);
                        //            }
                        //        }
                        //    }
                        //}
                    }
                    else
                    {
                        scans = scans.OrderBy(a => a.ScanNumber).ToList();

                        var scnss = scans.OrderBy(a => a.ScanNumber).ToList();

                        if (addparentmassfromMergeSpectra)
                        {
                            int totalscanscount = scans.Count();
                            for (int i = 0; i < totalscanscount; i++)
                            {
                                var aScan = scans.ElementAt(i);
                                activations.Add(MainPointProvider.GetActivationType(aScan.ScanNumber));
                                App.CurrentScanActivationType += activations[activations.Count - 1];
                                DechargerVM.ActivationType += activations[activations.Count - 1];
                                //activations.Add(aScan.Activation);
                                if (mgrspectra.Where(a => a.ScanNumber == aScan.ScanNumber).Any())
                                {
                                    var crntscan = mgrspectra.Where(a => a.ScanNumber == aScan.ScanNumber).First();
                                    if (crntscan.ParentIon != null)
                                    {
                                        scans.ElementAt(i).ParentIon = crntscan.ParentIon;
                                        scans.ElementAt(i).ParentMass = crntscan.ParentMass;
                                        CurrentSpectrum.ParentIon = crntscan.ParentIon;
                                        CurrentSpectrum.ParentMass = crntscan.ParentMass;
                                        //CurrentSpectrum.ParentCharge = crntscan.ParentZ;
                                        ParentZ = new List<int?>();
                                        ParentZ.Add(crntscan.ParentZ);
                                        //activations.Add(aScan.Activation);

                                    }
                                }
                            }

                            //foreach (var aScan in scnss.Where(s => s.ParentIon == null))
                            //{
                            //    if (mgrspectra.Where(a => a.ScanNumber == aScan.ScanNumber).Any())
                            //    {
                            //        var crntscan = mgrspectra.Where(a => a.ScanNumber == aScan.ScanNumber).First();
                            //        if (crntscan.ParentIon != null)
                            //        {
                            //            CurrentSpectrum.ParentIon = crntscan.ParentIon;
                            //            CurrentSpectrum.ParentMass = crntscan.ParentMass;
                            //            //CurrentSpectrum.ParentCharge = crntscan.ParentZ;
                            //            ParentZ = new List<int?>();
                            //            ParentZ.Add(crntscan.ParentZ);
                            //        }
                            //    }
                            //}
                        }

                        foreach (var aScan in scans)
                        {
                            ScanNumbers.Add(Convert.ToString(aScan.ScanNumber));
                            ParentZ.Add(aScan.ParentZ.Value);
                        }
                    }

                    App.ParentDetails = new clsParentInfo
                    {
                        ParentZ = ParentZ.Max(),
                        ScanNumber = string.Join(",", ScanNumbers)
                    };

                    currentparent.ParentZ = ParentZ.Max();
                    currentparent.ScanNumber = string.Join(",", ScanNumbers);

                    // why are we wiping out the activations here???
                    DechargerVM.ActivationType = string.Empty;
                    App.CurrentScanActivationType = string.Empty;

                    if (currentparent.ParentZ == null && currentparent.ScanNumber == "")
                    {
                        foreach (var aScan in scans)
                        {
                            MainPointProvider.SetParentInfo(aScan);
                            ParentZ.Add(aScan.ParentZ);
                            ScanNumbers.Add(Convert.ToString(aScan.ScanNumber));
                            CurrentSpectrum.ScanNumber = aScan.ScanNumber;
                            activations.Add(MainPointProvider.GetActivationType(aScan.ScanNumber));
                            //activations.Add(aScan.Activation);
                        }
                        DechargerVM.ActivationType += activations[activations.Count - 1];
                        App.CurrentScanActivationType += activations[activations.Count - 1];
                        currentparent.ParentZ = ParentZ.Max();
                        currentparent.ScanNumber = string.Join(",", ScanNumbers);

                    }
                }

                if (string.IsNullOrWhiteSpace(Properties.Settings.Default.ActivationOverride) == false)
                {
                    // override the activation
                    DechargerVM.ActivationType = Properties.Settings.Default.ActivationOverride;
                    App.CurrentScanActivationType = Properties.Settings.Default.ActivationOverride;
                }

                if (!fromvalidateautoscan)
                {
                    Dispatcher.Invoke(new Action(() =>
                    {
                        this.busyTic.IsBusy = true;
                        this.BusyProgressText = "Detecting Ions...";
                        btnFindAA.IsEnabled = false;
                    }));
                }
                else
                {
                    Dispatcher.Invoke(new Action(() =>
                        {
                            this.busySpectrum.IsBusy = true;
                            this.busySpectrum.BusyContent = "Detecting Ions...";
                        }));
                    RedMarkersSeries.DataPoints.Clear();
                    GreenMarkersSeries.DataPoints.Clear();
                    RedMarkersSeriesBright.DataPoints.Clear();
                    RedMarkersSeriesLite.DataPoints.Clear();
                    GreenMarkersSeriesBright.DataPoints.Clear();
                    GreenMarkersSeriesLite.DataPoints.Clear();
                }

                PopulateRedandGreenMarkers(null, false, false, true);
                lblExperimentalMass.Text = "";
                if (displaySpecWorker.IsBusy)
                {
                    Debug.Print("Cancelling old worker. " + displaySpecWorker.GetHashCode());
                    displaySpecWorker.CancelAsync();
                    SignalProcessor.CancelConsolidation = true;
                    //displaySpecWorker.RunWorkerCompleted += null;  // detaches all events?

                    //while (displaySpecWorker.IsBusy) Thread.Sleep(20);
                    Thread.Sleep(20);
                }

                displaySpecWorker = new BackgroundWorker() { WorkerSupportsCancellation = true };
                displaySpecWorker.RunWorkerCompleted += bwSpec_RunWorkerCompleted;

                displaySpecWorker.DoWork += (s, args) =>
                {
                    lock (lockObj)
                    {
                        Debug.Print("DoWork Start. " + s.GetHashCode());
                        var worker = s as BackgroundWorker;

                        float i = 0;

                        TempCurrentIons.Clear();
                        TempMergedIons.Clear();
                        CTerminusLine.DataPoints.Clear();
                        if (Properties.Settings.Default.ShowOnlyFTMS && MainPointProvider is RMSProvider && scans.Any(s1 => s1.Title.Contains("FTMS")))
                        {
                            scans = scans.Where(s2 => s2.Title.Contains("FTMS")).OrderBy(a => a.ScanNumber).ToList();
                        }
                        else if (Properties.Settings.Default.ShowOnlyFTMS && MainPointProvider is RMSProvider)
                        {
                            Debug.Print("Selection contains only non-FTMS scans, but we are only showing FTMS scans!  Exiting...");
                            return;
                        }


                        App.ScanNumber = string.Join(",", scans.Select(a => a.ScanNumber).ToArray());


                        if (Properties.Settings.Default.NativeAveragingEnabled == false) // || MainPointProvider.NativeScanSumSupported == false)
                        {
                            // Populate the collections with the decharged ions
                            foreach (var aScan in scans)
                            {
                                this.BusyProgressValue = (i++ / (float)scans.Count()) * 100;

                                if (worker.CancellationPending)
                                {
                                    break;
                                }

                                var minScore = (aScan.MsLevel == SpecMsLevel.MSMS) ? 100 : 300;


                                Dispatcher.Invoke(new Action(() =>
                                {
                                    if (aScan.MsLevel == SpecMsLevel.MSMS)
                                    {
                                        btnSetManualParentMass.Visibility = System.Windows.Visibility.Visible;
                                    }
                                }));
                                // Gather all the ions from all the scans
                                if (aScan.ParentZ.HasValue)
                                {


                                    TempMergedIons.AddRange(MainPointProvider.DetectIons(aScan.ScanNumber, 1, aScan.ParentZ.Value).Where(ion => ion.Score > minScore));  // only run charge detector up to Parent Charge
                                }
                                else
                                {
                                    TempMergedIons.AddRange(MainPointProvider.DetectIons(aScan.ScanNumber).Where(ion => ion.Score > minScore));
                                }
                            }
                        }
                        else
                        {
                            var nativeAveragedScan = MainPointProvider.NativeScanSum(scans.Select(x => x.ScanNumber).ToArray(), true);

                            var cd = new ChargeDetector(nativeAveragedScan);
                            var result = cd.DetectChargeStates(MainPointProvider.MassTolerance); //, minCharge, maxCharge, massRangeMin, massRangeMax);

                            TempMergedIons.AddRange(result);
                        }

                        if (!worker.CancellationPending)
                        {
                            // Now, consolidate all those ions where they are the same ion
                            TempCurrentIons = SignalProcessor.ConsolidateIons(TempMergedIons, true);
                            args.Result = scans;
                            Debug.Print("DoWork Complete.  " + s.GetHashCode());
                        }
                        else
                        {
                            args.Cancel = true;
                            args.Result = null;

                            Debug.Print("DoWork Cancelled.  " + s.GetHashCode());
                        }
                    }

                };
                displaySpecWorker.RunWorkerAsync();
            }
            catch (Exception ex)
            {
                App.Laststacktrace = ex.StackTrace;
                Action throwException = () => { throw ex; };
                Dispatcher.CurrentDispatcher.BeginInvoke(throwException);
            }
        }

        private void btnCancelmainpage_Click(object sender, RoutedEventArgs e)
        {
            busyTic.IsBusy = false;
            this.BusyProgressValue = 0;
            if (displaySpecWorker.IsBusy)
            {
                displaySpecWorker.CancelAsync();
            }
            if (bgDetectParents.IsBusy)
            {
                bgDetectParents.CancelAsync();
            }
        }


        float setdbmonointensity = new float();
        bool fromvalidateautoscan = false;
        string scannumbers = string.Empty;
        private void bwSpec_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            Debug.Print("RunWorkerCompleted.  " + sender.GetHashCode());

            if (e.Cancelled || (displaySpecWorker != null && sender.GetHashCode() != displaySpecWorker.GetHashCode()))
                return;

            try
            {
                if (e.Result is Exception)
                {
                    var ex = e.Result as Exception;
                    if (App.Log != null) App.Log.WriteEntry(ex.Message + " - " + ex.Source + "\n\n" + ex.StackTrace, EventLogEntryType.Error);
                    return;
                }

                if (e.Result == null || !(e.Result is IEnumerable<SpectrumInfo>)) return;

                Debug.Print("Worker displaying results.  " + sender.GetHashCode());

                lock (lockObj)
                {

                    var scans = e.Result as IEnumerable<SpectrumInfo>;

                    maxofpredictedvalues = 0.0;
                    var startTime = DateTime.Now.Ticks;
                    //App app = (App)Application.Current;

                    List<String> descr = new List<string>();
                    //bool mergespectra = false;

                    if (!fromvalidateautoscan)
                    {
                        ClearBYIons();
                    }

                    //if (addparentmassfromMergeSpectra)
                    //{

                    //}

                    //else 
                    //{
                    //    Dispatcher.Invoke(new Action(() =>
                    //    {
                    //        tbValidate.Focus();
                    //        dtgridBandYIons.Focus();
                    //    }));
                    //    fromvalidateautoscan = false;
                    //}
                    Dispatcher.Invoke(new Action(() =>
                       {
                           CurrentMonoMasses.Clear();
                           ReverseCurrentMonomasses.Clear();
                           MonoMassesfordbSequence.DataSource = null;
                           //CurrentIons.Clear();
                           //MergedIons.Clear();
                           MergeCurrentIons.Clear();
                           WaterLossSeries.DataPoints.Clear();
                           AmmoniaLossSeries.DataPoints.Clear();
                           CurrentSpectrum.Clear();
                           ReverseCurrentSpectrum.Clear();
                           ThermoPoint.Clear();
                           //parentmass = 0;
                           CurrentMode = ChartMode.Mass;
                           CurrentSpectrum.ParentIon = null;
                           //sequencemerge = false;
                           // Reset any Y-Axis scaling
                           this.BottomChart.AxesY[0].AxisMaximum = null;
                           zoomWidth = 0;
                           ParentMonoSeries.DataSource = null;
                           ZeroSeries.DataSource = null;

                           MonoMasslabel.DataPoints.Clear();
                       }));
                    CurrentIons = TempCurrentIons;
                    MergedIons = TempMergedIons;

                    foreach (var aCluster in CurrentIons)
                        CurrentSpectrum.AddRange(aCluster.Peaks); //.Where(p => p.MZ > aCluster.MonoMZ));



                    // Populate the Thermo data
                    //if (Properties.Settings.Default.ShowThermo && MainPointProvider is RMSProvider)
                    //{
                    //    foreach (var aScan in scans)
                    //    {
                    //        SpecPointCollection thermopoints = MainPointProvider.ThermoPoints(aScan.ScanNumber);

                    //        foreach (var thermo in thermopoints)
                    //        {
                    //            if (!(double.IsNaN(thermo.Mass)) && !(double.IsNaN(thermo.MZ)) && !(double.IsNaN(thermo.Intensity)))
                    //            {
                    //                ThermoPoint.Add(thermo);
                    //            }
                    //        }
                    //    }
                    //}

                    if (scans.Where(s => s.ParentIon != null).Any())
                    {
                        // We have at least 1 MS2 scan with a parent!
                        Dispatcher.Invoke(new Action(() =>
                        {
                            CurrentSpectrum.ParentIon = scans.Where(s => s.ParentMass == scans.Select(t => t.ParentMass).Median()).FirstOrDefault().ParentIon;
                            CurrentSpectrum.ParentIon.Description = "Parent Ion\nMass = " + CurrentSpectrum.ParentIon.MonoMass.ToString("0.0000");
                            ParentMass = CurrentSpectrum.ParentIon.MonoMass;
                            ParentMonoSeries.DataSource = new Cluster[] { CurrentSpectrum.ParentIon };
                            ZeroMonomass zm = new ZeroMonomass();
                            zm.Intensity = CurrentSpectrum.ParentIon.Intensity;
                            zm.MonoMass = 0;
                            ZeroSeries.DataSource = new ZeroMonomass[] { zm };
                            setdbmonointensity = CurrentSpectrum.ParentIon.Intensity;

                            if (string.IsNullOrWhiteSpace(Properties.Settings.Default.ActivationOverride))
                            {
                                var actList = new List<string>();

                                foreach (var aScan in scans)
                                    actList.Add(MainPointProvider.GetActivationType(aScan.ScanNumber).Trim().ToUpper());

                                CurrentSpectrum.Activation = string.Join(" ", actList);  // combine all activations

                            }
                            else
                            {
                                CurrentSpectrum.Activation = Properties.Settings.Default.ActivationOverride;

                            }

                            //update legacy global vars
                            DechargerVM.ActivationType = CurrentSpectrum.Activation;
                            App.CurrentScanActivationType = CurrentSpectrum.Activation;
                        }));
                    }



                    if (scans.Count() == 1)  // Single Scan
                    {
                        // Set the vertical line in the Chromatogram to mark the current spectrum
                        if (CurrentChromatogram != null)
                        {
                            // show marker for selected spectrum
                            CurrentChromatogram.TrendLines[1].Value = scans.First().RetentionTime;

                            CurrentChromatogram.TrendLines[1].Opacity = 1; // show vertical line marker
                            CurrentChromatogram.TrendLines[2].Opacity = 0; // hide range selection
                        }

                        if (addparentmassfromMergeSpectra)
                        {
                            var crntspc = mgrspectra.Where(a => a.ScanNumber == Convert.ToInt16(App.ScanNumber != null ? App.ScanNumber : "0")).Any() ? mgrspectra.Where(a => a.ScanNumber == Convert.ToInt16(App.ScanNumber != null ? App.ScanNumber : "0")).First() : new SpectrumInfo();
                            if (crntspc.MsLevel == SpecMsLevel.MSMS)
                            {
                                CurrentSpectrum.ParentIon = crntspc.ParentIon;
                                CurrentSpectrum.ParentMass = crntspc.ParentMass;
                            }
                        }

                        CurrentScanNumber = scans.First().ScanNumber;
                        CurrentSpectrum.ScanNumber = scans.First().ScanNumber;
                        scannumbers = Convert.ToString(scans.First().ScanNumber);
                        Dispatcher.Invoke(new Action(() =>
                          {
                              // set single spectrum title information
                              CurrentSpectrum.Title = MainPointProvider.Title(CurrentScanNumber.Value);
                              if (scans.First().ParentMass.HasValue)
                              {
                                  CurrentSpectrum.Title += " (" + scans.First().ParentMass.Value.ToString(MassValueFormat) + ") ";

                                  Dispatcher.Invoke(new Action(() =>
                                  {
                                      lblExperimentalMass.Text = Convert.ToString(scans.First().ParentMass.Value.ToString(MassValueFormat));
                                  }));
                                  //parentmass = Convert.ToDouble(scans.First().ParentMass.Value);
                              }
                              else if (addparentmassfromMergeSpectra)
                              {
                                  foreach (var aScan in scans)
                                  {
                                      var crntscan = mgrspectra.Where(a => a.ScanNumber == aScan.ScanNumber).First();
                                      if (crntscan.MsLevel == SpecMsLevel.MSMS)
                                      {
                                          CurrentSpectrum.ParentIon = crntscan.ParentIon;
                                          CurrentSpectrum.ParentMass = crntscan.ParentMass;
                                      }
                                      //CurrentSpectrum.ParentCharge = crntscan.ParentZ;
                                  }
                                  if (CurrentSpectrum.ParentIon != null)
                                  {
                                      ParentMonoSeries.DataSource = new Cluster[] { CurrentSpectrum.ParentIon };
                                      CurrentSpectrum.Title += " (" + CurrentSpectrum.ParentIon.MonoMass.ToString("0.000") + ") ";
                                      Dispatcher.Invoke(new Action(() =>
                                      {
                                          lblExperimentalMass.Text = Convert.ToString(CurrentSpectrum.ParentIon.MonoMass.ToString(MassValueFormat));
                                      }));
                                      ZeroMonomass zm = new ZeroMonomass();
                                      zm.Intensity = CurrentSpectrum.ParentIon.Intensity;
                                      zm.MonoMass = 0;
                                      ZeroSeries.DataSource = new ZeroMonomass[] { zm };
                                      setdbmonointensity = CurrentSpectrum.ParentIon.Intensity;
                                      //CurrentSpectrum.Title = "Consolidated MS2 Scans: " + string.Join(", ", scans.Select(s => s.ScanNumber)) + " (" + CurrentSpectrum.ParentIon.MonoMass.ToString("0.000") + ")";
                                  }
                                  else
                                  {
                                      BottomChart.Titles[1].Text = "Scan " + CurrentScanNumber.ToString() + ", " + MainPointProvider.Filename;
                                  }
                              }
                              BottomChart.Titles[1].Text = "Scan " + CurrentScanNumber.ToString() + ", " + MainPointProvider.Filename;
                          }));
                    }
                    else  // Multiple Scans
                    {
                        // set multiple scan title information
                        scans = scans.OrderBy(s => s.ScanNumber);

                        // Set the vertical line in the Chromatogram to mark the current spectrum
                        if (CurrentChromatogram != null)
                        {
                            // show marker for selected spectrum
                            CurrentChromatogram.TrendLines[2].StartValue = scans.First().RetentionTime;
                            CurrentChromatogram.TrendLines[2].EndValue = scans.Last().RetentionTime;

                            CurrentChromatogram.TrendLines[1].Opacity = 0; // hide vertical line marker
                            CurrentChromatogram.TrendLines[2].Opacity = 1; // show range selection
                        }

                        CurrentScanNumber = 0;
                        Dispatcher.Invoke(new Action(() =>
                          {
                              // set spectrum title information
                              if (scans.All(s => s.MsLevel == SpecMsLevel.MS))
                              {
                                  CurrentSpectrum.Title = "Sum of MS Scans for " + scans.First().RetentionTime.Value.ToString("0.000") + " to " + scans.Last().RetentionTime.Value.ToString("0.000") + " minutes";
                              }
                              else if (scans.All(s => s.MsLevel == SpecMsLevel.MSMS))
                              {
                                  if (CurrentSpectrum.ParentIon != null)
                                  {
                                      CurrentSpectrum.Title = "Consolidated MS2 Scans: " + string.Join(", ", scans.Select(s => s.ScanNumber)) + " (" + CurrentSpectrum.ParentIon.MonoMass.ToString("0.000") + ")";
                                      Dispatcher.Invoke(new Action(() =>
                                      {
                                          lblExperimentalMass.Text = scans.First().ParentMass.Value.ToString(MassValueFormat);
                                      }));
                                  }
                                  else
                                  {
                                      CurrentSpectrum.Title = "Consolidated MS2 Scans: " + string.Join(", ", scans.Select(s => s.ScanNumber)) + " (" + "No ParentMass Detected" + ")";
                                  }
                                  //parentmass = CurrentSpectrum.ParentIon.MonoMass;
                                  //CurrentParentMass = scans.Select(s => s.ParentMass).Median();
                              }
                              else
                              {
                                  CurrentSpectrum.Title = "Mix of MS1 and MS2 Scans: " + string.Join(", ", scans.Select(s => s.ScanNumber)); // +" (" + string.Join(", ", scans.Select(s => s.ParentMass.ToString())) + ")";
                                  //CurrentParentMass = scans.Select(s => s.ParentMass).Median();
                              }
                              scannumbers = string.Join(", ", scans.Select(s => s.ScanNumber));
                              BottomChart.Titles[1].Text = "Merged, " + MainPointProvider.Filename;
                          }));
                    }


                    //if (MainPointProvider is RMSProvider && (MainPointProvider as RMSProvider).ScanInfo(startIndex).ToUpper().StartsWith("FTMS"))
                    //        {
                    CurrentMode = ChartMode.Mass;


                    //foreach (var anIon in MergedIons)
                    //    if (anIon.Intensity > 9347 && anIon.Intensity < 9348)
                    //        Debug.Print("Suspect Ion");

                    // Decharged Mass Spectrum
                    Dispatcher.Invoke(new Action(() =>
                      {
                          txtScanNum.Text = (scans.Count() > 1) ? "Merged" : CurrentScanNumber.ToString();
                          //BottomChart.Series[0].DataPoints.Clear();
                          BottomChart.Series[0].DataSource = null;
                          //ThermoFischer.DataPoints.Clear();
                          ThermoFischer.DataSource = null;
                          BottomChart.Series[4].DataPoints.Clear();
                          BottomChart.Series[5].DataPoints.Clear();
                          AnnotationBars1.DataPoints.Clear();
                          AnnotationBars2.DataPoints.Clear();
                          AnnotationBars3.DataPoints.Clear();
                          GrayBarSeries.DataPoints.Clear();
                          RedBarSeries.DataPoints.Clear();
                          AnnotationBarsBlue.DataPoints.Clear();
                          ReverseSeries.DataPoints.Clear();
                      }));


                    int width = (int)BottomChart.AxesX[0].ActualWidth;

                    if (CurrentSpectrum.Count >= 1)  // some spectra could have no points
                    {
                        if (CurrentMode == ChartMode.Mass)
                        {
                            CurrentSpectrum.SortByMass();

                            double min = CurrentSpectrum.MinBy(p => p.Mass).Mass;
                            double max = sequencetagmass = CurrentSpectrum.ParentIon != null ? CurrentSpectrum.ParentIon.MonoMass : CurrentSpectrum.MaxBy(p => p.Mass).Mass;

                            //if (CurrentSpectrum.ParentIon
                            //if (MainPointProvider.ScanType(scans.First().ScanNumber) == "MS2")
                            if (MainPointProvider.MsLevel(scans.First().ScanNumber) == SpecMsLevel.MSMS)
                            {
                                min = 0;

                                if (max <= CurrentSpectrum.ParentMass)
                                    max = CurrentSpectrum.ParentMass.Value;
                            }

                            if (CurrentSpectrum.ParentIon != null)
                            {
                                if (max <= CurrentSpectrum.ParentMass)
                                    max = CurrentSpectrum.ParentMass.Value;
                            }

                            min = min - (max - min) * 0.035;  // This gives us a buffer on the ends of the X axis
                            max = max + (max - min) * 0.035;  // This gives us a buffer on the ends of the X axis
                            Dispatcher.Invoke(new Action(() =>
                      {
                          CurrentSpectrum.Add(new ClusterPeak() { Mass = min, Intensity = 0 });
                          CurrentSpectrum.Add(new ClusterPeak() { Mass = max, Intensity = 0 });

                          BottomChart.AxesX[0].AxisMinimum = min;
                          BottomChart.AxesX[0].AxisMaximum = max;

                          Debug.WriteLine("Point Count: " + CurrentSpectrum.Range(min, max, (int)BottomChart.AxesX[0].ActualWidth * (Properties.Settings.Default.HighBin ? 2 : 1)).Count());

                          //foreach (var item in collection)
                          //{
                          //    BottomChart.Series[0].DataPoints.Add()
                          //}

                          BottomChart.Series[0].DataSource = CurrentSpectrum.Range(min, max, (int)BottomChart.AxesX[0].ActualWidth * (Properties.Settings.Default.HighBin ? 2 : 1));



                          //if (MainPointProvider.ScanType(scans.First().ScanNumber) == "MS2" && CurrentSpectrum.ParentMass != null)
                          if (CurrentSpectrum.ParentIon != null)
                          {
                              var reverseions = (from d in CurrentSpectrum.Where(a => a.Mass <= CurrentSpectrum.ParentMass)
                                                 select new ClusterPeak
                                                 {
                                                     Parent = d.Parent,
                                                     Intensity = d.Intensity,
                                                     MZ = d.MZ,
                                                     //Z = d.Z,
                                                     Delta = d.Delta,
                                                     IsCorePeak = d.IsCorePeak,
                                                     Mass = CurrentSpectrum.ParentMass.Value - d.Mass
                                                 });
                              ReverseCurrentSpectrum = new Spectrum(reverseions);
                              ReverseSeries.DataSource = ReverseCurrentSpectrum.Range(min, max, (int)BottomChart.AxesX[0].ActualWidth * (Properties.Settings.Default.HighBin ? 2 : 1));
                          }

                          //if (mergespectra)
                          //{
                          //    var reverseions = (from d in CurrentSpectrum.Where(a => a.Mass <= CurrentSpectrum.ParentIon.MonoMass)
                          //                       select new ClusterPeak
                          //                       {
                          //                           Parent = d.Parent,
                          //                           Intensity = d.Intensity,
                          //                           MZ = d.MZ,
                          //                           //Z = d.Z,
                          //                           Delta = d.Delta,
                          //                           IsCorePeak = d.IsCorePeak,
                          //                           Mass = CurrentSpectrum.ParentIon.MonoMass - d.Mass
                          //                       });
                          //    ReverseCurrentSpectrum = new PeakList(reverseions);
                          //    ReverseSeries.DataSource = ReverseCurrentSpectrum.Range(min, max, (int)BottomChart.AxesX[0].ActualWidth * (Properties.Settings.Default.HighBin ? 2 : 1));
                          //    mergespectra = false;
                          //}

                          grdDirection.Visibility = ReverseSeries.DataPoints.Count() > 0 ? Visibility.Visible : Visibility.Hidden;

                          //if (Properties.Settings.Default.ShowThermo && MainPointProvider is RMSProvider)
                          //    ThermoFischer.DataSource = ThermoPoint;

                          BottomChart.Series[7].DataPoints.Clear();

                          BottomChart.AxesX[0].Zoom(min, max, min, max);

                          BottomChart.AxesX[0].AxisMinimum = min;
                          BottomChart.AxesX[0].AxisMaximum = max;

                          BottomChart.AxesX[0].Title = "Mass (amu)";
                      }));
                        }
                        else if (!Properties.Settings.Default.ShowOnlyFTMS || !(MainPointProvider is RMSProvider))
                        {
                            CurrentSpectrum.SortByMZ();

                            double min = CurrentSpectrum.MinBy(p => p.MZ).MZ;
                            double max = CurrentSpectrum.MaxBy(p => p.MZ).MZ;

                            //if (MainPointProvider.ScanType(scans.First().ScanNumber) == "MS2")
                            if (MainPointProvider.MsLevel(scans.First().ScanNumber) == SpecMsLevel.MSMS)
                            {
                                min = 0;

                                if (max <= CurrentSpectrum.ParentMass.Value)
                                    max = CurrentSpectrum.ParentMass.Value;

                            }

                            if (CurrentSpectrum.ParentIon != null)
                            {
                                if (max <= CurrentSpectrum.ParentIon.MonoMass)
                                    max = CurrentSpectrum.ParentIon.MonoMass;
                            }

                            min = min - (max - min) * 0.035;  // This gives us a buffer on the ends of the X axis
                            max = max + (max - min) * 0.035;  // This gives us a buffer on the ends of the X axis
                            Dispatcher.Invoke(new Action(() =>
                {
                    CurrentSpectrum.Add(new ClusterPeak() { MZ = min, Intensity = 0 });
                    CurrentSpectrum.Add(new ClusterPeak() { MZ = max, Intensity = 0 });

                    BottomChart.AxesX[0].AxisMinimum = min;
                    BottomChart.AxesX[0].AxisMaximum = max;

                    BottomChart.Series[7].DataSource = CurrentSpectrum.Range(min, max, (int)BottomChart.AxesX[0].ActualWidth * (Properties.Settings.Default.HighBin ? 2 : 1));
                    BottomChart.Series[0].DataPoints.Clear();

                    BottomChart.AxesX[0].Zoom(min, max, min, max);

                    BottomChart.AxesX[0].AxisMinimum = min;
                    BottomChart.AxesX[0].AxisMaximum = max;

                    BottomChart.AxesX[0].Title = "m/z (amu)";
                }));
                        }
                    }
                    else
                    {
                        BottomChart.AxesX[0].AxisMinimum = 0d;
                        BottomChart.AxesX[0].AxisMaximum = 1d;
                    }

                    TIC_Chart.IsEnabled = true;
                    BPI_Chart.IsEnabled = true;
                    BPM_Chart.IsEnabled = true;
                    XIC_Chart.IsEnabled = true;


                    BottomChart.Visibility = Visibility.Visible;
                    BottomChart.IsEnabled = true;
                    btnNext.IsEnabled = true;
                    btnPrevious.IsEnabled = true;
                    txtScanNum.IsEnabled = true;

                    BottomChart.Titles[0].Text = CurrentSpectrum.Title;

                    btnFindAA.IsEnabled = CurrentSpectrum.ParentIon != null || CurrentSpectrum.Title.ToLower().Contains("ms2");  // enable Find Sequence Tags button only when we have an MS2 scan loaded!

                    dtgridsequences.Visibility = System.Windows.Visibility.Collapsed;
                    ClearSequenceMatch();
                    txtMatchSequence.IsEnabled = false;
                    btnMatch.IsEnabled = false;
                    if (!fromautoscan)
                    {
                        btnFindAA.Visibility = System.Windows.Visibility.Visible;
                    }

                    monosfound = false;

                    SetScaling();
                }
            }
            finally
            {
                //Work around for bug in chart control where peaks don't show up.
                //Zooming seems to fix it.
                //if (CurrentSpectrum.ParentMass != null && fromvalidateautoscan)
                //{
                //    Dispatcher.Invoke(new Action(() =>
                //    {
                //        X1_OnZoom(X1, -10, (CurrentSpectrum.ParentMass.Value + 10));
                //    }));
                //}
                busyTic.IsBusy = false;
                if (fromautoscan)
                {
                    btnFindAA.RaiseEvent(new RoutedEventArgs(Button.ClickEvent));
                }
                if (fromautovalidate)
                {
                    btnShowBions_Click(null, null);
                    btnShowYions_Click(null, null);
                }
                fromautovalidate = false;
                if (!fromautoscan && !fromvalidateautoscan)
                {
                    Dispatcher.Invoke(new Action(() =>
                       {
                           ClearMonos_Click(null, null);
                           ClearAminoAcids_Click();
                           ClearRed_Click();
                           AmmoniaLossSeries.DataPoints.Clear();
                           MonoMassesfordbSequence.Visibility = System.Windows.Visibility.Hidden;
                           dtgridsequences.DataContext = null;
                           dtgridsequences.Visibility = System.Windows.Visibility.Collapsed;
                           ClearSequenceMatch();
                           txtMatchSequence.IsEnabled = false;
                           btnMatch.IsEnabled = false;
                           btnFindAA.Visibility = System.Windows.Visibility.Visible;
                           MonoMassesfordbSequence.DataSource = null;
                           txtSearchbox.Text = string.Empty;
                       }));

                }
                if (fromvalidateautoscan)
                {
                    this.busySpectrum.IsBusy = false;
                    fromvalidateautoscan = false;
                }

                //Work around for bug in chart control where peaks don't show up.
                this.ForceSpectrumRedraw();
            }
            //System.Diagnostics.Debug.WriteLine("DisplayNewSpectrum: Done - " + (double)(DateTime.Now.Ticks - startTime) / (double)TimeSpan.TicksPerSecond);
        }


        class ZeroMonomass
        {
            public double Intensity { get; set; }
            public double MonoMass { get; set; }
        }

        void SignalProcessor_OnProgressChange(float percent, string title)
        {
            Dispatcher.Invoke(new Action(() =>
            {
                //this.busyTic.IsBusy = true;
                this.BusyProgressValue = percent * 100;
                this.BusyProgressText = title;
                //Debug.Print("***********   " + (percent * 100).ToString("0") + " *************");
                //ticProgress.Maximum = 100;
                //ticProgress.Value = percent * 100;
            }));

        }

        // boiler-plate
        public event PropertyChangedEventHandler PropertyChanged;
        protected virtual void OnPropertyChanged(string propertyName)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null) handler(this, new PropertyChangedEventArgs(propertyName));
        }
        protected bool SetField<T>(ref T field, T value, string propertyName)
        {
            if (EqualityComparer<T>.Default.Equals(field, value)) return false;
            field = value;
            OnPropertyChanged(propertyName);
            return true;
        }


        private void ReverseIons(List<ClusterPeak> currentpeaklist, double ParentMass)
        {
            var reverseions = (from d in currentpeaklist
                               select new ClusterPeak
                               {
                                   Parent = d.Parent,
                                   Intensity = d.Intensity,
                                   MZ = d.MZ,
                                   //Z = d.Z,
                                   Delta = d.Delta,
                                   IsCorePeak = d.IsCorePeak,
                                   Mass = ParentMass - d.Mass
                               });

            ReverseSeries.DataSource = reverseions;
        }

        void PlotArea_MouseEnter(object sender, MouseEventArgs e)
        {
            // setting visibility didn't work, so used opacity: http://www.visifire.com/forums/index.php?showtopic=1612
            // ((sender as PlotArea).Tag as Chart).TrendLines[0].Opacity = 1;

            PlotWithFocus = (sender as PlotArea);
        }

        void PlotArea_MouseLeave(object sender, MouseEventArgs e)
        {
            // setting visibility didn't work, so used opacity: http://www.visifire.com/forums/index.php?showtopic=1612
            //((sender as PlotArea).Tag as Chart).TrendLines[0].Opacity = 0;

            if (PlotWithFocus == (sender as PlotArea)) PlotWithFocus = null;
        }

        void ChromPlotArea_MouseLeave(object sender, MouseEventArgs e)
        {
            // turn off the selection box when leaving the plot area
            //ShiftIsDown = false;
            //((sender as PlotArea).Tag as Chart).TrendLines[2].Opacity = 0;
            SelectingRange = false;
        }

        void PlotArea_MouseMove(object sender, PlotAreaMouseEventArgs e)
        {
            ((sender as PlotArea).Tag as Chart).TrendLines[0].Value = e.XValue;

            if (OffsetStart != double.NaN && ((sender as PlotArea).Tag as Chart).Name == "BottomChart")
            {
                var offset = (OffsetStart - (double)e.XValue);
                //LastSnappedXPosition = (double)e.XValue;
                var SnappedXPosition = (double)e.XValue;

                //Debug.Print("Offset = " + offset);

                if (Double.IsNaN(offset))
                {
                    lblOffset.Content = string.Empty;
                    return;
                }

                if (MassLookup == null)
                {
                    lblOffset.Content = offset;
                    return;
                }

                // Find Closest value in MassLookup with tolerance based on resolution!!

                //MassLookup[offset]

                var viewWidth = Math.Abs((double)((sender as PlotArea).Tag as Chart).AxesX[0].ViewMaximum - (double)((sender as PlotArea).Tag as Chart).AxesX[0].ViewMinimum);
                var pointsPerWidth = viewWidth / ((sender as PlotArea).Tag as Chart).AxesX[0].ActualWidth;
                var totalTolerance = PixelTolerance * pointsPerWidth;

                //var viewWidth = Math.Abs((double)((sender as PlotArea).Tag as Chart).AxesX[0].ViewMaximum - (double)((sender as PlotArea).Tag as Chart).AxesX[0].ViewMinimum);
                //var pointsPerWidth = viewWidth / ((sender as PlotArea).Tag as Chart).AxesX[0].ActualWidth;

                //var TotalTolerance = PixelTolerance * pointsPerWidth;

                // Find nearest/intense point? 
                if (CurrentMonoMasses != null && CurrentMonoMasses.Count > 0)
                {
                    var start = ((double)e.XValue) - totalTolerance * 3;
                    var end = ((double)e.XValue) + totalTolerance * 3;

                    // Find the closest monoMZ within the tolerance...
                    var candidates = CurrentMonoMasses.Where(p => (double)p.XValue > start && (double)p.XValue < end).OrderByDescending(s => Math.Abs((double)s.XValue - (double)e.XValue));
                    //CurrentSpectrum.GetKeyOfMaxYValueForXRange(start, end) ?? double.NaN;
                    if (candidates.Any())
                    {
                        // Update the offset to use a value snapped to the nearest MonoMZ

                        offset = OffsetStart - (double)candidates.First().XValue;
                        SnappedXPosition = (double)candidates.First().XValue;
                    }
                }

                //totalTolerance = (((Properties.Settings.Default.MassTolerancePPM / 1e6d) * (double)e.XValue));

                // TODO: Secondarily, snap to nearest peak!  

                // Search for Masses that match within our tolerance
                var matches = from m in (chkDipeptides.IsChecked.Value ? ComboMassLookup : MassLookup)
                              let difference = Math.Abs(m.Key - Math.Abs(offset))
                              where difference <= totalTolerance
                              orderby difference
                              select new { Name = m.Value, Delta = difference };

                SequenceDirectionRightToLeft = SnappedXPosition < OffsetStart;

                if (matches.Any())
                {
                    // We have a match, so update the lblOffset with a bold/green label
                    var bestMatch = matches.First();
                    lblOffset.Content = bestMatch.Name + " - " + bestMatch.Delta.ToString("0.0000");
                    lblOffset.FontWeight = FontWeights.Bold;

                    try
                    {
                        lblOffset.Foreground = ((((Properties.Settings.Default.MassTolerancePPM / 1e6d) * (double)e.XValue)) < bestMatch.Delta) ? new SolidColorBrush(Colors.Red) : new SolidColorBrush(Colors.Green);
                    }
                    catch { }

                    lastbar = new AnnotationBar()
                    {
                        Start = Math.Min(SnappedXPosition, OffsetStart),
                        End = Math.Max(SnappedXPosition, OffsetStart),
                        Name = bestMatch.Name
                    };

                }
                else
                {
                    lblOffset.Content = (-1 * offset).ToString("0.0000");
                    lblOffset.FontWeight = FontWeights.Normal;
                    lblOffset.Foreground = new SolidColorBrush(Colors.Black);

                    lastbar = new AnnotationBar()
                    {
                        Start = Math.Min(SnappedXPosition, OffsetStart),
                        End = Math.Max(SnappedXPosition, OffsetStart),
                        Name = Math.Abs(offset).ToString("#.000") + " amu"
                    };
                }
            }
        }

        void ChromPlotArea_MouseMove(object sender, PlotAreaMouseEventArgs e)
        {
            if (SelectingRange)
            {
                ((sender as PlotArea).Tag as Chart).TrendLines[2].Opacity = 1;
                ((sender as PlotArea).Tag as Chart).TrendLines[2].EndValue = e.XValue;
                //   ((sender as PlotArea).Tag as Chart).TrendLines[2].Opacity = 1;
            }
            else
            {
                //((sender as PlotArea).Tag as Chart).TrendLines[2].Opacity = 0;
            }

            if (SelectingQuantRange)
            {
                ((sender as PlotArea).Tag as Chart).TrendLines[3].Opacity = 1;
                ((sender as PlotArea).Tag as Chart).TrendLines[3].EndValue = e.XValue;
                //   ((sender as PlotArea).Tag as Chart).TrendLines[2].Opacity = 1;
            }
        }

        void Chrom_Cursor_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            if (MainPointProvider == null) return;

            var cursor = sender as TrendLine;

            ((sender as PlotArea).Tag as Chart).TrendLines[1].Value = cursor.Value;
        }

        private void btnBrowse_Click(object sender, RoutedEventArgs e)
        {

            string contents = string.Empty;

            OpenFileDialog odlg = new OpenFileDialog();

            odlg.Filter = "Supported Mass Spec Types|*.zms;*.raw;*.txt|Zipped Mass Spectra|*.zms|Thermo RAW files|*.raw|Text files|*.txt";

            odlg.Multiselect = false;

            if ((bool)odlg.ShowDialog())
            {
                if (System.IO.Path.GetExtension(odlg.FileName).ToLower() == ".zms")
                {
                    MainPointProvider = new ZMSProvider(File.OpenRead(odlg.FileName)) { MassTolerance = Properties.Settings.Default.MassTolerancePPM };
                }
                else if (System.IO.Path.GetExtension(odlg.FileName).ToLower() == ".raw")
                {
                    MainPointProvider = new RMSProvider(new FileInfo(odlg.FileName)) { MassTolerance = Properties.Settings.Default.MassTolerancePPM };
                }
                else
                {
                    MainPointProvider = new TextProvider(File.OpenRead(odlg.FileName)) { MassTolerance = Properties.Settings.Default.MassTolerancePPM };
                }

                InitCharts(MainPointProvider);
            }
        }

        private void InitCharts(IMSProvider x)
        {
            try
            {
                //System.Diagnostics.Debug.WriteLine("Time to bind: " + DateTime.Now.Subtract(start).TotalMilliseconds + " ms");
                //       

                //System.Diagnostics.Debug.WriteLine("Time to bind: " + DateTime.Now.Subtract(start).TotalMilliseconds + " ms");
                //BottomChart.Rendered += new EventHandler(chart_Rendered);
                Dispatcher.Invoke(new Action(() =>
                {

                    chkHideScansWithNoMass.IsEnabled = false;
                    chkHideScansWithNoMass.IsChecked = false;  // initially, the Mass values are all blank, so in order to see any rows, this should not be checked.  

                    this.busyIndicator.IsBusy = true;
                    this.busyIndicator.BusyContent = "Loading Data...";
                }));
                // Based on: http://stackoverflow.com/questions/4794851/why-does-my-silverlight-busyindicator-stay-invisible-after-setting-isbusy-true
                var bw = new BackgroundWorker();
                bw.DoWork += (s, args) =>
                {
                    Thread.Sleep(200);
                    //this.Dispatcher.Invoke(DispatcherPriority.Normal, (MyDelegate)
                    //   delegate () {

                    Dispatcher.Invoke((Action)(() =>
                        {

                            var xTic = x.TIC;

                            //Stuff that takes some time
                            TIC_Chart.Series[0].DataSource = xTic;
                            BPI_Chart.Series[0].DataSource = x.BPI;
                            BPM_Chart.Series[0].DataSource = x.BPM;
                            XIC_Chart.Series[0].DataSource = null;
                            //if (!PreviousXMLFileloaded)
                            //{
                            //this.dtgridSearchResults.ItemsSource = null;
                            //this.dtgridConfirmedSequences.ItemsSource = null;
                            //}
                            //this.dtgridSearchResultsDeNovo.ItemsSource = null;

                            txtStart.Text = "1";
                            txtEnd.Text = "*";


                            TIC_Chart.Titles.Clear();
                            BPI_Chart.Titles.Clear();
                            BPM_Chart.Titles.Clear();
                            XIC_Chart.Titles.Clear();

                            TIC_Chart.Titles.Add(new Title() { Text = x.Filename });
                            BPI_Chart.Titles.Add(new Title() { Text = x.Filename });
                            BPM_Chart.Titles.Add(new Title() { Text = x.Filename });
                            XIC_Chart.Titles.Add(new Title() { Text = x.Filename });

                            BottomChart.Titles[1].Text = x.Filename;
                            TIC_Chart.AxesX[0].AxisMinimum = x.TIC.MinKey; //xTic.MinKey;
                                                                           //TODO: this is a Kludgey fix.  The plot should just correctly handle 0 and 1 point situations without throwing exceptions!
                            TIC_Chart.AxesX[0].AxisMaximum = x.TIC.MaxKey != x.TIC.MinKey ? x.TIC.MaxKey : x.TIC.MaxKey + 1;/// xTic.MaxKey != xTic.MinKey ? xTic.MaxKey : xTic.MaxKey + 1;///x.TIC.MaxKey != x.TIC.MinKey ? x.TIC.MaxKey : x.TIC.MaxKey + 1;


                            CurrentMonoMasses.Clear();
                            MonoMassesfordbSequence.DataSource = null;
                            ReverseCurrentMonomasses.Clear();


                            DechargerVM.RetentionTime = x.RetentionTime(x.NextScan(0).Value);
                            DisplayNewSpectrum(x.RetentionTime(x.NextScan(0).Value));  // displays first scan, whatever the number

                            //DisplayNewSpectrum(x.RetentionTime(1));

                        }));
                };

                bw.RunWorkerCompleted += bw_RunWorkerCompleted;
                bw.RunWorkerAsync();
            }
            catch (Exception ex)
            {
                System.Windows.MessageBox.Show(this, "Error during initializing charts  Message:" + ex.Message + "\n Stack Trace: " + ex.StackTrace, "Failed to load the file into charts", MessageBoxButton.OK, MessageBoxImage.Exclamation);
            }
        }

        void bw_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            Dispatcher.Invoke(new Action(() =>
            {
                this.busyIndicator.IsBusy = false;
                dtgridsequences.Visibility = System.Windows.Visibility.Collapsed;
                ClearSequenceMatch();
                btnFindAA.Visibility = System.Windows.Visibility.Visible;
                btnMatch.IsEnabled = false;
                txtMatchSequence.IsEnabled = false;
            }));

            BackgroundWorker bgw = new BackgroundWorker();
            bgw.DoWork += bgw_DoWork;

            bgw.RunWorkerAsync();
        }

        void bgw_DoWork(object sender, DoWorkEventArgs e)
        {
            Dispatcher.Invoke(new Action(() =>
            {
                float maxIntensity = 0;

                mgrspectra.Clear();

                foreach (SpectrumInfo mgs in MainPointProvider.GetInitialParentInfo())
                {
                    maxIntensity = Math.Max(maxIntensity, mgs.RelativeIntensity);

                    mgrspectra.Add(new SpectrumInfo
                    {
                        TimeSort = mgs.ScanNumber, // initially just sort by scan number
                        ScanNumber = mgs.ScanNumber,
                        Title = mgs.Title,
                        RetentionTime = mgs.RetentionTime,
                        ParentIon = null,
                        Intensity = mgs.Intensity,
                        RelativeIntensity = mgs.RelativeIntensity,
                        MsLevel = mgs.MsLevel
                    });
                }

                chkHideScansWithNoMass_CheckChanged(null, null);
                //foreach (var aSpec in mgrspectra) aSpec.RelativeIntensity =  aSpec.Intensity / maxIntensity;

                Debug.Print("Done");

            }));
        }

        private void button1_Click_1(object sender, RoutedEventArgs e)
        {
            BottomChart.Series[0].DataPoints.Clear();
        }

        private void btnNext_Click(object sender, RoutedEventArgs e)
        {
            if (!btnNext.IsEnabled) return;
            if (CurrentScanNumber.HasValue == false) return;

            var NextScanID = MainPointProvider.NextScan(CurrentScanNumber.Value);


            if (NextScanID.HasValue)
            {
                App.ScanNumber = Convert.ToString(CurrentScanNumber);

                //CurrentScanNumber = NextScanID.Value;
                var rt = MainPointProvider.RetentionTime(NextScanID.Value);


                DisplayNewSpectrum(rt);
                //btnFindAA.Visibility = System.Windows.Visibility.Visible;
                //dtgridsequences.Visibility = System.Windows.Visibility.Collapsed;
                //                DisplayNewSpectrum(CurrentScanNumber, CurrentScanNumber, string.Empty);

                //txtScanNum.Text = NextScanID.Value.ToString();
                //bindToChart();
            }
        }

        private void btnPrevious_Click(object sender, RoutedEventArgs e)
        {
            if (btnPrevious.IsEnabled == false) return;
            if (CurrentScanNumber.HasValue == false) return;

            var PreviousScanID = MainPointProvider.PreviousScan(CurrentScanNumber.Value);

            if (PreviousScanID.HasValue)
            {
                App.ScanNumber = Convert.ToString(CurrentScanNumber);

                //CurrentScanNumber = PreviousScanID.Value;
                var rt = MainPointProvider.RetentionTime(PreviousScanID.Value);
                DisplayNewSpectrum(rt);
                //dtgridsequences.Visibility = System.Windows.Visibility.Collapsed;
                //btnFindAA.Visibility = System.Windows.Visibility.Visible;
                //DisplayNewSpectrum(CurrentScanNumber, CurrentScanNumber, string.Empty);

                //txtScanNum.Text = PreviousScanID.Value.ToString();
                //bindToChart();
            }
        }

        private void txtScanNum_TextInput(object sender, TextCompositionEventArgs e)
        {
            int result = 0;

            if (int.TryParse(txtScanNum.Text, out result))
            {
                if (MainPointProvider.Contains(result))
                {
                    CurrentScanNumber = result;

                    var rt = MainPointProvider.RetentionTime(result);

                    DisplayNewSpectrum(rt);
                    //dtgridsequences.Visibility = System.Windows.Visibility.Collapsed;
                    //btnFindAA.Visibility = System.Windows.Visibility.Visible;
                }
                else
                {
                    System.Windows.MessageBox.Show("Not a valid Scan Number for this file.  ");
                }
            }
            else
            {
                System.Windows.MessageBox.Show("Scan Number must be an integer number.  ");
            }

            Debug.WriteLine("TI");
        }

        //private void chkLabels_StateChanged(object sender, RoutedEventArgs e)
        //{
        //    BottomChart.Series[0].LabelEnabled = chkLabels.IsChecked.Value;
        //}

        void ShowBIonsFaint(List<DataPoint> bions)
        {
            for (int i = 0; i < bions.Count; i++)
            {
                RedMarkersSeriesLite.DataPoints.Add(bions[i]);
            }
        }

        void ShowYIonsFaint(List<DataPoint> yions)
        {
            for (int i = 0; i < yions.Count; i++)
            {
                GreenMarkersSeriesLite.DataPoints.Add(yions[i]);
            }
        }

        void ShowBIonsBright(List<DataPoint> bions)
        {
            for (int i = 0; i < bions.Count; i++)
            {
                RedMarkersSeriesBright.DataPoints.Add(bions[i]);
            }
        }

        void ShowYIonsBright(List<DataPoint> yions)
        {
            for (int i = 0; i < yions.Count; i++)
            {
                GreenMarkersSeriesBright.DataPoints.Add(yions[i]);
            }
        }


        private void btnApply_Click(object sender, RoutedEventArgs e)
        {
            //BottomMarkerPoints

            RedMarkersSeries.DataPoints.Clear();
            RedMarkersSeriesBright.DataPoints.Clear();
            RedMarkersSeriesLite.DataPoints.Clear();
            //RedMarkersSeries.MaxForY = true;

            //var result = from m in txtMarkers.Text.Split(new char[] { ',', '\t', '\n', '\r' }, StringSplitOptions.RemoveEmptyEntries)
            //             select new DataPoint { XValue = double.Parse(m), YValue = (double)BottomChart.AxesY[0].ActualAxisMaximum };

            var result = from m in txtMarkers.Text.Split(new char[] { ',', '\t', '\n', '\r' }, StringSplitOptions.RemoveEmptyEntries)
                         select new DataPoint { XValue = m.TolerantDoubleParse(), YValue = 0, ToolTipText = "Marker = " + m };

            Regex regex = new Regex("^[a-zA-Z]");

            foreach (var aPoint in result)
            {
                if (regex.Match(aPoint.ToolTipText.Substring(9, aPoint.ToolTipText.Length - 9)).Success)
                {
                    System.Windows.MessageBox.Show("Enter one numeric value followed by a comment per line", "Wrong Format", MessageBoxButton.OK, MessageBoxImage.Information);
                    return;
                }
                //if (aPoint.ToolTipText)
                else if (aPoint.AxisXLabel != "Element Owner")
                {
                    RedMarkersSeries.DataPoints.Add(aPoint);
                }
            }
            RedMarkersSeries.Opacity = (RedMarkersSeries.DataPoints.Count > 0) ? 0.45 : 0;
        }

        private void btnApply2_Click(object sender, RoutedEventArgs e)
        {
            GreenMarkersSeries.DataPoints.Clear();
            GreenMarkersSeriesBright.DataPoints.Clear();
            GreenMarkersSeriesLite.DataPoints.Clear();
            //GreenMarkersSeries.MaxForY = true;

            var result = from m in txtMarkers2.Text.Split(new char[] { ',', '\t', '\n', '\r' }, StringSplitOptions.RemoveEmptyEntries)
                         select new DataPoint { XValue = m.TolerantDoubleParse(), YValue = 0, ToolTipText = "Marker = " + m };

            Regex regex = new Regex("^[a-zA-Z]");

            foreach (var aPoint in result)
            {
                if (regex.Match(aPoint.ToolTipText.Substring(9, aPoint.ToolTipText.Length - 9)).Success)
                {
                    System.Windows.MessageBox.Show("Enter one numeric value followed by a comment per line", "Wrong Format", MessageBoxButton.OK, MessageBoxImage.Information);
                    return;
                }
                else if (aPoint.AxisXLabel != "Element Owner")
                {
                    GreenMarkersSeries.DataPoints.Add(aPoint);
                }
            }
            GreenMarkersSeries.Opacity = (GreenMarkersSeries.DataPoints.Count > 0) ? 0.45 : 0;
        }

        private void LayoutRoot_KeyUp(object sender, KeyEventArgs e)
        {
            if (e.Key == Key.Left) btnPrevious_Click(null, null);
            if (e.Key == Key.Right) btnNext_Click(null, null);

            // Since the plot area events are not working, we'll just raise the events directly here
            //if (PlotWithFocus != null) PlotArea_KeyUp(PlotWithFocus, e); 

            //if (e.Key == Key.LeftShift || e.Key == Key.RightShift)
            //{
            //    ShiftIsDown = false;
            //    //((sender as PlotArea).Tag as Chart).TrendLines[2].Opacity = 0;
            //}

            e.Handled = true;
        }

        private void LayoutRoot_KeyDown(object sender, KeyEventArgs e)
        {
            // Since the plot area events are not working, we'll just raise the events directly here
            //if (PlotWithFocus != null) PlotArea_KeyDown(PlotWithFocus, e); 

            //if (e.Key == Key.LeftShift || e.Key == Key.RightShift)
            //{
            //    ShiftIsDown = true;
            //    //    ((sender as PlotArea).Tag as Chart).TrendLines[2].Opacity = 1;
            //}

            e.Handled = true;
        }



        void X1_OnZoom(object sender, double zoomMin, double zoomMax)
        {
            try
            {
                if (CurrentSpectrum.Count < 2) return;

                //var scan = x.MassScans(CurrentScanNumber);
                var axis = sender as Visifire.Charts.Axis;

                //double zoomMin = (double)e.MinValue;
                //double zoomMax = (double)e.MaxValue;
                //BottomChart.AxesX.
                zoom(axis, zoomMin, zoomMax);
            }
            catch (Exception ex)
            {
                App.Laststacktrace = ex.StackTrace;
                Action throwException = () => { throw ex; };
                Dispatcher.CurrentDispatcher.BeginInvoke(throwException);
            }
        }


        private void X1_OnZoom(object sender, AxisZoomEventArgs e)
        {
            try
            {
                if (CurrentSpectrum.Count < 2) return;

                //var scan = x.MassScans(CurrentScanNumber);
                var axis = sender as Visifire.Charts.Axis;

                double zoomMin = (double)e.MinValue;
                double zoomMax = (double)e.MaxValue;
                //BottomChart.AxesX.
                zoom(axis, zoomMin, zoomMax);
            }
            catch (Exception ex)
            {
                App.Laststacktrace = ex.StackTrace;
                Action throwException = () => { throw ex; };
                Dispatcher.CurrentDispatcher.BeginInvoke(throwException);
            }
        }

        private void zoom(Visifire.Charts.Axis axis, double start, double end)
        {
            double zoomMin = start;
            double zoomMax = end;

            // Calculate Axis range
            var range = Math.Abs(zoomMax - zoomMin);

            if (range < 0.007) return;  // the chart control seems to lock up with ranges smaller than this!  

            //XValueFormatString="#0.0000"

            if (range < 0.001)
                axis.ValueFormatString = "0.0000";
            if (range < 0.01)
                axis.ValueFormatString = "0.0000";
            else if (range < 0.1)
                axis.ValueFormatString = "0.000";
            else if (range < 1)
                axis.ValueFormatString = "0.00";
            else if (range < 10)
                axis.ValueFormatString = "0.0";
            else if (range < 100)
                axis.ValueFormatString = "0";
            else
                axis.ValueFormatString = "00";


            IEnumerable<ClusterPeak> zoomView = null;

            var axisMax = Math.Min(zoomMax + (range * 2), CurrentSpectrum.MaxBy(p => p.Mass).Mass);
            var axisMin = Math.Max(zoomMin - (range * 2), CurrentSpectrum.MinBy(p => p.Mass).Mass);

            if (CurrentSpectrum.IsSortedByMass)
            {
                zoomView = CurrentSpectrum.Where(p => p.Mass > zoomMin && p.Mass < zoomMax);
            }
            else
            {
                axisMax = Math.Min(zoomMax + (range * 2), CurrentSpectrum.MaxBy(p => p.MZ).MZ);
                axisMin = Math.Max(zoomMin - (range * 2), CurrentSpectrum.MinBy(p => p.MZ).MZ);
                zoomView = CurrentSpectrum.Where(p => p.MZ > zoomMin && p.MZ < zoomMax);
            }

            int minPeakHeight = Properties.Settings.Default.MinPeak;  // Number of pixels per peak (higher number yields better performance on noisy data)

            float intensityThreshold = 0;

            if (zoomView.Count() > 500)
                intensityThreshold = ((float)minPeakHeight / (float)BottomChart.AxesY[0].ActualHeight) * zoomView.Max(p => p.Intensity);

            this.BottomChart.Series[0].DataSource = CurrentSpectrum.Range(axisMin, axisMax, (int)BottomChart.AxesX[0].ActualWidth * (Properties.Settings.Default.HighBin ? 2 : 1), intensityThreshold);
            ReverseSeries.DataSource = ReverseCurrentSpectrum.Range(axisMin, axisMax, (int)BottomChart.AxesX[0].ActualWidth * (Properties.Settings.Default.HighBin ? 2 : 1), intensityThreshold);


            //System.Diagnostics.Debug.WriteLine("Point comparison = " + (this.BottomChart.Series[0].DataSource as IEnumerable<KeyValuePair<double, float>>).Count().ToString() + " v. " + CurrentSpectrum.Range(axisMin, axisMax, (int)BottomChart.AxesX[0].ActualWidth * ((bool)IsolatedStorageSettings.ApplicationSettings["HighBin"] ? 2 : 1)).Count().ToString());

            BottomChart.Series[3].LabelEnabled = Properties.Settings.Default.BinnedLabels;

            if (Properties.Settings.Default.BinnedLabels)
            {
                var labelDensity = 7;
                this.BottomChart.Series[3].DataSource = CurrentSpectrum.Range(axisMin, axisMax, (int)(BottomChart.AxesX[0].ActualWidth / labelDensity));
            }
            else
            {
                this.BottomChart.Series[3].DataSource = null;
            }



            axis.Zoom(zoomMin, zoomMax, axisMin, axisMax);

            zoomWidth = zoomMax - zoomMin;

            if (setscale == scaleby.Primary)
            {
                float YMax = Math.Max(1, CurrentSpectrum.GetMaxYValueForXRange(zoomMin, zoomMax));
                YMax = Math.Max(YMax, ReverseCurrentSpectrum.GetMaxYValueForXRange(zoomMin, zoomMax));

                if (YMax == 1)
                {
                    YMax = Math.Max(YMax, CurrentSpectrum.GetMaxYValueForXRange(axisMin, axisMax));
                    YMax = Math.Max(YMax, ReverseCurrentSpectrum.GetMaxYValueForXRange(axisMin, axisMax));
                }

                this.BottomChart.AxesY[0].AxisMaximum = YMax;
            }
            else
            {
                SetScaling();
            }
        }

        //private void TIC_Chart_Rendered(object sender, EventArgs e)
        //{

        //}

        //private void PlotArea_LostMouseCapture(object sender, MouseEventArgs e)
        //{

        //}

        //private void imgSave_MouseLeftButtonUp(object sender, MouseButtonEventArgs e)
        //{

        //    SaveWorkspace_Click();
        //}

        //private void imgConfig_MouseLeftButtonUp(object sender, MouseButtonEventArgs e)
        //{
        //    var cw = new ConfigPage();

        //    cw.Closed += cw_Closed;

        //    cw.Owner = this;

        //    cw.ShowDialog();
        //}


        private void cw_Closed(object sender, EventArgs e)
        {
            var ch1 = (ConfigPage)sender;
            bool? opt = ch1.DialogResult;

            if (App.SaveorNot)
            {
                // OK was clicked
                ApplySettings();
            }
        }

        double totalbandyionpercent = 0;

        private void ApplySettings()
        {
            BottomChart.Series[0].LabelEnabled = Properties.Settings.Default.Labels;
            BottomChart.Series[0].ToolTipText = Properties.Settings.Default.ShowMassTips ? "#XValue" : null;

            //if (Properties.Settings.Default.ShowThermo && MainPointProvider is RMSProvider)
            //{
            //    ThermoSlider.Visibility = System.Windows.Visibility.Visible;
            //    lblAlternateCD.Visibility = System.Windows.Visibility.Visible;
            //}
            //else
            //{
                ThermoSlider.Visibility = System.Windows.Visibility.Collapsed;
                lblAlternateCD.Visibility = System.Windows.Visibility.Collapsed;
            //}

            Spectrum.ActivationOverride = Properties.Settings.Default.ActivationOverride;

            if (Properties.Settings.Default.PPMErrorPlot)
            {
                xaxisErrorPlot.Title = "Error (PPM)";

                if (txtValidateSequenceWithSpectrum != null && txtValidateSequenceWithSpectrum.Text != null && txtValidateSequenceWithSpectrum.Text != "")
                {
                    Dictionary<double, double> crntmnmonomasses = new Dictionary<double, double>();
                    if (CurrentMonoMasses.Count == 0)
                    {
                        FindMonos();
                    }
                    for (int i = 0; i < CurrentMonoMasses.Count; i++)
                    {
                        if (!crntmnmonomasses.ContainsKey(Convert.ToDouble(CurrentMonoMasses[i].XValue)))
                        {
                            crntmnmonomasses.Add(Convert.ToDouble(CurrentMonoMasses[i].XValue), CurrentMonoMasses[i].YValue);
                        }
                    }


                    var allbandyions = CalculateBYCZIons.CalculateBYCZIon(txtValidateSequenceWithSpectrum.Text, CurrentMonos.Select(a => a.XValue).ToList(), ParentMass, CurrentSpectrum.Activation, App.AllValidationModifications, Properties.Settings.Default.MatchTolerancePPM, AminoAcidHelpers.AminoAcids, false, crntmnmonomasses);

                    dtgridBandYIons.ItemsSource = allbandyions;

                    //dtgridBandYIons.ItemsSource = CalculateBandYIons.CalculateBandYIon(txtValidateSequenceWithSpectrum.Text, CurrentMonos.Select(a => a.XValue).ToList(), ParentMass, App.AllValidationModifications, Properties.Settings.Default.MatchTolerancePPM, AminoAcidHelpers.AminoAcidMass3, false, crntmnmonomasses);

                    double bandhionscount = allbandyions.Where(a => a.yioncolor || a.bioncolor).Count();

                    double bandyions_percent = Math.Round((bandhionscount / allbandyions.Count) * 100, 2);
                    totalbandyionpercent = bandyions_percent;
                    double bions_percent = Math.Round(((double)allbandyions.Where(a => a.bioncolor).Count() / allbandyions.Count) * 100, 2);
                    double yions_percent = Math.Round(((double)allbandyions.Where(a => a.yioncolor).Count() / allbandyions.Count) * 100, 2);

                    lblbandyionspercent.Content = "Coverage = " + bandyions_percent + "%    B Ions = " + bions_percent + "%    Y Ions = " + yions_percent + "%";
                    lblbandyionpercentagehidden.Content = bandyions_percent;
                }

                if (txtValidateSequenceWithSpectrum.Text != null && txtValidateSequenceWithSpectrum.Text != "" && shouldshowmaxppmerrorofbandyions)
                {
                    //Properties.Settings.Default.PPMErrorAxisMax = maxppmerrorofbandyions;
                    //Properties.Settings.Default.PPMErrorAxisMin = -maxppmerrorofbandyions;
                    shouldshowmaxppmerrorofbandyions = false;
                }
            }
            else ///if (Properties.Settings.Default.DaltonErrorPlot)
            {
                xaxisErrorPlot.Title = "Error (AMU)";
            }

            App.SaveorNot = false;
        }

        double maxppmerrorofbandyions = 0;

        bool shouldshowmaxppmerrorofbandyions = false;

        void CalculateIons(string Sequence, List<double> Monomasses, double ParentMass, List<ModificationList> AllValidationModifications = null, double MatchTolerance = 0.00, SortedList<char, double> aa = null, bool isauto = false, Dictionary<double, double> CurrentMonomasses = null)
        {

        }


        void ApplyMatchList()
        {
            try
            {
                MassLookup = (from m in txtMolecules.Text.Split(new char[] { '\n', '\r' }, StringSplitOptions.RemoveEmptyEntries)
                              where m.Split(new char[] { '\t', '\\', '\'', ' ' }, StringSplitOptions.RemoveEmptyEntries).Count() >= 2
                              select new { Key = m.Split(new char[] { '\t', '\\', '\'', ' ' }, StringSplitOptions.RemoveEmptyEntries)[1], Value = m.Split(new char[] { '\t', ' ' }, StringSplitOptions.RemoveEmptyEntries)[0] }).ToDictionary(k => double.Parse(k.Key), v => v.Value);

                MassLookup.Add(0, string.Empty);

                AminoAcidMass2.Clear();
                AminoAcids.Clear();
                ModifiedAminoAcids.Clear();
                ModifiedAminoAcidStrings.Clear();

                string[] splitstring = { "\n", "\r" };
                string[] splitstringmass = { "\t", " " };
                string[] Masses = { };

                Masses = txtMolecules.Text.Split(splitstring, StringSplitOptions.RemoveEmptyEntries);

                foreach (var mass in Masses.Where(mm => !mm.StartsWith("//")))
                {
                    string[] splitmasses = mass.Split(splitstringmass, StringSplitOptions.RemoveEmptyEntries);

                    if (AminoAcidMass2.ContainsKey(splitmasses[0])) continue;  // duplicate entry

                    AminoAcidMass2.Add(splitmasses[0], Convert.ToDouble(splitmasses[1]));
                    if (splitmasses[0].Length > 1)
                    {
                        if (!ModifiedAminoAcids.ContainsKey(splitmasses[0]))
                            ModifiedAminoAcids.Add(splitmasses[0], Convert.ToDouble(splitmasses[1]));

                        if (!ModifiedAminoAcidStrings.ContainsKey(Convert.ToString(splitmasses[0][0])))
                            ModifiedAminoAcidStrings.Add(Convert.ToString(splitmasses[0][0]), splitmasses[0]);

                        if (!ModifiedAminoAcids.ContainsKey(Convert.ToString(splitmasses[0][0])))
                        {
                            ModifiedAminoAcids.Add(Convert.ToString(splitmasses[0][0]), Convert.ToDouble(splitmasses[1]));
                            onlymodifications += Convert.ToString(splitmasses[0][1]);
                        }
                    }

                    if (AminoAcids.ContainsKey(splitmasses[0][0])) continue;  // duplicate entry

                    AminoAcids.Add(splitmasses[0][0], Convert.ToDouble(splitmasses[1]));

                    if (splitmasses[0] == "L")
                    {
                        // Add IsoLeucine 
                        AminoAcidMass2.Add("I", Convert.ToDouble(splitmasses[1]));
                        AminoAcids.Add('I', Convert.ToDouble(splitmasses[1]));

                        AminoAcidMass2.Add("J", Convert.ToDouble(splitmasses[1]));
                        AminoAcids.Add('J', Convert.ToDouble(splitmasses[1]));
                    }
                }

                var temp = from m1 in MassLookup
                           from m2 in MassLookup
                           select new { Key = m1.Key + m2.Key, Value = m1.Value + ((string.IsNullOrWhiteSpace(m1.Value) || string.IsNullOrWhiteSpace(m2.Value)) ? string.Empty : " + ") + m2.Value };

                // Get the distinct combinations by key mass -- NOTE: this could hide other mass combinations with the same mass!
                var a = temp.GroupBy(x => x.Key).Select(x => new { Key = x.Key, Value = x.First().Value });
                ComboMassLookup = a.Where(x => x.Key > 0).ToDictionary(k => k.Key, v => v.Value);


                MassLookup.Remove(0);


                var temp1 = from m1 in MassLookup
                            from m2 in MassLookup
                            from m3 in MassLookup
                            select new { Key = m1.Key + m2.Key + m3.Key, Value = m1.Value + ((string.IsNullOrWhiteSpace(m1.Value) || string.IsNullOrWhiteSpace(m2.Value)) ? string.Empty : " + ") + m2.Value + ((string.IsNullOrWhiteSpace(m2.Value) || string.IsNullOrWhiteSpace(m3.Value)) ? string.Empty : " + ") + m3.Value };

                var a1 = temp1.GroupBy(x => x.Key).Select(x => new { Key = x.Key, Value = x.First().Value });

                ThreeComboMassLookup = a1.Where(x => x.Key > 0).ToDictionary(k => k.Key, v => v.Value);

                Debug.Print("Dipeptide count: " + ComboMassLookup.Count());

                Properties.Settings.Default.Save();
            }
            catch (Exception ex)
            {
                System.Windows.MessageBox.Show(ex.Message);

            }
        }

        private void MenuItem1_Click(object sender, RoutedEventArgs e)
        {

            try
            {
                var xvalue = (double)BottomChart.TrendLines[0].Value;
                xvalue = (SpecRightClickSpot.Start + SpecRightClickSpot.End) / 2d;  // average

                if (xvalue == 0) return;

                var bins = CurrentSpectrum.Range(xvalue - 10, xvalue + 10);

                //foreach (var abin in bins)
                //    output += abin.Key.ToString() + ", " + abin.Value.ToString() + "\n";


                //Dispatcher.BeginInvoke(() =>
                //{
                //    Clipboard.SetText(output);
                //});

                // Call service with values...

                //var serviceCall2 = new Uri(hostSource, "../SignalProcessor.svc/FindMonoMass?points=" + Uri.EscapeDataString(xvalue.ToString() + "\n" + output));
                //var client2 = new WebClient();
                //client2.DownloadStringCompleted += GotResult;
                //client2.DownloadStringAsync(serviceCall2);

                // Build a wrapper exception that will be serialized
                //Exception ex = e.ExceptionObject;
                //MyException exception = new MyException(ex.Message, ex.StackTrace, "silverlight app", ex.GetType().FullName, string.Empty);

                var points = new List<SignalProcessing.Point>();
                points.Add(new SignalProcessing.Point() { X = xvalue, Y = -1 });
                points.Add(new SignalProcessing.Point() { X = xvalue - 10, Y = 0 });
                points.AddRange(bins.Select(s => new SignalProcessing.Point() { X = s.Mass, Y = s.HybridIntensity }));  // Must use Hybrid intensity here because using raw intensity may find isotope patterns in noise peaks
                //points.AddRange(bins.Select(s => new SignalProcessing.Point() { X = s.Mass, Y = s.Intensity }));
                points.Add(new SignalProcessing.Point() { X = xvalue + 10, Y = 0 });

                //                string json = string.Empty;

                //                using (MemoryStream memoryStream = new MemoryStream())
                //                {
                //                    // Serialize the object 
                //                    var serializer = new DataContractJsonSerializer(typeof(Point[]));
                ////                    serializer.WriteObject(memoryStream, new point[2] { new SignalProcessing.Point() { X=1d, Y = 2f }, new SignalProcessing.Point() { X=4d, Y=6f } });
                //                    serializer.WriteObject(memoryStream, points);

                //                    // Convert the data to json
                //                    byte[] bytes = memoryStream.ToArray();
                //                    int count = (int)(memoryStream.Length);
                //                    json = Encoding.UTF8.GetString(bytes, 0, count);
                //                }

                //                var wc = new WebClient();
                //                wc.Headers["Content-type"] = "application/json";
                //                wc.Encoding = Encoding.UTF8;
                //                Uri serviceCall3; // = new Uri(hostSource, "../SignalProcessor.svc/FindMonoMass");

                string r;
                List<SignalProcessing.Point> p, x;

                var start = DateTime.Now;

                switch ((sender as MenuItem).Name)
                {
                    case "mnuShowSmoothedSignal":
                        //serviceCall3 = new Uri(hostSource, "../SignalProcessor.svc/FindMonoMassAndGetSignal");
                        //wc.UploadStringCompleted += new UploadStringCompletedEventHandler(SignalReceived);




                        SignalProcessor.FindMonoMass1(points, out r, out p, out x);

                        Console.WriteLine("Elapsed: " + DateTime.Now.Subtract(start).TotalMilliseconds + " ms");

                        BottomChart.Series[5].DataPoints.Clear();


                        foreach (var aPoint in x)
                            BottomChart.Series[5].DataPoints.Add(new DataPoint { XValue = aPoint.X, YValue = (double)aPoint.Y });

                        SetScaling();

                        break;
                    case "mnuShowPredicted":
                        //serviceCall3 = new Uri(hostSource, "../SignalProcessor.svc/FindMonoMassAndGetFit");
                        //wc.UploadStringCompleted += new UploadStringCompletedEventHandler(SignalReceived);

                        BottomChart.Series[5].DataPoints.Clear();

                        SignalProcessor.FindMonoMass1(points, out r, out p, out x);

                        maxofpredictedvalues = p.MaxBy(a => a.X).X;

                        foreach (var aPoint in p)
                            BottomChart.Series[5].DataPoints.Add(new DataPoint { XValue = aPoint.X, YValue = (double)aPoint.Y });

                        SetScaling();

                        break;

                    case "mnuShowCalled":
                        // find closest mono assuming user tried to click on apex of isotope pattern

                        var monoEstimate = xvalue - MassSpec.MonoToApexMass(xvalue);

                        Debug.Print("ShowCalled: " + xvalue);
                        var targetIon = CurrentIons.MinBy(i => Math.Abs(i.MonoMass - monoEstimate));



                        Debug.Print("Target Ion: " + targetIon.MonoMZ);

                        BottomChart.Series[5].DataPoints.Clear();

                        p = SignalProcessor.CalledProfile(targetIon);

                        foreach (var aPoint in p)
                            BottomChart.Series[5].DataPoints.Add(new DataPoint { XValue = aPoint.X, YValue = (double)aPoint.Y });

                        //BottomChart.Series[5].DataSource = SignalProcessor.CalledProfile(targetIon);


                        break;
                    case "mnuShowMonoLabel":
                        Debug.Print("ShowMonoLabel: " + xvalue);

                        if (mnuShowMonoLabel.Tag != null && mnuShowMonoLabel.Tag is MonoLabelAction)
                        {
                            var action = mnuShowMonoLabel.Tag as MonoLabelAction;

                            Debug.Print("Taking action: M" + action.Mass.ToString() + ", I" + action.Intensity.ToString() + ", Z" + action.Z.ToString());

                            if (action.Show)
                            {
                                Debug.Print("Mono Show");

                                // Show the marker
                                MonoMasslabel.DataPoints.Add(new DataPoint { ShadowEnabled = false, MarkerSize = 10, MarkerType = MarkerTypes.Diamond, MarkerEnabled = true, XValue = action.Mass, YValue = 11, LabelStyle = LabelStyles.Middle, LabelEnabled = true, LabelText = action.Mass.ToString("0.0000") }); //  + "\t\t " });

                                if (!CurrentMonoMasses.Where(s => (double)s.XValue == action.Mass).Any())
                                    CurrentMonoMasses.Add(new DataPoint() { XValue = action.Mass, YValue = action.Intensity, ZValue = action.Z });
                            }
                            else
                            {
                                Debug.Print("Mono Hide");
                                MonoMasslabel.DataPoints.Remove(MonoMasslabel.DataPoints.Where(h => (double)h.XValue == action.Mass).First());
                            }
                            SetScaling();
                        }

                        //break;


                        ////double targetIon2 = 0;

                        //var candidates = CurrentMonoMasses.Where(w => Math.Abs((double)w.XValue - xvalue) < zoomWidth / 20).OrderBy(i => Math.Abs((double)i.XValue - xvalue));
                        //var candidateIons = CurrentIons.Where(w => Math.Abs((double)w.MonoMass - xvalue) < zoomWidth / 20).OrderBy(i => Math.Abs((double)i.MonoMass - xvalue));

                        //if (candidates.Any())
                        //{

                        //    var targetIonMass = (double)candidates.First().XValue;

                        //    //var targetIon2 = CurrentIons.MinBy(i => Math.Abs(i.MonoMass - xvalue));

                        //    if (MonoMasslabel.DataPoints.Where(h => (double)h.XValue == targetIonMass).Any())
                        //    {
                        //        // Hide the marker
                        //        MonoMasslabel.DataPoints.Remove(MonoMasslabel.DataPoints.Where(h => (double)h.XValue == targetIonMass).First());
                        //    }
                        //    else
                        //    {
                        //        // Show the marker
                        //        MonoMasslabel.DataPoints.Add(new DataPoint { ShadowEnabled = false, MarkerSize = 10, MarkerType = MarkerTypes.Diamond, MarkerEnabled = true, XValue = targetIonMass, YValue = 11, LabelStyle = LabelStyles.Middle, LabelEnabled = true, LabelText = targetIonMass.ToString("0.0000") }); //  + "\t\t " });
                        //    }
                        //}
                        //else if (candidateIons.Any())
                        //{
                        //    //    var candidateIons = CurrentIons.Where(w => Math.Abs((double)w.XValue - xvalue) < zoomWidth);

                        //    var targetIon2 = candidateIons.First();

                        //    Debug.Print("Target Ion: " + targetIon2.MonoMZ);

                        //    //var targetIon2 = CurrentIons.MinBy(i => Math.Abs(i.MonoMass - xvalue));

                        //    if (MonoMasslabel.DataPoints.Where(h => (double)h.XValue == targetIon2.MonoMass).Any())
                        //    {
                        //        // Hide the marker
                        //        MonoMasslabel.DataPoints.Remove(MonoMasslabel.DataPoints.Where(h => (double)h.XValue == targetIon2.MonoMass).First());
                        //    }
                        //    else
                        //    {
                        //        // Show the marker
                        //        MonoMasslabel.DataPoints.Add(new DataPoint { ShadowEnabled = false, MarkerSize = 10, MarkerType = MarkerTypes.Diamond, MarkerEnabled = true, XValue = targetIon2.MonoMass, YValue = 11, LabelStyle = LabelStyles.Middle, LabelEnabled = true, LabelText = targetIon2.MonoMass.ToString("0.0000") }); //  + "\t\t " });

                        //        if (!CurrentMonoMasses.Where(s => (double)s.XValue == targetIon2.MonoMass).Any())
                        //            CurrentMonoMasses.Add(new DataPoint() { XValue = targetIon2.MonoMass, YValue = targetIon2.Intensity, ZValue = targetIon2.Z });
                        //    }
                        //}

                        // var point = CurrentMonoMasses.Where(s => (double)s.XValue == targetIon2.MonoMass).FirstOrDefault();

                        //if (point != null) point.LabelText = "#XValue";


                        break;
                    default:
                        //serviceCall3 = new Uri(hostSource, "../SignalProcessor.svc/FindMonoMass");
                        //wc.UploadStringCompleted += new UploadStringCompletedEventHandler(wc_UploadStringCompleted);


                        SignalProcessor.FindMonoMass1(points, out r, out p, out x);
                        Console.WriteLine("Elapsed: " + DateTime.Now.Subtract(start).TotalMilliseconds + " ms");

                        var pointToAdd = new DataPoint() { XValue = double.Parse(r.Split(',')[0].Trim('\"', '"')), YValue = double.Parse(r.Split(',')[1].Trim('\"', '"')), ZValue = 0 };
                        CurrentMonoMasses.Add(pointToAdd);
                        BottomChart.Series[4].Opacity = (CurrentMonoMasses.Count > 0) ? 1 : 0;

                        break;
                }


                //var serviceCall3 = new Uri(hostSource, "../SignalProcessor.svc/FindMonoMassAndGetFit");

                //urlString = "http://" + site + "/service1.svc/SendData";
                //wc.UploadStringCompleted += new UploadStringCompletedEventHandler(wc_UploadStringCompleted);
                //wc.UploadStringAsync(serviceCall3, "POST", (xvalue.ToString() + "\n" + output));

                //System.Diagnostics.Debug.WriteLine("Executing Post");
                //wc.UploadStringAsync(serviceCall3, "POST", json);


                //// Submit the information to log
                //string url = "http://localhost:90/services/MyService.svc/LogError";
                //WebClient loggingService = new WebClient();
                //loggingService.UploadStringCompleted += new UploadStringCompletedEventHandler(loggingService_UploadStringCompleted);
                //loggingService.Headers["Content-type"] = "application/json";
                //loggingService.Encoding = Encoding.UTF8;
                //loggingService.UploadStringAsync(new Uri(logExceptionUrl), "POST", json);





                //System.Diagnostics.Debug.WriteLine(output);

            }
            catch (Exception ex)
            {
                App.Laststacktrace = ex.StackTrace;
                Action throwException = () => { throw ex; };
                Dispatcher.CurrentDispatcher.BeginInvoke(throwException);
            }

            //MessageBox.Show("Calculating...");
        }

        //void SignalReceived(object sender, UploadStringCompletedEventArgs e)
        //{
        //    try
        //    {
        //        var points = new List <SignalProcessing.Point>();
        //        var ms = new MemoryStream(Encoding.Unicode.GetBytes(e.Result));
        //        var serializer = new DataContractJsonSerializer(points.GetType());
        //        points = serializer.ReadObject(ms) as List <SignalProcessing.Point>;
        //        ms.Close();

        //        BottomChart.Series[5].DataPoints.Clear();

        //        foreach (var aPoint in points)
        //            BottomChart.Series[5].DataPoints.Add(new DataPoint { XValue = aPoint.X, YValue = (double)aPoint.Y });
        //    }
        //    catch (Exception ex)
        //    {
        //        System.Windows.MessageBox.Show("Result = " + e.Result + ", error: " + ex.Message + ", Inner: " + ex.InnerException.Message);
        //    }
        //}

        //void wc_UploadStringCompleted(object sender, UploadStringCompletedEventArgs e)
        //{
        //    try
        //    {
        //        var pointToAdd = new DataPoint() { XValue = double.Parse(e.Result.Split(',')[0].Trim('\"', '"')), YValue = double.Parse(e.Result.Split(',')[1].Trim('\"', '"')) };
        //        CurrentMonoMasses.Add(pointToAdd);
        //        BottomChart.Series[4].Opacity = (CurrentMonoMasses.Count > 0) ? 1 : 0;
        //    }
        //    catch (Exception ex)
        //    {
        //        System.Windows.MessageBox.Show("Result = " + e.Result + ", error: " + ex.Message + ", Inner: " + ex.InnerException.Message);
        //    }
        //}


        //void GotResult(object sender, DownloadStringCompletedEventArgs e)
        //{
        //    System.Windows.MessageBox.Show("Result is: " + e.Result);
        //}

        private void CopyPoints_Click(object sender, RoutedEventArgs e)
        {
            // Yikes, this should get broken up into a few intelligible lines...
            string points = string.Join("\n", CurrentSpectrum.Range((double)BottomChart.AxesX[0].ViewMinimum, (double)BottomChart.AxesX[0].ViewMaximum).Select(r => r.Mass.ToString() + "\t" + r.Intensity.ToString()));



            Clipboard.SetText(points);
        }

        private void CopyIsotopeClusters_Click(object sender, RoutedEventArgs e)
        {
            // Yikes, this should get broken up into a few intelligible lines...

            string points = "MonoMass\tMonoMZ\tZ\tScore\tIntensity\tCorePeaks\n";
            points += string.Join("\n", CurrentIons.Select(r => r.MonoMass.ToString() + "\t" + r.MonoMZ.ToString() + "\t" + r.Z.ToString() + "\t" + r.Score.ToString() + "\t" + r.Intensity.ToString() + "\t" + r.Peaks.Where(p => p.IsCorePeak).Count()));

            Clipboard.SetText(points);
        }

        //private void button1_Click(object sender, RoutedEventArgs e)
        //{
        //    //this.Dispatcher.BeginInvoke(() =>
        //    //{
        //    Clipboard.SetText("ABC");
        //    //});
        //}

        //private void button1_Click_3(object sender, RoutedEventArgs e)
        //{

        //    //CurrentMonoMasses.Add(5, 4);

        //    //Clipboard.ContainsText();
        //    //Clipboard.SetText("ABC");
        //}

        private void btnCopy_Click(object sender, RoutedEventArgs e)
        {
            //this.Dispatcher.BeginInvoke(() =>
            //{
            Clipboard.SetText(string.Join("\r\n", CurrentMonoMasses.Select(m => m.XValue.ToString() + "\t" + m.YValue.ToString() + "\t" + m.ZValue.ToString())));
            //});
        }


        private void txtMolecules_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.Key == Key.Tab)
            {
                e.Handled = true;

                var tb = ((TextBox)sender);
                var cursorLocation = tb.CaretIndex;
                tb.Text = tb.Text.Insert(cursorLocation, "\t");
                tb.Select(cursorLocation + 1, 0);
                //tb.Text += "\t";
                //tb.Select(tb.Text.Length, 0);
            }
        }

        private void UserControl_KeyUp(object sender, KeyEventArgs e)
        {
            switch (e.Key)
            {
                case Key.Right:
                    if (txtScanNum.IsFocused || btnPrevious.IsFocused || btnNext.IsFocused)
                    {
                        btnNext_Click(null, null);
                    }
                    break;
                case Key.Left:
                    if (txtScanNum.IsFocused || btnPrevious.IsFocused || btnNext.IsFocused)
                    {
                        btnPrevious_Click(null, null);
                    }
                    break;
                case Key.Space:
                    if (busySpectrum.IsMouseOver)
                    {
                        AddRangeLabel();
                    }
                    break;
                case Key.Return:

                    if (txtScanNum.IsEnabled && txtScanNum.IsFocused)
                    {
                        float rt = 1;

                        try
                        {
                            int newScanNum = 0;

                            if (int.TryParse(txtScanNum.Text, out newScanNum) && MainPointProvider.ScanExists(int.Parse(txtScanNum.Text)))
                            {
                                rt = MainPointProvider.RetentionTime(newScanNum);

                                if (this.CurrentScanNumber.ToString() != MainPointProvider.ScanIndex(rt).ToString())
                                {
                                    txtScanNum.Text = MainPointProvider.ScanIndex(rt).ToString();
                                    DisplayNewSpectrum(rt);
                                    //chkSequence.Visibility = System.Windows.Visibility.Collapsed;
                                    dtgridsequences.Visibility = System.Windows.Visibility.Collapsed;
                                    ClearSequenceMatch();
                                    btnFindAA.Visibility = System.Windows.Visibility.Visible;
                                    btnMatch.IsEnabled = false;
                                    txtMatchSequence.IsEnabled = false;
                                }
                            }
                            else if (CurrentScanNumber.HasValue)
                            {
                                txtScanNum.Text = CurrentScanNumber.Value.ToString();
                            }
                        }
                        catch { }
                    }
                    break;

                //case Key.F1:
                //    btngrabsomedata.Visibility = System.Windows.Visibility.Visible;
                //    break;

                default:
                    return;
            }

            e.Handled = true;
        }


        private void AddReverseRangeNewSequence()
        {
            AnnotationBars1.DataPoints.Add(new DataPoint() { XValue = lastbar.Start - 0.000001d, YValue = double.NaN, Name = lastbar.Index, StickColor = System.Windows.Media.Brushes.DarkRed });
            AnnotationBars1.DataPoints.Add(new DataPoint() { XValue = lastbar.Start, YValue = 4, LabelEnabled = false, Name = lastbar.Index, MarkerBorderColor = System.Windows.Media.Brushes.DarkRed, MarkerBorderThickness = MarkerThickness(lastbar.StartScore), StickColor = System.Windows.Media.Brushes.DarkRed });
            AnnotationBars1.DataPoints.Add(new DataPoint() { MarkerEnabled = false, LabelStyle = LabelStyles.Below, Name = lastbar.Index, LabelEnabled = true, XValue = lastbar.Start + ((lastbar.End - lastbar.Start) / 2), YValue = 4, LabelText = lastbar.Name, StickColor = System.Windows.Media.Brushes.DarkRed });
            AnnotationBars1.DataPoints.Add(new DataPoint() { XValue = lastbar.End, YValue = 4, LabelEnabled = false, Name = lastbar.Index, MarkerBorderColor = System.Windows.Media.Brushes.DarkRed, MarkerBorderThickness = MarkerThickness(lastbar.EndScore), StickColor = System.Windows.Media.Brushes.DarkRed });
            AnnotationBars1.DataPoints.Add(new DataPoint() { XValue = lastbar.End + 0.000001d, YValue = double.NaN, Name = lastbar.Index, StickColor = System.Windows.Media.Brushes.DarkRed });
        }

        private void AddRangeNewSequence()
        {
            if (!reversesequence)
            {
                AnnotationBars1.DataPoints.Add(new DataPoint() { XValue = lastbar.Start - 0.000001d, YValue = double.NaN, Name = lastbar.Index });
                AnnotationBars1.DataPoints.Add(new DataPoint() { XValue = lastbar.Start, YValue = 10, LabelEnabled = false, Name = lastbar.Index, MarkerBorderColor = System.Windows.Media.Brushes.BurlyWood, MarkerBorderThickness = MarkerThickness(lastbar.StartScore) });
                AnnotationBars1.DataPoints.Add(new DataPoint() { MarkerEnabled = false, LabelStyle = LabelStyles.Below, Name = lastbar.Index, LabelEnabled = true, XValue = lastbar.Start + ((lastbar.End - lastbar.Start) / 2), YValue = 10, LabelText = lastbar.Name });
                AnnotationBars1.DataPoints.Add(new DataPoint() { XValue = lastbar.End, YValue = 10, LabelEnabled = false, Name = lastbar.Index, MarkerBorderColor = System.Windows.Media.Brushes.BurlyWood, MarkerBorderThickness = MarkerThickness(lastbar.EndScore) });
                AnnotationBars1.DataPoints.Add(new DataPoint() { XValue = lastbar.End + 0.000001d, YValue = double.NaN, Name = lastbar.Index });
            }
            else
            {
                AnnotationBars1.DataPoints.Add(new DataPoint() { XValue = lastbar.Start - 0.000001d, YValue = double.NaN, Name = lastbar.Index });
                AnnotationBars1.DataPoints.Add(new DataPoint() { XValue = lastbar.Start, YValue = 10, LabelEnabled = false, Name = lastbar.Index, MarkerBorderColor = System.Windows.Media.Brushes.BurlyWood, MarkerBorderThickness = MarkerThickness(3802) });
                AnnotationBars1.DataPoints.Add(new DataPoint() { MarkerEnabled = false, LabelStyle = LabelStyles.Below, Name = lastbar.Index, LabelEnabled = true, XValue = lastbar.Start + ((lastbar.End - lastbar.Start) / 2), YValue = 10, LabelText = lastbar.Name });
                AnnotationBars1.DataPoints.Add(new DataPoint() { XValue = lastbar.End, YValue = 10, LabelEnabled = false, Name = lastbar.Index, MarkerBorderColor = System.Windows.Media.Brushes.BurlyWood, MarkerBorderThickness = MarkerThickness(3802) });
                AnnotationBars1.DataPoints.Add(new DataPoint() { XValue = lastbar.End + 0.000001d, YValue = double.NaN, Name = lastbar.Index });
                reversesequence = false;
            }
        }

        /// <summary>
        /// A Multipurpose Method for adding annotation bars to the Spectrum Chart
        /// </summary>
        /// <param name="series"></param>
        /// <param name="aBar"></param>
        /// <param name="verticalOffset"></param>
        /// <param name="showEndPoints"></param>
        /// <param name="isReverse"></param>
        private void AddAnnotationBar(DataSeries series, AnnotationBar aBar, System.Windows.Media.Brush markerBrush = null, bool showEndPoints = true, float verticalOffset = 10, bool isReverse = false, bool startside = false, bool endside = false)
        {
            if (markerBrush == null) markerBrush = System.Windows.Media.Brushes.Green;

            if (isReverse)
            {
                if ((startside || endside))
                {
                    if (!startside)
                    {
                        series.DataPoints.Add(new DataPoint() { XValue = aBar.Start - 0.000001d, YValue = double.NaN, Name = aBar.Index });
                        series.DataPoints.Add(new DataPoint() { XValue = aBar.Start, YValue = verticalOffset, MarkerEnabled = showEndPoints, LabelEnabled = false, Name = aBar.Index, MarkerBorderColor = markerBrush, MarkerBorderThickness = MarkerThickness(aBar.StartScore), MarkerSize = 13 });
                    }
                    //series.DataPoints.Add(new DataPoint() { XValue = aBar.Start, YValue = verticalOffset, MarkerEnabled = showEndPoints, LabelEnabled = false, Name = aBar.Index, MarkerBorderColor = markerBrush, MarkerBorderThickness = MarkerThickness(3802) });
                    if (!string.IsNullOrWhiteSpace(aBar.Name)) series.DataPoints.Add(new DataPoint() { MarkerEnabled = false, LabelStyle = LabelStyles.Below, Name = aBar.Index, LabelEnabled = true, XValue = aBar.Start + ((aBar.End - aBar.Start) / 2), YValue = verticalOffset, LabelText = aBar.Name });
                    if (!endside)
                    {
                        series.DataPoints.Add(new DataPoint() { XValue = aBar.End, YValue = verticalOffset, MarkerEnabled = showEndPoints, LabelEnabled = false, Name = aBar.Index, MarkerBorderColor = markerBrush, MarkerBorderThickness = MarkerThickness(aBar.EndScore), MarkerSize = 13 });
                        //series.DataPoints.Add(new DataPoint() { XValue = aBar.End, YValue = verticalOffset, MarkerEnabled = showEndPoints, LabelEnabled = false, Name = aBar.Index, MarkerBorderColor = markerBrush, MarkerBorderThickness = MarkerThickness(3802) });
                        series.DataPoints.Add(new DataPoint() { XValue = aBar.End + 0.000001d, YValue = double.NaN, Name = aBar.Index });
                    }
                }
                else
                {
                    //if (!startside)
                    //{
                    series.DataPoints.Add(new DataPoint() { XValue = aBar.Start - 0.000001d, YValue = double.NaN, Name = aBar.Index });
                    series.DataPoints.Add(new DataPoint() { XValue = aBar.Start, YValue = verticalOffset, MarkerEnabled = showEndPoints, LabelEnabled = false, Name = aBar.Index, MarkerBorderColor = markerBrush, MarkerBorderThickness = MarkerThickness(aBar.StartScore), MarkerSize = 13 });
                    //}
                    //series.DataPoints.Add(new DataPoint() { XValue = aBar.Start, YValue = verticalOffset, MarkerEnabled = showEndPoints, LabelEnabled = false, Name = aBar.Index, MarkerBorderColor = markerBrush, MarkerBorderThickness = MarkerThickness(3802) });
                    if (!string.IsNullOrWhiteSpace(aBar.Name)) series.DataPoints.Add(new DataPoint() { MarkerEnabled = false, LabelStyle = LabelStyles.Below, Name = aBar.Index, LabelEnabled = true, XValue = aBar.Start + ((aBar.End - aBar.Start) / 2), YValue = verticalOffset, LabelText = aBar.Name });
                    //if (!endside)
                    //{
                    series.DataPoints.Add(new DataPoint() { XValue = aBar.End, YValue = verticalOffset, MarkerEnabled = showEndPoints, LabelEnabled = false, Name = aBar.Index, MarkerBorderColor = markerBrush, MarkerBorderThickness = MarkerThickness(aBar.EndScore), MarkerSize = 13 });
                    //series.DataPoints.Add(new DataPoint() { XValue = aBar.End, YValue = verticalOffset, MarkerEnabled = showEndPoints, LabelEnabled = false, Name = aBar.Index, MarkerBorderColor = markerBrush, MarkerBorderThickness = MarkerThickness(3802) });
                    series.DataPoints.Add(new DataPoint() { XValue = aBar.End + 0.000001d, YValue = double.NaN, Name = aBar.Index });
                    //}
                }
                reversesequence = false;
            }
            else
            {
                if ((startside || endside))
                {
                    if (!startside)
                    {
                        series.DataPoints.Add(new DataPoint() { XValue = aBar.Start - 0.000001d, YValue = double.NaN, Name = aBar.Index });
                        series.DataPoints.Add(new DataPoint() { XValue = aBar.Start, YValue = verticalOffset, MarkerEnabled = showEndPoints, LabelEnabled = false, Name = aBar.Index, MarkerBorderColor = markerBrush, MarkerBorderThickness = MarkerThickness(aBar.StartScore), MarkerSize = 13 });
                    }
                    if (!string.IsNullOrWhiteSpace(aBar.Name)) series.DataPoints.Add(new DataPoint() { MarkerEnabled = false, LabelStyle = LabelStyles.Below, Name = aBar.Index, LabelEnabled = true, XValue = aBar.Start + ((aBar.End - aBar.Start) / 2), YValue = verticalOffset, LabelText = aBar.Name });
                    if (!endside)
                    {
                        series.DataPoints.Add(new DataPoint() { XValue = aBar.End, YValue = verticalOffset, MarkerEnabled = showEndPoints, LabelEnabled = false, Name = aBar.Index, MarkerBorderColor = markerBrush, MarkerBorderThickness = MarkerThickness(aBar.EndScore), MarkerSize = 13 });
                        series.DataPoints.Add(new DataPoint() { XValue = aBar.End + 0.000001d, YValue = double.NaN, Name = aBar.Index });
                    }
                }
                else
                {
                    //if (!startside)
                    //{
                    series.DataPoints.Add(new DataPoint() { XValue = aBar.Start - 0.000001d, YValue = double.NaN, Name = aBar.Index });
                    series.DataPoints.Add(new DataPoint() { XValue = aBar.Start, YValue = verticalOffset, MarkerEnabled = showEndPoints, LabelEnabled = false, Name = aBar.Index, MarkerBorderColor = markerBrush, MarkerBorderThickness = MarkerThickness(aBar.StartScore), MarkerSize = 13 });
                    //}
                    if (!string.IsNullOrWhiteSpace(aBar.Name)) series.DataPoints.Add(new DataPoint() { MarkerEnabled = false, LabelStyle = LabelStyles.Below, Name = aBar.Index, LabelEnabled = true, XValue = aBar.Start + ((aBar.End - aBar.Start) / 2), YValue = verticalOffset, LabelText = aBar.Name });
                    //if (!endside)
                    //{
                    series.DataPoints.Add(new DataPoint() { XValue = aBar.End, YValue = verticalOffset, MarkerEnabled = showEndPoints, LabelEnabled = false, Name = aBar.Index, MarkerBorderColor = markerBrush, MarkerBorderThickness = MarkerThickness(aBar.EndScore), MarkerSize = 13 });
                    series.DataPoints.Add(new DataPoint() { XValue = aBar.End + 0.000001d, YValue = double.NaN, Name = aBar.Index });
                    //}
                }
            }
        }

        private void AddRangeNewSequence(AnnotationBar aBar, bool isReverse = false)
        {

            if (isReverse)
            {
                AnnotationBars1.DataPoints.Add(new DataPoint() { XValue = aBar.Start - 0.000001d, YValue = double.NaN, Name = aBar.Index });
                AnnotationBars1.DataPoints.Add(new DataPoint() { XValue = aBar.Start, YValue = 10, LabelEnabled = false, Name = aBar.Index, MarkerBorderColor = System.Windows.Media.Brushes.BurlyWood, MarkerBorderThickness = MarkerThickness(3802) });
                AnnotationBars1.DataPoints.Add(new DataPoint() { MarkerEnabled = false, LabelStyle = LabelStyles.Below, Name = aBar.Index, LabelEnabled = true, XValue = aBar.Start + ((aBar.End - aBar.Start) / 2), YValue = 10, LabelText = aBar.Name });
                AnnotationBars1.DataPoints.Add(new DataPoint() { XValue = aBar.End, YValue = 10, LabelEnabled = false, Name = aBar.Index, MarkerBorderColor = System.Windows.Media.Brushes.BurlyWood, MarkerBorderThickness = MarkerThickness(3802) });
                AnnotationBars1.DataPoints.Add(new DataPoint() { XValue = aBar.End + 0.000001d, YValue = double.NaN, Name = aBar.Index });
                reversesequence = false;
            }
            else
            {
                AnnotationBars1.DataPoints.Add(new DataPoint() { XValue = aBar.Start - 0.000001d, YValue = double.NaN, Name = aBar.Index });
                AnnotationBars1.DataPoints.Add(new DataPoint() { XValue = aBar.Start, YValue = 10, LabelEnabled = false, Name = aBar.Index, MarkerBorderColor = System.Windows.Media.Brushes.BurlyWood, MarkerBorderThickness = MarkerThickness(aBar.StartScore) });
                AnnotationBars1.DataPoints.Add(new DataPoint() { MarkerEnabled = false, LabelStyle = LabelStyles.Below, Name = aBar.Index, LabelEnabled = true, XValue = aBar.Start + ((aBar.End - aBar.Start) / 2), YValue = 10, LabelText = aBar.Name });
                AnnotationBars1.DataPoints.Add(new DataPoint() { XValue = aBar.End, YValue = 10, LabelEnabled = false, Name = aBar.Index, MarkerBorderColor = System.Windows.Media.Brushes.BurlyWood, MarkerBorderThickness = MarkerThickness(aBar.EndScore) });
                AnnotationBars1.DataPoints.Add(new DataPoint() { XValue = aBar.End + 0.000001d, YValue = double.NaN, Name = aBar.Index });
            }
        }

        private void AddGapSequence()
        {
            AnnotationBars1.DataPoints.Add(new DataPoint() { XValue = lastbar.Start - 0.000001d, YValue = double.NaN, Name = lastbar.Index });
            AnnotationBars1.DataPoints.Add(new DataPoint() { XValue = lastbar.Start, YValue = 4, LabelEnabled = false, Name = lastbar.Index, MarkerBorderColor = System.Windows.Media.Brushes.DarkViolet, MarkerBorderThickness = MarkerThickness(lastbar.StartScore) });
            AnnotationBars1.DataPoints.Add(new DataPoint() { MarkerEnabled = false, LabelStyle = LabelStyles.Below, Name = lastbar.Index, LabelEnabled = true, XValue = lastbar.Start + ((lastbar.End - lastbar.Start) / 2), YValue = 4, LabelText = lastbar.Name });
            AnnotationBars1.DataPoints.Add(new DataPoint() { XValue = lastbar.End, YValue = 4, LabelEnabled = false, Name = lastbar.Index, MarkerBorderColor = System.Windows.Media.Brushes.DarkViolet, MarkerBorderThickness = MarkerThickness(lastbar.EndScore) });
            AnnotationBars1.DataPoints.Add(new DataPoint() { XValue = lastbar.End + 0.000001d, YValue = double.NaN, Name = lastbar.Index });
        }

        private void AddDBRangeLabel(AnnotationBar theBar, double score = 0, bool start = false, bool end = false)
        {
            if (score <= 0.009)
            {
                AddAnnotationBar(AnnotationBars1, theBar, System.Windows.Media.Brushes.Green);
            }
            if (score == 0.050)
            {
                AddAnnotationBar(AnnotationBarsBlue, theBar, System.Windows.Media.Brushes.Black);
            }
            //else if (score == 0.0501)
            //{
            //    AddAnnotationBar(AnnotationBarsBlue, theBar, System.Windows.Media.Brushes.Yellow, true, 10, start, end);
            //}
            else if (score == 0.0502)
            {
                AddAnnotationBar(AnnotationBarsBlue, theBar, System.Windows.Media.Brushes.Black, true, 10, start, end);
            }
            else if (score == 0.0600)
            {
                AddAnnotationBar(CTerminusLine, theBar, System.Windows.Media.Brushes.Purple, true, 10, start, end);
            }
            else if (score >= 0.100 && score < 0.200)
            {
                AddAnnotationBar(GrayBarSeries, theBar, System.Windows.Media.Brushes.LightGray);
            }
            else if (score >= 0.200)
            {
                AddAnnotationBar(RedBarSeries, theBar, null, false);
            }
        }

        private void AddRangeLabel()
        {
            if (AnnotationbarScore <= 0.025)
            {
                AnnotationBars1.DataPoints.Add(new DataPoint() { XValue = lastbar.Start - 0.000001d, YValue = double.NaN, Name = lastbar.Index });
                AnnotationBars1.DataPoints.Add(new DataPoint() { XValue = lastbar.Start, YValue = 8.0, LabelEnabled = false, Name = lastbar.Index, MarkerBorderColor = System.Windows.Media.Brushes.Green, MarkerBorderThickness = MarkerThickness(lastbar.StartScore) });
                AnnotationBars1.DataPoints.Add(new DataPoint() { MarkerEnabled = false, LabelStyle = LabelStyles.Below, Name = lastbar.Index, LabelEnabled = true, XValue = lastbar.Start + ((lastbar.End - lastbar.Start) / 2), YValue = 8.0, LabelText = lastbar.Name });
                AnnotationBars1.DataPoints.Add(new DataPoint() { XValue = lastbar.End, YValue = 8.0, LabelEnabled = false, Name = lastbar.Index, MarkerBorderColor = System.Windows.Media.Brushes.Green, MarkerBorderThickness = MarkerThickness(lastbar.EndScore) });
                AnnotationBars1.DataPoints.Add(new DataPoint() { XValue = lastbar.End + 0.000001d, YValue = double.NaN, Name = lastbar.Index });
            }
            else if (AnnotationbarScore >= 0.025 & AnnotationbarScore <= 0.050)
            {
                AnnotationBars2.DataPoints.Add(new DataPoint() { XValue = lastbar.Start - 0.000001d, YValue = double.NaN, Name = lastbar.Index });
                AnnotationBars2.DataPoints.Add(new DataPoint() { XValue = lastbar.Start, YValue = 8.0, LabelEnabled = false, Name = lastbar.Index, MarkerBorderColor = System.Windows.Media.Brushes.Green, MarkerBorderThickness = MarkerThickness(lastbar.StartScore) });
                AnnotationBars2.DataPoints.Add(new DataPoint() { MarkerEnabled = false, LabelStyle = LabelStyles.Below, Name = lastbar.Index, LabelEnabled = true, XValue = lastbar.Start + ((lastbar.End - lastbar.Start) / 2), YValue = 8.0, LabelText = lastbar.Name });
                AnnotationBars2.DataPoints.Add(new DataPoint() { XValue = lastbar.End, YValue = 8.0, LabelEnabled = false, Name = lastbar.Index, MarkerBorderColor = System.Windows.Media.Brushes.Green, MarkerBorderThickness = MarkerThickness(lastbar.EndScore) });
                AnnotationBars2.DataPoints.Add(new DataPoint() { XValue = lastbar.End + 0.000001d, YValue = double.NaN, Name = lastbar.Index });
            }
            else if (AnnotationbarScore >= 0.050 & AnnotationbarScore <= 0.075)
            {
                AnnotationBars3.DataPoints.Add(new DataPoint() { XValue = lastbar.Start - 0.000001d, YValue = double.NaN, Name = lastbar.Index });
                AnnotationBars3.DataPoints.Add(new DataPoint() { XValue = lastbar.Start, YValue = 8.0, LabelEnabled = false, Name = lastbar.Index, MarkerBorderColor = System.Windows.Media.Brushes.Green, MarkerBorderThickness = MarkerThickness(lastbar.StartScore) });
                AnnotationBars3.DataPoints.Add(new DataPoint() { MarkerEnabled = false, LabelStyle = LabelStyles.Below, Name = lastbar.Index, LabelEnabled = true, XValue = lastbar.Start + ((lastbar.End - lastbar.Start) / 2), YValue = 8.0, LabelText = lastbar.Name });
                AnnotationBars3.DataPoints.Add(new DataPoint() { XValue = lastbar.End, YValue = 8.0, LabelEnabled = false, Name = lastbar.Index, MarkerBorderColor = System.Windows.Media.Brushes.Green, MarkerBorderThickness = MarkerThickness(lastbar.EndScore) });
                AnnotationBars3.DataPoints.Add(new DataPoint() { XValue = lastbar.End + 0.000001d, YValue = double.NaN, Name = lastbar.Index });
            }
            else if (AnnotationbarScore >= 0.075)
            {
                GrayBarSeries.DataPoints.Add(new DataPoint() { XValue = lastbar.Start - 0.000001d, YValue = double.NaN, Name = lastbar.Index });
                GrayBarSeries.DataPoints.Add(new DataPoint() { XValue = lastbar.Start, YValue = 8.0, LabelEnabled = false, Name = lastbar.Index, MarkerBorderColor = System.Windows.Media.Brushes.Green, MarkerBorderThickness = MarkerThickness(lastbar.StartScore) });
                GrayBarSeries.DataPoints.Add(new DataPoint() { MarkerEnabled = false, LabelStyle = LabelStyles.Below, Name = lastbar.Index, LabelEnabled = true, XValue = lastbar.Start + ((lastbar.End - lastbar.Start) / 2), YValue = 8.0, LabelText = lastbar.Name });
                GrayBarSeries.DataPoints.Add(new DataPoint() { XValue = lastbar.End, YValue = 8.0, LabelEnabled = false, Name = lastbar.Index, MarkerBorderColor = System.Windows.Media.Brushes.Green, MarkerBorderThickness = MarkerThickness(lastbar.EndScore) });
                GrayBarSeries.DataPoints.Add(new DataPoint() { XValue = lastbar.End + 0.000001d, YValue = double.NaN, Name = lastbar.Index });
            }
            OffsetStart = SequenceDirectionRightToLeft ? lastbar.Start : lastbar.End;
        }

        private Thickness MarkerThickness(double th)
        {
            Thickness thick = new Thickness();
            if (th <= 1400)
            {
                thick.Left = 1;
                thick.Bottom = 1;
                return thick;
            }
            else if (th >= 1401 && th <= 2600)
            {
                thick.Left = 3;
                thick.Bottom = 3;
                return thick;
            }
            else if (th >= 2601 && th <= 3800)
            {
                thick.Left = 6;
                thick.Bottom = 6;
                return thick;
            }
            else if (th >= 3801)
            {
                thick.Left = 10;
                thick.Bottom = 10;
                return thick;
            }
            return thick;
        }


        private void RemoveRangeLabel(AnnotationBar barToRemove, double barScore)
        {
            try
            {

                if (barScore <= 0.025)
                {
                    AnnotationBars1.DataPoints.Remove(
                                                            AnnotationBars1.DataPoints.Where(a => Convert.ToDouble(a.XValue) == (barToRemove.Start - 0.000001d) && (a.Name == barToRemove.Index)
                                                            ).First());
                    AnnotationBars1.DataPoints.Remove(
                                                            AnnotationBars1.DataPoints.Where(a => Convert.ToDouble(a.XValue) == barToRemove.End + 0.000001d && (a.Name == barToRemove.Index)
                                                            ).First());
                    AnnotationBars1.DataPoints.Remove(
                                                                AnnotationBars1.DataPoints.Where(a => (Convert.ToDouble(a.XValue) == barToRemove.Start) && (Convert.ToDouble(a.YValue) == 8.0) && (a.Name == barToRemove.Index)
                                                                ).First());
                    AnnotationBars1.DataPoints.Remove(
                                                            AnnotationBars1.DataPoints.Where(a => (Convert.ToDouble(a.XValue) == barToRemove.Start + ((barToRemove.End - barToRemove.Start) / 2)) && (Convert.ToDouble(a.YValue) == 8.0) && (a.Name == barToRemove.Index)
                                                            ).First());
                    AnnotationBars1.DataPoints.Remove(
                                                            AnnotationBars1.DataPoints.Where(a => (Convert.ToDouble(a.XValue) == barToRemove.End) && (Convert.ToDouble(a.YValue) == 8.0) && (a.Name == barToRemove.Index)
                                                            ).First());
                }
                else if (barScore >= 0.025 & barScore <= 0.050)
                {
                    AnnotationBars2.DataPoints.Remove(
                                                            AnnotationBars2.DataPoints.Where(a => Convert.ToDouble(a.XValue) == (barToRemove.Start - 0.000001d) && (a.Name == barToRemove.Index)
                                                            ).First());
                    AnnotationBars2.DataPoints.Remove(
                                                            AnnotationBars2.DataPoints.Where(a => Convert.ToDouble(a.XValue) == barToRemove.End + 0.000001d && (a.Name == barToRemove.Index)
                                                            ).First());
                    AnnotationBars2.DataPoints.Remove(
                                                            AnnotationBars2.DataPoints.Where(a => (Convert.ToDouble(a.XValue) == barToRemove.Start) && (Convert.ToDouble(a.YValue) == 8.0) && (a.Name == barToRemove.Index)
                                                                ).First());
                    AnnotationBars2.DataPoints.Remove(
                                                            AnnotationBars2.DataPoints.Where(a => (Convert.ToDouble(a.XValue) == barToRemove.Start + ((barToRemove.End - barToRemove.Start) / 2)) && (Convert.ToDouble(a.YValue) == 8.0) && (a.Name == barToRemove.Index)
                                                            ).First());
                    AnnotationBars2.DataPoints.Remove(
                                                            AnnotationBars2.DataPoints.Where(a => (Convert.ToDouble(a.XValue) == barToRemove.End) && (Convert.ToDouble(a.YValue) == 8.0) && (a.Name == barToRemove.Index)
                                                            ).First());
                }
                else if (barScore >= 0.050 & barScore <= 0.075)
                {
                    AnnotationBars3.DataPoints.Remove(
                                                            AnnotationBars3.DataPoints.Where(a => Convert.ToDouble(a.XValue) == (barToRemove.Start - 0.000001d) && (a.Name == barToRemove.Index)
                                                            ).First());
                    AnnotationBars3.DataPoints.Remove(
                                                            AnnotationBars3.DataPoints.Where(a => Convert.ToDouble(a.XValue) == barToRemove.End + 0.000001d && (a.Name == barToRemove.Index)
                                                            ).First());
                    AnnotationBars3.DataPoints.Remove(
                                                            AnnotationBars3.DataPoints.Where(a => (Convert.ToDouble(a.XValue) == barToRemove.Start) && (Convert.ToDouble(a.YValue) == 8.0) && (a.Name == barToRemove.Index)
                                                            ).First());
                    AnnotationBars3.DataPoints.Remove(
                                                            AnnotationBars3.DataPoints.Where(a => (Convert.ToDouble(a.XValue) == barToRemove.Start + ((barToRemove.End - barToRemove.Start) / 2)) && (Convert.ToDouble(a.YValue) == 8.0) && (a.Name == barToRemove.Index)
                                                            ).First());
                    AnnotationBars3.DataPoints.Remove(
                                                            AnnotationBars3.DataPoints.Where(a => (Convert.ToDouble(a.XValue) == barToRemove.End) && (Convert.ToDouble(a.YValue) == 8.0) && (a.Name == barToRemove.Index)
                                                            ).First());
                }
                else if (barScore >= 0.075)
                {
                    GrayBarSeries.DataPoints.Remove(
                                                            GrayBarSeries.DataPoints.Where(a => Convert.ToDouble(a.XValue) == (barToRemove.Start - 0.000001d) && (a.Name == barToRemove.Index)
                                                            ).First());
                    GrayBarSeries.DataPoints.Remove(
                                                            GrayBarSeries.DataPoints.Where(a => Convert.ToDouble(a.XValue) == barToRemove.End + 0.000001d && (a.Name == barToRemove.Index)
                                                            ).First());
                    GrayBarSeries.DataPoints.Remove(
                                                            GrayBarSeries.DataPoints.Where(a => (Convert.ToDouble(a.XValue) == barToRemove.Start) && (Convert.ToDouble(a.YValue) == 8.0) && (a.Name == barToRemove.Index)
                                                            ).First());
                    GrayBarSeries.DataPoints.Remove(
                                                            GrayBarSeries.DataPoints.Where(a => (Convert.ToDouble(a.XValue) == barToRemove.Start + ((barToRemove.End - barToRemove.Start) / 2)) && (Convert.ToDouble(a.YValue) == 8.0) && (a.Name == barToRemove.Index)
                                                            ).First());
                    GrayBarSeries.DataPoints.Remove(
                                                            GrayBarSeries.DataPoints.Where(a => (Convert.ToDouble(a.XValue) == barToRemove.End) && (Convert.ToDouble(a.YValue) == 8.0) && (a.Name == barToRemove.Index)
                                                            ).First());
                }
            }
            catch
            {
                System.Diagnostics.Debug.WriteLine("Warning: Annotation Bar " + barToRemove.Name + " could not be found to be removed.");
            }
        }


        private void slider1_ValueChanged(object sender, RoutedPropertyChangedEventArgs<double> e)
        {
            if (BottomChart == null) return;

            try
            {
                if (e.NewValue > 0.25)
                {
                    sldDirectionSlider.IsEnabled = false;
                    ThermoSlider.IsEnabled = false;
                }
                else
                {
                    sldDirectionSlider.IsEnabled = true;
                    ThermoSlider.IsEnabled = true;
                }
                BottomChart.Series[0].Opacity = 1 - e.NewValue;
                BottomChart.Series[5].Opacity = e.NewValue;
                ThermoFischer.Opacity = 1 - e.NewValue;
                ReverseSeries.Opacity = 1 - e.NewValue;
            }
            catch { }
        }

        private void UserControl_Loaded(object sender, RoutedEventArgs e)
        {

        }

        private void MenuItem2_Click(object sender, RoutedEventArgs e)
        {
            // Based on: http://www.visifire.com/blog/2009/11/12/exporting-visifire-silverlight-chart-as-image/
            //SaveToImage(BottomChart);
        }

        private void LayoutRoot_Loaded(object sender, RoutedEventArgs e)
        {
            if (System.Diagnostics.Debugger.IsAttached == false && ApplicationDeployment.IsNetworkDeployed)
            {
                ApplicationDeployment applicationDeployment = ApplicationDeployment.CurrentDeployment;

                Version version = applicationDeployment.CurrentVersion;

                lblVersionAuthors.Content = string.Format("Version {0}.{1}.{2}.{3} by Tony Major, Mike Knierman and Anvesh Kodumuri", version.Major, version.Minor, version.Build, version.Revision);
                App.AppVersion = version.Major + "." + version.Minor + "." + version.Build + "." + version.Revision;
            }
            else
            {
                lblVersionAuthors.Content = "by Tony Major, Mike Knierman and Anvesh Kodumuri";
                var assembly = Assembly.GetExecutingAssembly();
                string version = assembly.FullName.Split(',')[1];
                App.AppVersion = version.Split('=')[1];
            }
        }

        private void btnChargeDetect_Click(object sender, RoutedEventArgs e)
        {


            //var specWithCharge = new ChargeDetector();

            //var charges = specWithCharge.ParallelDetectChargeStates(4, 40);

            //System.Windows.MessageBox.Show("Sorry Mike, this isn't implemented yet :)");
        }

        private void btnFindMonoMZ_Click(object sender, RoutedEventArgs e)
        {
            System.Windows.MessageBox.Show("Sorry, this isn't implemented yet :)");
        }

        //   List<FindSequenceTags.SequenceTag> sqsalltags = new List<FindSequenceTags.SequenceTag>();

        private void btnFindAA_Click(object sender, RoutedEventArgs e)
        {
            using (new WaitCursor())
            {
                if (!monosfound || CurrentMonos.Count == 0)
                {
                    FindMonos();
                    monosfound = true;
                }


                sqsalldenovotgs.Clear();
                sqsalldenovotgs = FindAllSequenceTags(CurrentIons, sequencetagmass);

                SaveCurrentScanInfo.currentTags = sqsalldenovotgs;
                SaveCurrentScanInfo.ions = CurrentIons;
                //SaveCurrentScanInfo.ParentMass = 

                //if (CurrentScanNumber != null && CurrentScanNumber.Value != 0)
                //{
                //    SaveCurrentScanInfo.ParentMass = MainPointProvider.GetParentInfo(CurrentScanNumber.Value).ParentMass;
                //}

                List<double> modifications = new List<double>();
                //modifications.Add(18.0105);
                ModificationsList mdf = new ModificationsList();
                mdf.ScanNumbers = "";
                sqsalldenovotgs = FindAllSequenceTagsWithoutModifications(CurrentIons, modifications, ref mdf, sequencetagmass, true);
                sqsalldenovotgs.AddRange(FindAllSequenceTagsWithoutModifications(CurrentIons, modifications, ref mdf, sequencetagmass, false));
                sqsalldenovotgs = sqsalldenovotgs.GroupBy(a => (a.RawSequence + Convert.ToString(a.Start))).Select(a => a.First()).ToList();
                sqsalldenovotgs = sqsalldenovotgs.Where(a => a.Sequence.Length >= Properties.Settings.Default.SequenceTagLength).ToList();

                dtgrdtxtDbHits.Visibility = System.Windows.Visibility.Visible;

                if (!Properties.Settings.Default.CountBlastHits)
                {
                    if (Properties.Settings.Default.UseBlast)
                    {
                        dtgrdtxtDbHits.Visibility = System.Windows.Visibility.Hidden;
                    }
                }



                if (DechargerVM.UseFasta)
                {
                    // A worker thread is created in order perform the database search to find if the sequence tag is a valid tag or not.
                    BackgroundWorker bgsequencesearchinfasta = new BackgroundWorker();
                    bgsequencesearchinfasta.DoWork += bgsequencesearchinfasta_DoWork;
                    bgsequencesearchinfasta.RunWorkerCompleted += bgsequencesearchindb_RunWorkerCompleted;

                    SequenceBusyIndicator.IsBusy = true;
                    btnFindAA.Visibility = System.Windows.Visibility.Collapsed;

                    Debug.WriteLine("btnFindAA_Click1 - Tag count: " + sqsalldenovotgs.Count);


                    bgsequencesearchinfasta.RunWorkerAsync(sqsalldenovotgs);
                }
                else if (NetworkInterface.GetIsNetworkAvailable() && string.IsNullOrWhiteSpace(db.DataSource) == false)
                { //TODO: need a better way of detecting no SQL Server...
                    // A worker thread is created in order perform the database search to find if the sequence tag is a valid tag or not.
                    BackgroundWorker bgsequencesearchindb = new BackgroundWorker();
                    bgsequencesearchindb.DoWork += bgsequencesearchindb_DoWork;
                    bgsequencesearchindb.RunWorkerCompleted += bgsequencesearchindb_RunWorkerCompleted;

                    SequenceBusyIndicator.IsBusy = true;
                    btnFindAA.Visibility = System.Windows.Visibility.Collapsed;

                    Debug.WriteLine("btnFindAA_Click2 - Tag count: " + sqsalldenovotgs.Count);
                    bgsequencesearchindb.RunWorkerAsync(sqsalldenovotgs);
                }
                else
                {
                    Dispatcher.Invoke(new Action(() =>
                    {
                        dtgridsequences.DataContext = null;
                        sqsalldenovotgs = sqsalldenovotgs.OrderByDescending(a => a.Sequence.Length).ToList();
                        dtgridsequences.DataContext = sqsalldenovotgs.Where(a => a.Sequence.Length >= Properties.Settings.Default.SequenceTagLength).ToList(); /// FindAllSequenceTags(CurrentIons, sequencetagmass).OrderByDescending(a => a.Sequence.Length).ToList();
                        dtgridsequences.Visibility = System.Windows.Visibility.Visible;
                        btnMatch.IsEnabled = true;
                        txtMatchSequence.IsEnabled = true;
                        btnFindAA.Content = "Find Sequence Tags";
                        btnFindAA.Visibility = System.Windows.Visibility.Collapsed;
                        SequenceBusyIndicator.IsBusy = false;
                        //DechargerVM = new DeChargerViewModel();
                        //this.DataContext = this.DataContext ?? new DeChargerViewModel();
                    }));
                    Findtags();
                }
            }
            Dispatcher.Invoke((Action)(() =>
            {
                btnFindAA.Visibility = System.Windows.Visibility.Hidden;
            }));
        }

        private void Findtags()
        {
            using (new WaitCursor())
            {
                if (CurrentSpectrum.ParentIon != null) FindNewSequences2();
            }
        }

        string sequen = string.Empty;
        //string newsequenwithgaps = string.Empty;
        List<double> IonsforSqDBMatch = new List<double>();
        private void Findnewsequences()
        {
            var maxAminoAcidMass = MassLookup.MaxBy(a => a.Key).Key;

            var m = CurrentMonos.Where(a => Convert.ToDouble(a.XValue) <= CurrentSpectrum.ParentIon.MonoMass).OrderByDescending(a => a.XValue).ToList();
            var cmm = CurrentMonos.OrderByDescending(a => a.XValue).ToList();
            var sm = SecondaryCurrentMonos.Where(a => Convert.ToDouble(a.XValue) <= CurrentSpectrum.ParentIon.MonoMass).OrderByDescending(a => a.XValue).ToList();
            sequen = string.Empty;
            double total = 0;
            double priortotal = 0;
            int i = 0;
            int ck = 1;
            foreach (MonoPeak cm in m)
            {
                if (ck > 1)
                {
                    i++;
                    ck--;
                    continue;
                }

                foreach (MonoPeak im in m.Skip(i + 1))
                {
                    int j = i;
                    if (im.XValue >= cm.XValue)
                    {
                        j++;
                        continue;
                    }

                    //double dif = PPM.MaxPPM(Math.Min(cm.XValue, im.XValue), Math.Max(cm.XValue, im.XValue));
                    double dif = PPMCalc.MaxPPM(im.XValue, cm.XValue);

                    //if (((cm.XValue - im.XValue) + dif) > maxAminoAcidMass) break;

                    var match = from ma in MassLookup
                                let difference = Math.Abs(ma.Key - (cm.XValue - im.XValue))
                                where difference <= dif
                                orderby difference
                                select new { Name = ma.Value, Delta = difference, Start = im.XValue, End = cm.XValue, StartScore = im.Score, EndScore = cm.Score, StartCharge = cm.XValue <= im.XValue ? cm.Charge : im.Charge, EndCharge = cm.XValue > im.XValue ? cm.Charge : im.Charge };

                    var secondaryindexi = sm.Where(k => k.Index == m[i].Index);
                    var secondaryindexj = sm.Where(k => k.Index == m[j].Index);

                    bool sei = secondaryindexi.Any();

                    var secondarymatch = (from ma in MassLookup
                                          let difference = sei != true ? 999 : Math.Abs(ma.Key - Math.Abs(secondaryindexi.First().XValue - secondaryindexj.First().XValue))
                                          where difference <= dif
                                          orderby difference
                                          select new { Name = ma.Value, Delta = difference, Start = sei != true ? 0 : Math.Min(secondaryindexi.First().XValue, secondaryindexj.First().XValue), End = sei != true ? 0 : Math.Max(secondaryindexi.First().XValue, (secondaryindexj.First().XValue)), StartScore = secondaryindexj.First().Score, EndScore = secondaryindexi.First().Score, StartCharge = secondaryindexi.First().XValue <= secondaryindexj.First().XValue ? secondaryindexi.First().Charge : secondaryindexj.First().Charge, EndCharge = secondaryindexi.First().XValue > secondaryindexj.First().XValue ? secondaryindexi.First().Charge : secondaryindexj.First().Charge });

                    //var x = MassLookup.MaxBy(a => a.Key).Key;

                    if (MassLookup.MaxBy(a => a.Key).Key > Math.Abs(Convert.ToDouble(cm.XValue) - Convert.ToDouble(im.XValue)))
                    {
                        if (match.Any() && secondarymatch.Any())
                        {
                            if (match.First().Delta > secondarymatch.First().Delta)
                            {
                                sequen += " " + secondarymatch.First().Name + " Sec ";
                                lastbar.Start = secondarymatch.First().Start;
                                lastbar.End = secondarymatch.First().End;
                                lastbar.Name = secondarymatch.First().Name + " Sec ";
                                priortotal = total;
                                total = total + Math.Abs(secondarymatch.First().Start - secondarymatch.First().End);
                                aai.Add(new AminoAcidIndex
                                {
                                    Totaltillnow = total,
                                    Value = secondarymatch.First().Name + " Sec ",
                                    End = secondarymatch.First().End,
                                    Start = secondarymatch.First().Start,
                                    StartCharge = secondarymatch.First().StartCharge,
                                    EndCharge = secondarymatch.First().EndCharge
                                });
                                AddRangeNewSequence();
                                break;
                            }
                            else if (match.First().Delta <= secondarymatch.First().Delta)
                            {
                                sequen += " " + match.First().Name;
                                lastbar.Start = match.First().Start;
                                lastbar.End = match.First().End;
                                lastbar.Name = match.First().Name;
                                priortotal = total;
                                total = total + Math.Abs(match.First().Start - match.First().End);
                                aai.Add(new AminoAcidIndex
                                {
                                    Totaltillnow = total,
                                    Value = match.First().Name,
                                    End = match.First().End,
                                    Start = match.First().Start,
                                    StartCharge = match.First().StartCharge,
                                    EndCharge = match.First().EndCharge
                                });
                                AddRangeNewSequence();
                                break;
                            }
                        }
                        else if (match.Any())
                        {
                            sequen += " " + match.First().Name;
                            lastbar.Start = match.First().Start;
                            lastbar.End = match.First().End;
                            lastbar.Name = match.First().Name;
                            priortotal = total;
                            total = total + Math.Abs(match.First().Start - match.First().End);
                            aai.Add(new AminoAcidIndex
                            {
                                Totaltillnow = total,
                                Value = match.First().Name,
                                End = match.First().End,
                                Start = match.First().Start,
                                StartCharge = match.First().StartCharge,
                                EndCharge = match.First().EndCharge
                            });
                            AddRangeNewSequence();
                            break;
                        }
                        else if (secondarymatch.Any())
                        {
                            sequen += " " + secondarymatch.First().Name + " Sec ";
                            lastbar.Start = secondarymatch.First().Start;
                            lastbar.End = secondarymatch.First().End;
                            lastbar.Name = secondarymatch.First().Name + " Sec ";
                            priortotal = total;
                            total = total + Math.Abs(secondarymatch.First().Start - secondarymatch.First().End);
                            aai.Add(new AminoAcidIndex
                            {
                                Totaltillnow = total,
                                Value = secondarymatch.First().Name + " Sec ",
                                End = secondarymatch.First().End,
                                Start = secondarymatch.First().Start,
                                StartCharge = secondarymatch.First().StartCharge,
                                EndCharge = secondarymatch.First().EndCharge
                            });
                            AddRangeNewSequence();
                            break;
                        }
                    }
                    else if (ComboMassLookup.MaxBy(a => a.Key).Key > Math.Abs((cm.XValue) - (im.XValue)))
                    {
                        match = from ma in ComboMassLookup
                                let difference = Math.Abs(ma.Key - Math.Abs(cm.XValue - im.XValue))
                                where difference <= dif
                                orderby difference
                                select new { Name = ma.Value, Delta = difference, Start = Math.Min(cm.XValue, im.XValue), End = Math.Max(cm.XValue, im.XValue), StartScore = im.Score, EndScore = cm.Score, StartCharge = cm.XValue <= im.XValue ? cm.Charge : im.Charge, EndCharge = cm.XValue > im.XValue ? cm.Charge : im.Charge };


                        secondarymatch = (from ma in ComboMassLookup
                                          let difference = sei != true ? 999 : Math.Abs(ma.Key - Math.Abs(secondaryindexi.First().XValue - secondaryindexj.First().XValue))
                                          where difference <= dif
                                          orderby difference
                                          select new { Name = ma.Value, Delta = difference, Start = Math.Min(secondaryindexi.First().XValue, secondaryindexj.First().XValue), End = Math.Max(secondaryindexi.First().XValue, secondaryindexj.First().XValue), StartScore = secondaryindexj.First().Score, EndScore = secondaryindexi.First().Score, StartCharge = secondaryindexi.First().XValue <= secondaryindexj.First().XValue ? secondaryindexi.First().Charge : secondaryindexj.First().Charge, EndCharge = secondaryindexi.First().XValue > secondaryindexj.First().XValue ? secondaryindexi.First().Charge : secondaryindexj.First().Charge });

                        if (match.Any() && secondarymatch.Any())
                        {
                            if (match.First().Delta > secondarymatch.First().Delta)
                            {
                                sequen += " " + secondarymatch.First().Name + " Sec ";
                                lastbar.Start = secondarymatch.First().Start;
                                lastbar.End = secondarymatch.First().End;
                                lastbar.Name = secondarymatch.First().Name + " Sec ";
                                priortotal = total;
                                total = total + Math.Abs(secondarymatch.First().Start - secondarymatch.First().End);
                                aai.Add(new AminoAcidIndex
                                {
                                    Totaltillnow = total,
                                    Value = secondarymatch.First().Name + " Sec ",
                                    End = secondarymatch.First().End,
                                    Start = secondarymatch.First().Start,
                                    StartCharge = secondarymatch.First().StartCharge,
                                    EndCharge = secondarymatch.First().EndCharge
                                });
                                AddRangeNewSequence();
                                break;
                            }
                            else if (match.First().Delta <= secondarymatch.First().Delta)
                            {
                                sequen += " " + match.First().Name;
                                lastbar.Start = match.First().Start;
                                lastbar.End = match.First().End;
                                lastbar.Name = match.First().Name;
                                priortotal = total;
                                total = total + Math.Abs(match.First().Start - match.First().End);
                                aai.Add(new AminoAcidIndex
                                {
                                    Totaltillnow = total,
                                    Value = match.First().Name,
                                    End = match.First().End,
                                    Start = match.First().Start,
                                    StartCharge = match.First().StartCharge,
                                    EndCharge = match.First().EndCharge
                                });
                                AddRangeNewSequence();
                                break;
                            }
                        }
                        else if (match.Any())
                        {
                            sequen += " " + match.First().Name;
                            lastbar.Start = match.First().Start;
                            lastbar.End = match.First().End;
                            lastbar.Name = match.First().Name;
                            priortotal = total;
                            total = total + Math.Abs(match.First().Start - match.First().End);
                            aai.Add(new AminoAcidIndex
                            {
                                Totaltillnow = total,
                                Value = match.First().Name,
                                End = match.First().End,
                                Start = match.First().Start,
                                StartCharge = match.First().StartCharge,
                                EndCharge = match.First().EndCharge
                            });
                            AddRangeNewSequence();
                            break;
                        }
                        else if (secondarymatch.Any())
                        {
                            sequen += " " + secondarymatch.First().Name + " Sec ";
                            lastbar.Start = secondarymatch.First().Start;
                            lastbar.End = secondarymatch.First().End;
                            lastbar.Name = secondarymatch.First().Name + " Sec ";
                            priortotal = total;
                            total = total + Math.Abs(secondarymatch.First().Start - secondarymatch.First().End);
                            aai.Add(new AminoAcidIndex
                            {
                                Totaltillnow = total,
                                Value = secondarymatch.First().Name + " Sec ",
                                End = secondarymatch.First().End,
                                Start = secondarymatch.First().Start,
                                StartCharge = secondarymatch.First().StartCharge,
                                EndCharge = secondarymatch.First().EndCharge
                            });
                            AddRangeNewSequence();
                            break;
                        }
                    }
                    else
                    {
                        sequen += " " + Convert.ToString(Math.Abs(cm.XValue - im.XValue));
                        priortotal = total;
                        total = total + Math.Abs(cm.XValue - im.XValue);
                        aag.Add(new AminoAcidGap
                        {
                            EndValue = Math.Max(cm.XValue, im.XValue),
                            StartValue = Math.Min(cm.XValue, im.XValue),
                            Gap = Math.Abs(cm.XValue - im.XValue),
                            StartPosition = priortotal,
                            EndPosition = total,
                            StartCharge = cm.XValue <= im.XValue ? cm.Charge : im.Charge,
                            EndCharge = cm.XValue > im.XValue ? cm.Charge : im.Charge
                        });
                        aai.Add(new AminoAcidIndex
                        {
                            Totaltillnow = total,
                            Value = Convert.ToString(Math.Abs(cm.XValue - im.XValue))
                        });
                        break;
                    }
                    j++;
                    ck++;
                }
                i++;
            }
            //FindReverseSequence();

        }


        private void FindNewSequences2()
        {
            var m = CurrentMonos.Where(a => Convert.ToDouble(a.XValue) <= CurrentSpectrum.ParentIon.MonoMass).OrderByDescending(a => a.XValue).ToList();
            var cmm = CurrentMonos.OrderByDescending(a => a.XValue).ToList();
            var sm = SecondaryCurrentMonos.Where(a => Convert.ToDouble(a.XValue) <= CurrentSpectrum.ParentIon.MonoMass).OrderByDescending(a => a.XValue).ToList();
            string sequen = string.Empty;
            double total = 0;
            double priortotal = 0;
            double lastPosition = double.MaxValue;



            // Combine the Single and 2 AminoAcid Mass Lists
            //var combinedMassLookup = MassLookup.Concat(ComboMassLookup).GroupBy(d => d.Key)
            //                         .ToDictionary(d => d.Key, d => string.Join(" or ", d));

            var maxAminoAcidMass = ComboMassLookup.MaxBy(p => p.Key).Key;
            var minAminoAcidMass = MassLookup.MinBy(p => p.Key).Key;
            var minAminoAcidComboMass = ComboMassLookup.MinBy(p => p.Key).Key;
            //newsequenwithgaps = string.Empty;
            aminoacidsforsequence.Clear();

            FlagMassLookup.Clear();
            FlagMassLookup.Add(Molecules.Water, "Water Loss");

            foreach (var cm in CurrentIons.Where(i => i.MonoMass <= CurrentSpectrum.ParentIon.MonoMass).OrderByDescending(j => j.MonoMass))
            {
                double dif = PPMCalc.CurrentPPM(cm.MonoMass, Properties.Settings.Default.MatchTolerancePPM);

                if (cm.MonoMass - dif > lastPosition) continue;

                var bestMatches = new List<AminoAcidMatch>();

                foreach (var im in CurrentIons.Where(p => p.MonoMass < cm.MonoMass).OrderByDescending(j => j.MonoMass))
                {
                    //double dif = PPM.MaxPPM(Math.Min(cm.XValue, im.XValue), Math.Max(cm.XValue, im.XValue));

                    if (((cm.MonoMass - im.MonoMass) - dif) > maxAminoAcidMass || ((cm.MonoMass - im.MonoMass) + dif) < minAminoAcidMass) continue;

                    // Find all the best matches
                    var matches = from ma in MassLookup
                                  let difference = Math.Abs(ma.Key - (cm.MonoMass - im.MonoMass))
                                  where difference <= dif
                                  //orderby difference
                                  select new AminoAcidMatch { Name = ma.Value, Mass = ma.Key, Start = cm, End = im };

                    if (((cm.MonoMass - im.MonoMass) - dif) > minAminoAcidComboMass)
                    {
                        matches = from ma in ComboMassLookup
                                  let difference = Math.Abs(ma.Key - (cm.MonoMass - im.MonoMass))
                                  where difference <= dif
                                  //orderby difference
                                  select new AminoAcidMatch { Name = ma.Value, Mass = ma.Key, Start = cm, End = im };
                    }

                    bestMatches.AddRange(matches);
                }


                if (bestMatches.Any())
                {
                    var singleAaMatches = bestMatches.Where(p => p.Name.Length == 1);
                    AminoAcidMatch bestMatch = null;

                    foreach (var aMatch in singleAaMatches)
                    {
                        // Boost score if the proposed Amino Acid extends the sequence further
                        if (bestMatches.Where(p => p.Name.Length > 1 && p.Name.Contains(aMatch.Name)).Any()) aMatch.ScoreBooster++;


                        // Boost score if the proposed Amino Acid has a water loss
                        foreach (var aFlag in FlagMassLookup)
                        {
                            var flagHits = CurrentIons.Where(p => (p.MonoMass < (aMatch.End.MonoMass - aFlag.Key) + dif) && (p.MonoMass > (aMatch.End.MonoMass - aFlag.Key) - dif));

                            if (flagHits.Any()) aMatch.ScoreBooster++;
                        }
                    }

                    if (singleAaMatches.Any())
                        bestMatch = singleAaMatches.OrderByDescending(p => p.End.Intensity * (1d / p.Delta) * p.ScoreBooster).FirstOrDefault();
                    else
                        bestMatch = bestMatches.MinBy(p => p.Delta);

                    // Boost score if the proposed Amino Acid has a water loss
                    foreach (var aFlag in FlagMassLookup)
                    {
                        var flagHits = CurrentIons.Where(p => (p.MonoMass < (bestMatch.End.MonoMass - aFlag.Key) + dif) && (p.MonoMass > (bestMatch.End.MonoMass - aFlag.Key) - dif));

                        if (flagHits.Any())
                            AddAnnotationBar(WaterLossSeries, new AnnotationBar() { Start = flagHits.First().MonoMass, End = bestMatch.End.MonoMass }, null, false, 10.3f);
                    }

                    sequen += " " + bestMatch.Name;

                    //lastbar.Start = bestMatch.Start;
                    //lastbar.End = bestMatch.End;
                    //lastbar.Name = bestMatch.Name;
                    priortotal = total;

                    total = total + Math.Abs(bestMatch.Start.MonoMass - bestMatch.End.MonoMass);

                    aai.Add(new AminoAcidIndex
                    {
                        Totaltillnow = total,
                        Value = bestMatch.Name,
                        End = bestMatch.End.MonoMass,
                        Start = bestMatch.Start.MonoMass,
                        //StartCharge = secondarymatch.First().StartCharge,
                        //EndCharge = secondarymatch.First().EndCharge
                    });

                    aaiforsequencematches.Add(new AminoAcidIndex
                    {
                        Totaltillnow = total,
                        Value = bestMatch.Name.Contains("+") ? " " + Convert.ToString(Math.Abs(bestMatch.End.MonoMass - bestMatch.Start.MonoMass)) + " " : bestMatch.Name,
                        End = bestMatch.End.MonoMass,
                        Start = bestMatch.Start.MonoMass
                    });

                    aminoacidsforsequence.Add(new MainSequenceTagmatches
                    {
                        End = bestMatch.End.MonoMass,
                        Start = bestMatch.Start.MonoMass,
                        MassDiff = Math.Abs(bestMatch.End.MonoMass - bestMatch.Start.MonoMass),
                        Seq = bestMatch.Name.Contains("+") ? Convert.ToString(Math.Abs(bestMatch.End.MonoMass - bestMatch.Start.MonoMass)) : bestMatch.Name
                    });


                    AddRangeNewSequence(new AnnotationBar() { Name = bestMatch.Name, Start = bestMatch.Start.MonoMass, End = bestMatch.End.MonoMass });

                    lastPosition = bestMatch.End.MonoMass;
                }
            }

            if (!aminoacidsforsequence.Any()) return;

            int aminocount = 1;
            double end = aminoacidsforsequence.First().End;
            List<MainSequenceTagmatches> tempaminoacidsforseq = new List<MainSequenceTagmatches>();
            foreach (MainSequenceTagmatches aminoacid in aminoacidsforsequence.GetRange(1, aminoacidsforsequence.Count - 1))
            {
                if (end == aminoacid.Start)
                {
                    end = aminoacid.End;
                }
                else
                {
                    tempaminoacidsforseq.Add(new MainSequenceTagmatches
                    {
                        Start = aminoacidsforsequence[aminocount - 1].End,
                        MassDiff = (end - aminoacid.Start),
                        Seq = Convert.ToString(Math.Abs(end - aminoacid.Start)),
                        End = aminoacid.Start
                    });
                    end = aminoacid.End;
                }
                aminocount++;
            }
            aminoacidsforsequence.AddRange(tempaminoacidsforseq);
            aminoacidsforsequence = aminoacidsforsequence.OrderBy(a => a.Start).ToList();
            var regex = new Regex(@"^-*[0-9,\.]+$");
            //foreach (MainSequenceTagmatches am in aminoacidsforsequence)
            //{
            //    newsequenwithgaps += regex.IsMatch(am.Seq) ? " " : am.Seq;
            //}
            //char[] rev = newsequenwithgaps.ToCharArray();
            //Array.Reverse(rev);
            //newsequenwithgaps = new string(rev);
        }

        private List<MainSequenceTagmatches> FindNewSequences3(Spectrum spectrum, List<MonoPeak> monoPeaks, List<Cluster> ions)
        {
            var m = monoPeaks.Where(a => Convert.ToDouble(a.XValue) <= spectrum.ParentIon.MonoMass).OrderByDescending(a => a.XValue).ToList();
            var cmm = monoPeaks.OrderByDescending(a => a.XValue).ToList();
            //var sm = SecondaryCurrentMonos.Where(a => Convert.ToDouble(a.XValue) <= spectrum.ParentIon.MonoMass).OrderByDescending(a => a.XValue).ToList();
            string sequen = string.Empty;
            double total = 0;
            double priortotal = 0;
            double lastPosition = double.MaxValue;

            var returnTags = new List<MainSequenceTagmatches>();

            // Combine the Single and 2 AminoAcid Mass Lists
            //var combinedMassLookup = MassLookup.Concat(ComboMassLookup).GroupBy(d => d.Key)
            //                         .ToDictionary(d => d.Key, d => string.Join(" or ", d));

            var maxAminoAcidMass = ComboMassLookup.MaxBy(p => p.Key).Key;
            var minAminoAcidMass = MassLookup.MinBy(p => p.Key).Key;
            var minAminoAcidComboMass = ComboMassLookup.MinBy(p => p.Key).Key;
            //newsequenwithgaps = string.Empty;
            returnTags.Clear();

            FlagMassLookup.Clear();
            FlagMassLookup.Add(Molecules.Water, "Water Loss");

            foreach (var cm in ions.Where(i => i.MonoMass <= spectrum.ParentIon.MonoMass).OrderByDescending(j => j.MonoMass))
            {
                double dif = PPMCalc.CurrentPPM(cm.MonoMass, Properties.Settings.Default.MatchTolerancePPM);

                if (cm.MonoMass - dif > lastPosition) continue;

                var bestMatches = new List<AminoAcidMatch>();

                foreach (var im in ions.Where(p => p.MonoMass < cm.MonoMass).OrderByDescending(j => j.MonoMass))
                {
                    //double dif = PPM.MaxPPM(Math.Min(cm.XValue, im.XValue), Math.Max(cm.XValue, im.XValue));

                    if (((cm.MonoMass - im.MonoMass) - dif) > maxAminoAcidMass || ((cm.MonoMass - im.MonoMass) + dif) < minAminoAcidMass) continue;

                    // Find all the best matches
                    var matches = from ma in MassLookup
                                  let difference = Math.Abs(ma.Key - (cm.MonoMass - im.MonoMass))
                                  where difference <= dif
                                  //orderby difference
                                  select new AminoAcidMatch { Name = ma.Value, Mass = ma.Key, Start = cm, End = im };

                    if (((cm.MonoMass - im.MonoMass) - dif) > minAminoAcidComboMass)
                    {
                        matches = from ma in ComboMassLookup
                                  let difference = Math.Abs(ma.Key - (cm.MonoMass - im.MonoMass))
                                  where difference <= dif
                                  //orderby difference
                                  select new AminoAcidMatch { Name = ma.Value, Mass = ma.Key, Start = cm, End = im };
                    }

                    bestMatches.AddRange(matches);
                }


                if (bestMatches.Any())
                {
                    var singleAaMatches = bestMatches.Where(p => p.Name.Length == 1);
                    AminoAcidMatch bestMatch = null;

                    foreach (var aMatch in singleAaMatches)
                    {
                        // Boost score if the proposed Amino Acid extends the sequence further
                        if (bestMatches.Where(p => p.Name.Length > 1 && p.Name.Contains(aMatch.Name)).Any()) aMatch.ScoreBooster++;


                        // Boost score if the proposed Amino Acid has a water loss
                        foreach (var aFlag in FlagMassLookup)
                        {
                            var flagHits = ions.Where(p => (p.MonoMass < (aMatch.End.MonoMass - aFlag.Key) + dif) && (p.MonoMass > (aMatch.End.MonoMass - aFlag.Key) - dif));

                            if (flagHits.Any()) aMatch.ScoreBooster++;
                        }
                    }

                    if (singleAaMatches.Any())
                        bestMatch = singleAaMatches.OrderByDescending(p => p.End.Intensity * (1d / p.Delta) * p.ScoreBooster).FirstOrDefault();
                    else
                        bestMatch = bestMatches.MinBy(p => p.Delta);

                    // Boost score if the proposed Amino Acid has a water loss
                    foreach (var aFlag in FlagMassLookup)
                    {
                        var flagHits = ions.Where(p => (p.MonoMass < (bestMatch.End.MonoMass - aFlag.Key) + dif) && (p.MonoMass > (bestMatch.End.MonoMass - aFlag.Key) - dif));

                        if (flagHits.Any())
                            AddAnnotationBar(WaterLossSeries, new AnnotationBar() { Start = flagHits.First().MonoMass, End = bestMatch.End.MonoMass }, null, false, 10.3f);
                    }

                    sequen += " " + bestMatch.Name;

                    //lastbar.Start = bestMatch.Start;
                    //lastbar.End = bestMatch.End;
                    //lastbar.Name = bestMatch.Name;
                    priortotal = total;

                    total = total + Math.Abs(bestMatch.Start.MonoMass - bestMatch.End.MonoMass);

                    aai.Add(new AminoAcidIndex
                    {
                        Totaltillnow = total,
                        Value = bestMatch.Name,
                        End = bestMatch.End.MonoMass,
                        Start = bestMatch.Start.MonoMass,
                        //StartCharge = secondarymatch.First().StartCharge,
                        //EndCharge = secondarymatch.First().EndCharge
                    });

                    aaiforsequencematches.Add(new AminoAcidIndex
                    {
                        Totaltillnow = total,
                        Value = bestMatch.Name.Contains("+") ? " " + Convert.ToString(Math.Abs(bestMatch.End.MonoMass - bestMatch.Start.MonoMass)) + " " : bestMatch.Name,
                        End = bestMatch.End.MonoMass,
                        Start = bestMatch.Start.MonoMass
                    });

                    returnTags.Add(new MainSequenceTagmatches
                    {
                        End = bestMatch.End.MonoMass,
                        Start = bestMatch.Start.MonoMass,
                        MassDiff = Math.Abs(bestMatch.End.MonoMass - bestMatch.Start.MonoMass),
                        Seq = bestMatch.Name.Contains("+") ? Convert.ToString(Math.Abs(bestMatch.End.MonoMass - bestMatch.Start.MonoMass)) : bestMatch.Name
                    });


                    AddRangeNewSequence(new AnnotationBar() { Name = bestMatch.Name, Start = bestMatch.Start.MonoMass, End = bestMatch.End.MonoMass });

                    lastPosition = bestMatch.End.MonoMass;
                }
            }

            if (!returnTags.Any()) return returnTags;

            int aminocount = 1;
            double end = returnTags.First().End;
            List<MainSequenceTagmatches> tempaminoacidsforseq = new List<MainSequenceTagmatches>();
            foreach (MainSequenceTagmatches aminoacid in returnTags.GetRange(1, returnTags.Count - 1))
            {
                if (end == aminoacid.Start)
                {
                    end = aminoacid.End;
                }
                else
                {
                    tempaminoacidsforseq.Add(new MainSequenceTagmatches
                    {
                        Start = returnTags[aminocount - 1].End,
                        MassDiff = (end - aminoacid.Start),
                        Seq = Convert.ToString(Math.Abs(end - aminoacid.Start)),
                        End = aminoacid.Start
                    });
                    end = aminoacid.End;
                }
                aminocount++;
            }
            returnTags.AddRange(tempaminoacidsforseq);
            returnTags = returnTags.OrderBy(a => a.Start).ToList();
            var regex = new Regex(@"^-*[0-9,\.]+$");
            //foreach (MainSequenceTagmatches am in returnTags)
            //{
            //    newsequenwithgaps += regex.IsMatch(am.Seq) ? " " : am.Seq;
            //}
            //char[] rev = newsequenwithgaps.ToCharArray();
            //Array.Reverse(rev);
            //newsequenwithgaps = new string(rev);

            return returnTags;
        }


        bool reversesequence = false;

        /// <summary>
        /// Based on the sequence obtained from the Parent mass
        /// verifying if there is a sequence possible in the 
        /// reverse direction.
        /// If the same elements are found in the reverse direction
        /// then it really confident in those regions.
        /// And hence the scoring can be improved in those regions.
        /// </summary>
        private void FindReverseSequence()
        {
            int i = 0;
            double currenttotal = 0.0d;
            foreach (AminoAcidIndex a in aai)
            {
                if (currenttotal > a.Totaltillnow)
                {
                    i++;
                    continue;
                }
                double dif = PPMCalc.MaxPPM(a.Totaltillnow, currenttotal, Properties.Settings.Default.MatchTolerancePPM); //, a.EndCharge, a.StartCharge);

                //double dif = (Properties.Settings.Default.MatchTolerancePPM / 1e6d) * (cm.MonoMass);

                //double dif = ((Properties.Settings.Default.MassTolerancePPM / 1e6d) *  (a.Totaltillnow / a.EndCharge));
                var currentmono = from cm in CurrentMonos
                                  let difference = Math.Abs(cm.XValue - a.Totaltillnow)
                                  where difference <= dif
                                  select cm;

                if (currentmono.Count() > 0)
                {
                    foreach (AminoAcidIndex aa in aai.Skip(i + 1))
                    {
                        var match = from ma in MassLookup
                                    let difference = Math.Abs(ma.Key - Math.Abs(a.Totaltillnow - aa.Totaltillnow))
                                    where difference <= dif
                                    orderby difference
                                    select new { Name = ma.Value, Delta = difference, Start = ((double)aa.Start), End = ((double)aa.End) };

                        if (match.Any())
                        {
                            lastbar.Start = match.First().Start;
                            lastbar.End = match.First().End;
                            lastbar.Name = match.First().Name;
                            currenttotal = Math.Max((double)a.Totaltillnow, ((double)aa.Totaltillnow));
                            reversesequence = true;
                            AddRangeNewSequence();
                            break;
                        }
                        else if (!(ComboMassLookup.MaxBy(x => x.Key).Key > Math.Abs(a.Totaltillnow - aa.Totaltillnow)))
                        {
                            break;
                        }
                    }
                }
                i++;
            }
            FindGaps();
        }

        /// <summary>
        /// Once sequencing in the reverse direction 
        /// is done, the gaps in the sequence will be
        /// filled in using the data from the monos
        /// in the forward direction
        /// </summary>
        private void FindGaps()
        {
            foreach (AminoAcidGap a in aag)
            {
                var monogap = from cm in CurrentMonos
                              where cm.XValue >= a.StartPosition && cm.XValue <= a.EndPosition
                              select cm;

                if (monogap.Count() > 0)
                {
                    foreach (var c in monogap)
                    {
                        double dif = PPMCalc.MaxPPM(Math.Min(c.XValue, (a.EndPosition)), Math.Max(c.XValue, (a.EndPosition)), Properties.Settings.Default.MatchTolerancePPM); //, c.XValue <= a.EndPosition ? c.Charge : a.EndCharge, c.XValue > a.EndPosition ? c.Charge : a.EndCharge);



                        //double dif = Math.Max(Math.Min(c.XValue, (a.EndPosition)), Math.Max(c.XValue, (a.EndPosition)));
                        var match = from ma in MassLookup
                                    let difference = Math.Abs(ma.Key - Math.Abs(c.XValue - a.EndPosition))
                                    where difference <= dif
                                    orderby difference
                                    select new { Name = ma.Value, Delta = difference, Start = Math.Min(c.XValue, a.EndPosition), End = Math.Max(c.XValue, a.EndPosition) };

                        if (match.Any())
                        {
                            lastbar.End = match.First().End;
                            lastbar.Start = match.First().Start;
                            lastbar.Name = match.First().Name;
                            AddGapSequence();

                            var match1 = from ma in MassLookup
                                         let difference = Math.Abs(ma.Key - Math.Abs(Convert.ToDouble(a.StartPosition) - Convert.ToDouble(lastbar.Start)))
                                         where difference <= dif
                                         orderby difference
                                         select new { Name = ma.Value, Delta = difference, Start = Math.Min(a.StartPosition, lastbar.Start), End = Math.Max(a.StartPosition, lastbar.Start) };

                            if (match1.Any())
                            {
                                lastbar.Name = match1.First().Name;
                                lastbar.End = match1.First().End;
                                lastbar.Start = match1.First().Start;

                                AddGapSequence();
                            }
                            else
                            {
                                var match2 = from ma in ComboMassLookup
                                             let difference = Math.Abs(ma.Key - Math.Abs(a.StartPosition - lastbar.Start))
                                             where difference <= dif
                                             orderby difference
                                             select new { Name = ma.Value, Delta = difference, Start = Math.Min(a.StartPosition, lastbar.Start), End = Math.Max(a.StartPosition, lastbar.Start) };

                                if (match2.Any())
                                {
                                    lastbar.Name = match2.First().Name;
                                    lastbar.End = match2.First().End;
                                    lastbar.Start = match2.First().Start;

                                    AddGapSequence();
                                }
                            }
                        }

                        else
                        {
                            var secondarymatch = from ma in ComboMassLookup
                                                 let difference = Math.Abs(ma.Key - Math.Abs(c.XValue - a.EndPosition))
                                                 where difference <= dif
                                                 orderby difference
                                                 select new { Name = ma.Value, Delta = difference, Start = Math.Min(c.XValue, a.EndPosition), End = Math.Max(c.XValue, a.EndPosition) };

                            if (secondarymatch.Any())
                            {
                                lastbar.End = secondarymatch.First().End;
                                lastbar.Start = secondarymatch.First().Start;
                                lastbar.Name = secondarymatch.First().Name;
                                AddGapSequence();

                                var secondarymatch1 = from ma in MassLookup
                                                      let difference = Math.Abs(ma.Key - Math.Abs(a.StartPosition - lastbar.Start))
                                                      where difference <= dif
                                                      orderby difference
                                                      select new { Name = ma.Value, Delta = difference, Start = Math.Min(a.StartPosition, lastbar.Start), End = Math.Max(a.StartPosition, lastbar.Start) };

                                if (secondarymatch1.Any())
                                {
                                    lastbar.Name = secondarymatch1.First().Name;
                                    lastbar.End = secondarymatch1.First().End;
                                    lastbar.Start = secondarymatch1.First().Start;
                                    AddGapSequence();
                                }
                                else
                                {
                                    var secondarymatch2 = from ma in ComboMassLookup
                                                          let difference = Math.Abs(ma.Key - Math.Abs(a.StartPosition - lastbar.Start))
                                                          where difference <= dif
                                                          orderby difference
                                                          select new { Name = ma.Value, Delta = difference, Start = Math.Min(a.StartPosition, lastbar.Start), End = Math.Max(a.StartPosition, lastbar.Start) };

                                    if (secondarymatch2.Any())
                                    {
                                        lastbar.Name = secondarymatch2.First().Name;
                                        lastbar.End = secondarymatch2.First().End;
                                        lastbar.Start = secondarymatch2.First().Start;
                                        AddGapSequence();
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        List<FindSequenceTags.SequenceTag> publicseq = new List<FindSequenceTags.SequenceTag>();
        // List<FindSequenceTags.SequenceTag> revseq = new List<FindSequenceTags.SequenceTag>();

        private List<FindSequenceTags.SequenceTag> FindAllSequenceTags(IEnumerable<Cluster> ions, double parentMass = double.NaN) //, bool allsequencetags
        {
            var seq = new List<FindSequenceTags.SequenceTag>();

            //currentTags.Clear();
            List<InitialAA> values = new List<InitialAA>();
            int index = 1;
            seq.Clear();
            //revseq.Clear();
            //Dictionary<double, string> massLookup = null;

            Dispatcher.Invoke(new Action(() =>
            {
                MassLookupToUse = chkDipeptides.IsChecked.Value ? ComboMassLookup : MassLookup;
            }));

            try
            {
                //var monos = ions.Where(a => a.MonoMass <= sequencetagmass);
                var monos = double.IsNaN(parentMass) ? ions : ions.Where(a => a.MonoMass <= parentMass);
                monos = monos.OrderBy(a => a.MonoMass);
                double matchtolerance = DechargerVM.SpectralDataFilename != null ? Properties.Settings.Default.MatchTolerancePPM : App.SSRXMLMatchTolerancePPM;

                // Find nearest/intense point? 
                if (ions != null && ions.Any())
                {
                    foreach (var startMono in monos)
                    {
                        foreach (var endMono in monos)
                        {
                            if ((endMono.MonoMass) <= (startMono.MonoMass)) continue;

                            var offset = (startMono.MonoMass) - endMono.MonoMass;

                            var SnappedXPosition = endMono.MonoMass;

                            var tolerance = PPMCalc.CurrentPPM(SnappedXPosition, matchtolerance);// Properties.Settings.Default.MatchTolerancePPM);  //float.Parse(txtMonoMatchTolerance.Text);

                            var start = (endMono.MonoMass) - tolerance;
                            var end = (endMono.MonoMass) + tolerance;


                            //var candidate = ions.Where(p => p.MonoMass > start && p.MonoMass < end).FirstOrDefault();

                            var candidate = ions.Where(p => p.MonoMass > start && p.MonoMass < end).FirstOrDefault();

                            if (candidate != null)
                            {
                                // Update the offset to use a value snapped to the nearest MonoMZ

                                offset = startMono.MonoMass - candidate.MonoMass;
                                SnappedXPosition = candidate.MonoMass;
                            }


                            double dif = PPMCalc.MaxPPM(Math.Min(SnappedXPosition, startMono.MonoMass), Math.Max(SnappedXPosition, startMono.MonoMass), matchtolerance); ///Properties.Settings.Default.MatchTolerancePPM); //, startMono.ZValue, endMono.ZValue);

                            //double dif = (((Properties.Settings.Default.MassTolerancePPM / 1e6d) * (Math.Min(SnappedXPosition, ((double)startMono.XValue)) * startMono.ZValue)) + ((Properties.Settings.Default.MassTolerancePPM / 1e6d) * (Math.Max(SnappedXPosition, ((double)startMono.XValue)) * endMono.ZValue))) / 2;

                            // TODO: Secondarily, snap to nearest peak!  

                            // Search for Masses that match within our tolerance
                            var matches = (from m in MassLookupToUse
                                           let difference = Math.Abs(m.Key - Math.Abs(offset))
                                           where difference <= dif
                                           orderby difference
                                           select new
                                           {
                                               Name = m.Value,
                                               Delta = difference,
                                               Start = Math.Min(SnappedXPosition, startMono.MonoMass),
                                               End = Math.Max(SnappedXPosition, startMono.MonoMass),
                                               StartScore = startMono.Score,
                                               EndScore = endMono.Score,
                                               AverageMonoMassIntensity = ((endMono.Intensity + startMono.Intensity) / (2)),
                                               SumofMonoMassIntensities = endMono.Intensity + startMono.Intensity
                                           }).FirstOrDefault();

                            //                                           select new { Name = m.Value, Delta = difference, Start = Math.Round(Math.Min(SnappedXPosition, (startMono.MonoMass)), 1), End = Math.Round(Math.Max(SnappedXPosition, (startMono.MonoMass)), 1), StartScore = startMono.Score, EndScore = endMono.Score }).FirstOrDefault();

                            SequenceDirectionRightToLeft = SnappedXPosition < startMono.MonoMass;

                            if (matches != null)
                            {
                                values.Add(new InitialAA
                                {
                                    EndDelta = (float)matches.EndScore,
                                    Delta = (float)matches.Delta,
                                    End = matches.End,
                                    Name = matches.Name,
                                    Start = matches.Start,
                                    StartDelta = (float)matches.StartScore,
                                    SumofMonoMassIntensities = matches.SumofMonoMassIntensities,
                                    AverageMonoMassIntensity = matches.AverageMonoMassIntensity
                                });
                            }
                        }
                    }

                    values = values.OrderBy(a => a.Start).ToList();

                    foreach (InitialAA val in values)
                    {
                        val.Index = Convert.ToString(index);
                        index++;
                    }
                    ///After finding all the Amino Acids available we need to look up for the possible sequences.
                    ///One of the parameters for finding the sequences is all the amino acids,
                    ///the other one is the Max length possible for an Amino Acid.

                    //if (!allsequencetags)
                    //{

                    seq = publicseq = FindSequenceTags.FindAllSequenceTags(values);

                    ///FindSequenceTags.FindAllSequenceTags(values);

                    //}
                    //else
                    //{
                    //    seq = publicseq = FindSequenceTags.FindAllSequenceTags(values);
                    //}
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine(ex.Message);
            }
            return seq;
        }

        public class ModificationsList
        {
            public int Numberofmodifications { get; set; }
            public string ScanNumbers { get; set; }
        }

        //private List<FindSequenceTags.SequenceTag> FindAllSequenceTags(SuperSpectrum spectrum, List<double> modifications = null, CancellationToken cToken = default(CancellationToken))
        //{
        //    var seq = publicseq = FindSequenceTags.FindAllSequenceTags(values);



        //    return seq;
        //}


            private List<FindSequenceTags.SequenceTag> FindAllSequenceTagsWithoutModifications(IEnumerable<Cluster> ions, List<double> modifications, ref ModificationsList modificationslist, double parentMass = double.NaN, bool direction = false, CancellationToken cToken = default(CancellationToken))
        {
            //TODO: Use activation do calculate abc xyz of ions to use for fragmentation.  

            var seq = new List<FindSequenceTags.SequenceTag>();
            int numberofmodifications = 0;
            double matchtolerance = DechargerVM.SpectralDataFilename != null ? Properties.Settings.Default.MatchTolerancePPM : App.SSRXMLMatchTolerancePPM;
            var ion = ions.OrderBy(a => a.MonoMass).ToList();
            modifications.Add(15.9949);
            int i = 0;
            int j = 0;
            while (i < ion.Count)
            {
                if (cToken != default(CancellationToken) && cToken.IsCancellationRequested) return seq;

                while (j < ion.Count)
                {
                    var offset = ion[i].MonoMass - ion[j].MonoMass;
                    double dif = PPMCalc.MaxPPM(ion[i].MonoMass, ion[j].MonoMass, matchtolerance);
                    if (modifications.Where(a => Math.Abs(a - Math.Abs(offset)) <= dif).Any())
                    {
                        if (direction)
                        {
                            ion.Remove(ion[j]);
                            numberofmodifications++;
                        }
                        else
                        {
                            ion.Remove(ion[i]);
                            numberofmodifications++;
                        }
                    }
                    j++;
                }
                j = i;
                i++;
            }

            ions = ion;

            List<double> removedvalues = new List<double>();

            List<InitialAA> values = new List<InitialAA>();
            int index = 1;
            seq.Clear();
            Dispatcher.Invoke(new Action(() =>
            {
                MassLookupToUse = chkDipeptides.IsChecked.Value ? ComboMassLookup : MassLookup;
            }));

            try
            {
                //var monos = ions.Where(a => a.MonoMass <= sequencetagmass);
                var monos = double.IsNaN(parentMass) ? ions.ToList() : ions.Where(a => a.MonoMass <= parentMass).ToList();
                monos = monos.OrderBy(a => a.MonoMass).ToList();


                var newmonos = monos.ToList();
                int numberofmonos = monos.Count;
                // Find nearest/intense point? 
                if (ions != null && ions.Any())
                {
                    i = 0;
                    j = 0;
                    while (i < monos.Count)
                    {
                        if (cToken != default(CancellationToken) && cToken.IsCancellationRequested) return seq;

                        var startMono = monos[i];
                        while (j < monos.Count)
                        {
                            var endMono = monos[j];

                            if ((endMono.MonoMass) <= (startMono.MonoMass))
                            {
                                j++;
                                continue;
                            }

                            var offset = (startMono.MonoMass) - endMono.MonoMass;

                            var SnappedXPosition = endMono.MonoMass;

                            var tolerance = PPMCalc.CurrentPPM(SnappedXPosition, matchtolerance);

                            var start = (endMono.MonoMass) - tolerance;
                            var end = (endMono.MonoMass) + tolerance;

                            var candidate = ions.Where(p => p.MonoMass > start && p.MonoMass < end).FirstOrDefault();

                            if (candidate != null)
                            {
                                // Update the offset to use a value snapped to the nearest MonoMZ

                                offset = startMono.MonoMass - candidate.MonoMass;
                                SnappedXPosition = candidate.MonoMass;
                            }


                            double dif = PPMCalc.MaxPPM(Math.Min(SnappedXPosition, startMono.MonoMass), Math.Max(SnappedXPosition, startMono.MonoMass), matchtolerance); ///Properties.Settings.Default.MatchTolerancePPM); //, startMono.ZValue, endMono.ZValue);

                            // TODO: Secondarily, snap to nearest peak!  

                            //if (modifications.Where(a => Math.Abs(a - Math.Abs(offset)) <= dif).Any())
                            //{
                            //    if (direction)
                            //    {
                            //        monos.Remove(endMono);
                            //        removedvalues.Add(endMono.MonoMass);
                            //        numberofmodifications++;
                            //    }
                            //    else
                            //    {
                            //        monos.Remove(startMono);
                            //        removedvalues.Add(startMono.MonoMass);
                            //        numberofmodifications++;
                            //    }
                            //    j++;
                            //    continue;
                            //}

                            // Search for Masses that match within our tolerance
                            var matches = (from m in MassLookupToUse
                                           let difference = Math.Abs(m.Key - Math.Abs(offset))
                                           where difference <= dif
                                           orderby difference
                                           select new
                                           {
                                               Name = m.Value,
                                               Delta = difference,
                                               Start = Math.Min(SnappedXPosition, startMono.MonoMass),
                                               End = Math.Max(SnappedXPosition, startMono.MonoMass),
                                               StartScore = startMono.Score,
                                               EndScore = endMono.Score,
                                               AverageMonoMassIntensity = ((startMono.Intensity + endMono.Intensity) / 2),
                                               SumofMonoMassIntensity = (startMono.Intensity + endMono.Intensity)
                                           }).FirstOrDefault();

                            SequenceDirectionRightToLeft = SnappedXPosition < startMono.MonoMass;

                            if (matches != null)
                            {
                                values.Add(new InitialAA
                                {
                                    EndDelta = (float)matches.EndScore,
                                    Delta = (float)matches.Delta,
                                    End = matches.End,
                                    Name = matches.Name,
                                    Start = matches.Start,
                                    StartDelta = (float)matches.StartScore,
                                    AverageMonoMassIntensity = matches.AverageMonoMassIntensity,
                                    SumofMonoMassIntensities = matches.SumofMonoMassIntensity
                                });
                            }

                            j++;
                        }
                        i++;
                        j = 0;
                    }
                    //i = 0;
                    //j = 0;
                    //while (i < monos.Count)
                    //{
                    //    var startMono = monos[i];
                    //    while (j < monos.Count)
                    //    {
                    //        var endMono = monos[j];

                    //        if ((endMono.MonoMass) <= (startMono.MonoMass))
                    //        {
                    //            j++;
                    //            continue;
                    //        }

                    //        var offset = (startMono.MonoMass) - endMono.MonoMass;

                    //        var SnappedXPosition = endMono.MonoMass;

                    //        var tolerance = PPMCalc.CurrentPPM(SnappedXPosition, matchtolerance);

                    //        var start = (endMono.MonoMass) - tolerance;
                    //        var end = (endMono.MonoMass) + tolerance;

                    //        var candidate = ions.Where(p => p.MonoMass > start && p.MonoMass < end).FirstOrDefault();

                    //        if (candidate != null)
                    //        {
                    //            // Update the offset to use a value snapped to the nearest MonoMZ

                    //            offset = startMono.MonoMass - candidate.MonoMass;
                    //            SnappedXPosition = candidate.MonoMass;
                    //        }


                    //        double dif = PPMCalc.MaxPPM(Math.Min(SnappedXPosition, startMono.MonoMass), Math.Max(SnappedXPosition, startMono.MonoMass), matchtolerance); ///Properties.Settings.Default.MatchTolerancePPM); //, startMono.ZValue, endMono.ZValue);

                    //        // TODO: Secondarily, snap to nearest peak!  

                    //        if (modifications.Where(a => Math.Abs(a - Math.Abs(offset)) <= dif).Any())
                    //        {
                    //            monos.Remove(startMono);
                    //            continue;
                    //        }

                    //        // Search for Masses that match within our tolerance
                    //        var matches = (from m in MassLookupToUse
                    //                       let difference = Math.Abs(m.Key - Math.Abs(offset))
                    //                       where difference <= dif
                    //                       orderby difference
                    //                       select new { Name = m.Value, Delta = difference, Start = Math.Min(SnappedXPosition, startMono.MonoMass), End = Math.Max(SnappedXPosition, startMono.MonoMass), StartScore = startMono.Score, EndScore = endMono.Score }).FirstOrDefault();

                    //        SequenceDirectionRightToLeft = SnappedXPosition < startMono.MonoMass;

                    //        if (matches != null)
                    //        {
                    //            values.Add(new InitialAA
                    //            {
                    //                EndDelta = (float)matches.EndScore,
                    //                Delta = (float)matches.Delta,
                    //                End = matches.End,
                    //                Name = matches.Name,
                    //                Start = matches.Start,
                    //                StartDelta = (float)matches.StartScore,
                    //            });
                    //        }

                    //        j++;
                    //    }
                    //    i++;
                    //    j = 0;
                    //}
                    //foreach (var startMono in monos)
                    //{
                    //    foreach (var endMono in monos)
                    //    {
                    //        if ((endMono.MonoMass) <= (startMono.MonoMass)) continue;

                    //        //if (!newmonos.Where(a => a.MonoMass == endMono.MonoMass).Any()) continue;

                    //        var offset = (startMono.MonoMass) - endMono.MonoMass;

                    //        var SnappedXPosition = endMono.MonoMass;

                    //        var tolerance = PPMCalc.CurrentPPM(SnappedXPosition, matchtolerance);

                    //        var start = (endMono.MonoMass) - tolerance;
                    //        var end = (endMono.MonoMass) + tolerance;

                    //        var candidate = ions.Where(p => p.MonoMass > start && p.MonoMass < end).FirstOrDefault();

                    //        if (candidate != null)
                    //        {
                    //            // Update the offset to use a value snapped to the nearest MonoMZ

                    //            offset = startMono.MonoMass - candidate.MonoMass;
                    //            SnappedXPosition = candidate.MonoMass;
                    //        }


                    //        double dif = PPMCalc.MaxPPM(Math.Min(SnappedXPosition, startMono.MonoMass), Math.Max(SnappedXPosition, startMono.MonoMass), matchtolerance); ///Properties.Settings.Default.MatchTolerancePPM); //, startMono.ZValue, endMono.ZValue);

                    //        // TODO: Secondarily, snap to nearest peak!  

                    //        if (modifications.Where(a => Math.Abs(a - Math.Abs(offset)) <= dif).Any())
                    //        {
                    //            monos.Remove(endMono);
                    //        }

                    //        // Search for Masses that match within our tolerance
                    //        var matches = (from m in MassLookupToUse
                    //                       let difference = Math.Abs(m.Key - Math.Abs(offset))
                    //                       where difference <= dif
                    //                       orderby difference
                    //                       select new { Name = m.Value, Delta = difference, Start = Math.Min(SnappedXPosition, startMono.MonoMass), End = Math.Max(SnappedXPosition, startMono.MonoMass), StartScore = startMono.Score, EndScore = endMono.Score }).FirstOrDefault();

                    //        SequenceDirectionRightToLeft = SnappedXPosition < startMono.MonoMass;

                    //        if (matches != null)
                    //        {
                    //            values.Add(new InitialAA
                    //            {
                    //                EndDelta = (float)matches.EndScore,
                    //                Delta = (float)matches.Delta,
                    //                End = matches.End,
                    //                Name = matches.Name,
                    //                Start = matches.Start,
                    //                StartDelta = (float)matches.StartScore,
                    //            });
                    //        }
                    //    }
                    //}

                    //values = values.GroupBy(a => (a.Start + a.End + a.Name)).Select(a => a.First()).ToList();

                    //foreach (var va in removedvalues)
                    //{
                    //    values.Remove(values.Where(a => a.Start == va || a.End == va).Any() ? values.Where(a => a.Start == va || a.End == va).First() : new InitialAA());
                    //}

                    values = values.OrderBy(a => a.Start).ToList();
                    modificationslist.Numberofmodifications = numberofmodifications;
                    foreach (InitialAA val in values)
                    {
                        val.Index = Convert.ToString(index);
                        index++;
                    }
                    ///After finding all the Amino Acids available we need to look up for the possible sequences.
                    ///One of the parameters for finding the sequences is all the amino acids,
                    ///the other one is the Max length possible for an Amino Acid.

                    //if (!allsequencetags)
                    //{

                    seq = publicseq = FindSequenceTags.FindAllSequenceTags(values);

                    ///FindSequenceTags.FindAllSequenceTags(values);

                    //}
                    //else
                    //{
                    //    seq = publicseq = FindSequenceTags.FindAllSequenceTags(values);
                    //}
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine(ex.Message);
            }
            return seq;
        }

        //void GenerateTestFileforApplyHighlight(List<FindSequenceTags.SequenceTag> AllSqsTags, List<string> PairMatch, string BoundText, List<string> Allthesequencetags, List<MainSequenceTagmatches> Mainsequencematch, List<Cluster> CrntIons, double ParentMass)
        //{
        //    var baseDir = System.IO.Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);
        //    string pathString = "C:\\Code\\ApplyhighlightTest";
        //    string fileName = DeChargerModel.FileName.Replace(".raw", "") + "_" + App.ScanNumber + ".txt";
        //    StringBuilder stb = new StringBuilder();
        //    foreach (FindSequenceTags.SequenceTag sqstags in AllSqsTags)
        //    {
        //        stb.Append("SqsTags \t" + (sqstags.End.ToString("G17")) + "\t" + " StartIndividualAAs " + "\t"
        //                    + string.Join(" ", sqstags.IndividualAAs.ToList().Select(a => " iaas " + (a.End.ToString("G17")) + " " + (a.EndScore.ToString("G17")) + " "
        //                    + a.Name + " " + (a.Score.ToString("G17")) + " " + (a.Start.ToString("G17")) + " " + (a.StartScore.ToString("G17")))) + " EndIndividualAAs " +
        //                    "\t" + (sqstags.MaxScore.ToString("G17")) +
        //                    "\t" + sqstags.NumberofAA + "\t" + sqstags.RawSequence + "\t"
        //             + (sqstags.Score.ToString("G17")) + "\t"
        //                    + (sqstags.Start.ToString("G17")) + "\t" + (sqstags.totalScore.ToString("G17")) + "\t");
        //    }
        //    stb.Append("\n");
        //    foreach (string pm in PairMatch)
        //    {
        //        stb.Append(pm + "\t");
        //    }
        //    stb.Append("\n");
        //    stb.Append(BoundText + "\n");

        //    foreach (string alltsqtgs in Allthesequencetags)
        //    {
        //        stb.Append(alltsqtgs + "\t");
        //    }

        //    stb.Append("\n");

        //    foreach (MainSequenceTagmatches mstm in Mainsequencematch)
        //    {
        //        stb.Append("mstm \t" + (mstm.End.ToString("G17")) + "\t" + (mstm.MassDiff.ToString("G17")) + "\t" + mstm.Seq + "\t" + (mstm.Start.ToString("G17")) + "\t");
        //    }

        //    stb.Append("\n");

        //    foreach (Cluster crntion in CrntIons)
        //    {
        //        stb.Append("crntion \t" + (crntion.Intensity.ToString("G17")) + "\t" + (crntion.MonoMass.ToString("G17")) + "\t" + (crntion.MonoMZ.ToString("G17")) + "\t" + (crntion.Score.ToString("G17")) + "\t");
        //    }

        //    stb.Append("\n");

        //    stb.Append((ParentMass.ToString("G17")));

        //    stb.Append("\n");

        //    foreach (var aa in AminoAcidHelpers.AminoAcidMass3)
        //    {
        //        stb.Append("aa3\t" + aa.Key + "\t" + aa.Value + "\t");
        //    }

        //    stb.Append("\n");

        //    File.WriteAllText(pathString + "\\" + fileName, Convert.ToString(stb));
        //}


        //void GenerateTestFileforSequencetag(List<InitialAA> values)
        //{
        //    var baseDir = System.IO.Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);
        //    string pathString = "C:\\Code\\SequenceTagTest";
        //    //string fileName = DeChargerModel.FileName.Replace(".raw", "") + "_" + txtScanNum.Text + ".txt";
        //    string fileName = DeChargerModel.FileName.Replace(".raw", "") + "_" + scannumbers + ".txt";
        //    StringBuilder stb = new StringBuilder();

        //    foreach (InitialAA vl in values)
        //    {
        //        stb.AppendLine(vl.Delta + "\t" + vl.End + "\t" + vl.EndDelta + "\t" + vl.Index + "\t" + vl.Name + "\t" + vl.NameIndex + "\t" + vl.Start + "\t" + vl.StartDelta);
        //    }

        //    File.WriteAllText(pathString + "\\" + fileName, Convert.ToString(stb));
        //}

        void bgsequencesearchinfasta_DoWork(object sender, DoWorkEventArgs e)
        {
            if (e.Argument == null || (e.Argument is List<FindSequenceTags.SequenceTag>) == false)
            {
                e.Result = new ArgumentException();
                return;
            }

            var tags = e.Argument as List<FindSequenceTags.SequenceTag>;
            var workerResult = new List<FindSequenceTags.SequenceTag>();

            try
            {
                Debug.WriteLine("bgsequencesearchinfasta_DoWork - Tag count: " + tags.Count);

                if (tags.Any() == false) return;

                if (!Properties.Settings.Default.UseBlast)
                {
                    foreach (FindSequenceTags.SequenceTag aTag in tags)
                    {
                        // DO NOT COUNT any tag occurrences for tags shorter than 3 amino acids in length
                        if (aTag.Sequence.Length > 2)
                        {
                            workerResult.Add(new FindSequenceTags.SequenceTag
                            {
                                RawSequence = aTag.Sequence,
                                End = aTag.End,
                                Index = aTag.Index,
                                Ions = aTag.Ions,
                                MaxScore = aTag.MaxScore,
                                NumberofAA = aTag.NumberofAA,
                                Start = aTag.Start,
                                totalScore = aTag.totalScore,
                                IndividualAAs = aTag.IndividualAAs,
                                Score = aTag.Score,
                                Visibility = "No",
                                DatabaseHitsValue = App.lstFasta.Where(x => (x.ModifiedSequenceforL.Contains(aTag.Sequence) || x.ModifiedSequenceforL.Contains(aTag.ReverseSequence))).Distinct().Count()
                            });
                        }
                        else
                        {
                            workerResult.Add(new FindSequenceTags.SequenceTag
                            {
                                RawSequence = aTag.Sequence,
                                End = aTag.End,
                                Index = aTag.Index,
                                Ions = aTag.Ions,
                                MaxScore = aTag.MaxScore,
                                NumberofAA = aTag.NumberofAA,
                                Start = aTag.Start,
                                totalScore = aTag.totalScore,
                                IndividualAAs = aTag.IndividualAAs,
                                Score = aTag.Score,
                                Visibility = "No",
                                DatabaseHitsValue = 0
                            });
                        }
                    }
                }
                else
                {
                    StringBuilder AlltheSequencetagsfromallscans = new StringBuilder();
                    tags = tags.Where(a => a.Sequence.Length >= Properties.Settings.Default.SequenceTagLength).ToList();

                    var tag = tags.First();

                    Dictionary<Guid, string> blastpsequences = new Dictionary<Guid, string>();

                    foreach (string s in tags.Select(a => a.Sequence))
                    {
                        Guid newguid = Guid.NewGuid();
                        blastpsequences.Add(newguid, s);
                        AlltheSequencetagsfromallscans.Append(">" + newguid + "\n" + s + "\n");

                        newguid = Guid.NewGuid();
                        blastpsequences.Add(newguid, ReverseString.Reverse(s));
                        AlltheSequencetagsfromallscans.Append(">" + newguid + "\n" + ReverseString.Reverse(s) + "\n");
                    }

                    var blastpresults = BlastP.BlastQueryResults(AlltheSequencetagsfromallscans);

                    var allofresults = (from b in blastpsequences
                                        join blp in blastpresults on b.Key equals Guid.Parse(blp.QuerySequenceID)
                                        select new
                                        {
                                            Sequence = b.Value,
                                            SequenceID = blp.SubjectSequenceID,
                                            SequenceStart = blp.QueryStart,
                                            SequenceEnd = blp.QueryEnd - blp.QueryStart,
                                        });

                    foreach (var t in tags)
                    {
                        if (allofresults.Where(a => (a.Sequence == t.Sequence || a.Sequence == ReverseString.Reverse(t.Sequence))).Any())
                        {
                            var tempresult = new FindSequenceTags.SequenceTag
                            {
                                RawSequence = t.Sequence,
                                End = t.End,
                                Index = t.Index,
                                Ions = t.Ions,
                                MaxScore = t.MaxScore,
                                Start = t.Start,
                                totalScore = t.totalScore,
                                IndividualAAs = t.IndividualAAs,
                                Score = t.Score,
                                Visibility = "No",
                                BlastTag = t.Sequence.Substring(allofresults.Where(a => (a.Sequence == t.Sequence || a.Sequence == ReverseString.Reverse(t.Sequence))).First().SequenceStart - 1, allofresults.Where(a => (a.Sequence == t.Sequence || a.Sequence == ReverseString.Reverse(t.Sequence))).First().SequenceEnd + 1),
                                DatabaseHitsValue = allofresults.Where(a => (a.Sequence == t.Sequence || a.Sequence == ReverseString.Reverse(t.Sequence))).GroupBy(a => a.SequenceID).Count()
                            };

                            workerResult.Add(tempresult);
                        }
                    }


                    foreach (var t in tags)
                    {
                        if (!((workerResult.Where(a => a.Sequence == t.Sequence).Any()) || (workerResult.Where(a => a.Sequence == ReverseString.Reverse(t.Sequence)).Any())))
                        {
                            workerResult.Add(new FindSequenceTags.SequenceTag
                            {
                                RawSequence = t.RawSequence,
                                End = t.End,
                                Index = t.Index,
                                Ions = t.Ions,
                                MaxScore = t.MaxScore,
                                Start = t.Start,
                                totalScore = t.totalScore,
                                IndividualAAs = t.IndividualAAs,
                                Score = t.Score,
                                Visibility = "No",
                                DatabaseHitsValue = 0
                            });
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                e.Result = ex;
            }
            finally
            {
                e.Result = workerResult;
            }
        }

        void bgsequencesearchindb_DoWork(object sender, DoWorkEventArgs e)
        {
            if (e.Argument == null || (e.Argument is List<FindSequenceTags.SequenceTag>) == false)
            {
                e.Result = new ArgumentException();
                return;
            }

            var tags = e.Argument as List<FindSequenceTags.SequenceTag>;

            var workerResult = new List<FindSequenceTags.SequenceTag>();

            workerResult = NumberofDatabaseHitsfortags(tags);

            e.Result = workerResult;
        }

        public List<FindSequenceTags.SequenceTag> NumberofDatabaseHitsfortags(List<FindSequenceTags.SequenceTag> tags)
        {
            var workerResult = new List<FindSequenceTags.SequenceTag>();
            //try
            //{
                //using (var cn = new SqlConnection(Properties.Settings.Default.ConnectionString))
                //{
                    //cn.Open();
                    if (db.State == ConnectionState.Closed) db.Open();

                    foreach (FindSequenceTags.SequenceTag sq in tags)
                    {
                        if (sq.Sequence.Length >= Properties.Settings.Default.SequenceTagLength) /// || Properties.Settings.Default.CountBlastHits)
                        {
                            string allspecies = "'" + string.Join(",", App.DistinctSpecies.Where(a => a.IsSelected == true).Select(a => a.SpeciesID)) + "'";
                            string sqlcommand = string.Empty;
                            if (!Properties.Settings.Default.UseBlast || (sq.Sequence.Length <= 4 && Properties.Settings.Default.CountBlastHits))
                            {
                                sqlcommand = "SELECT COUNT(*) FROM [dbo].[FindProteinsByIsobaricSequenceforCountbySpecies]( '" + sq.Sequence + "', " + (Properties.Settings.Default.SearchAllSpecies ? "NULL" : allspecies) + " )";
                            }
                            else if (Properties.Settings.Default.CountBlastHits)
                            {
                                sqlcommand = "EXEC [dbo].[BlastpBySpecies20] '" + sq.Sequence + "', " + "0 ," + (Properties.Settings.Default.SearchAllSpecies ? "NULL" : allspecies) + ", '-evalue 5000 -ungapped -comp_based_stats 0 -task blastp-short' ";  //-max_target_seqs 101  -ungapped blastp-short
                            }

                            using (SqlCommand cmd = new SqlCommand(sqlcommand, db))
                            {
                                cmd.CommandTimeout = 100000;
                                cmd.CommandType = CommandType.Text;

                                if (!Properties.Settings.Default.UseBlast || (sq.Sequence.Length <= 4 && Properties.Settings.Default.CountBlastHits))
                                {
                                    var scalarResult = cmd.ExecuteScalar();
                                    workerResult.Add(new FindSequenceTags.SequenceTag
                                    {
                                        RawSequence = sq.Sequence,
                                        End = sq.End,
                                        Index = sq.Index,
                                        Ions = sq.Ions,
                                        MaxScore = sq.MaxScore,
                                        NumberofAA = sq.NumberofAA,
                                        Start = sq.Start,
                                        totalScore = sq.totalScore,
                                        IndividualAAs = sq.IndividualAAs,
                                        Score = sq.Score,
                                        Visibility = "No",
                                        DatabaseHitsValue = (int)scalarResult
                                    });
                                }
                                else if (Properties.Settings.Default.CountBlastHits)
                                {
                                    //int cnt = 0;
                                    //int count = SearchforSequence(sq.Sequence, SaveCurrentScanInfo.currentTags, SaveCurrentScanInfo.ions, ref cnt, SaveCurrentScanInfo.ParentMass).Count();

                                    cmd.ExecuteNonQuery();

                                    sqlcommand = "SELECT @@ROWCOUNT as NumberofRows";

                                    SqlCommand cmd1 = new SqlCommand(sqlcommand, db);

                                    int scalarvalue = Convert.ToInt32(cmd1.ExecuteScalar());

                                    //using (SqlDataReader dr = cmd1.ExecuteReader())
                                    //{
                                    //    while(dr.Read())
                                    //    {

                                    //sqlcommand = "EXEC [dbo].[BlastpBySpecies4] '" + ReverseString.ReverseStr(sq.Sequence) + "', " + "0 ," + (Properties.Settings.Default.SearchAllSpecies ? "NULL" : allspecies) + ", '-evalue 5000 -ungapped  -comp_based_stats 0 -task blastp-short' ";  //-max_target_seqs 101
                                    //SqlCommand cmd2 = new SqlCommand(sqlcommand, cn);
                                    //cmd2.ExecuteNonQuery();

                                    //sqlcommand = "SELECT @@ROWCOUNT as NumberofRows";

                                    //cmd1 = new SqlCommand(sqlcommand, cn);

                                    //scalarvalue += Convert.ToInt32(cmd1.ExecuteScalar());

                                    workerResult.Add(new FindSequenceTags.SequenceTag
                                    {
                                        RawSequence = sq.Sequence,
                                        End = sq.End,
                                        Index = sq.Index,
                                        Ions = sq.Ions,
                                        MaxScore = sq.MaxScore,
                                        NumberofAA = sq.NumberofAA,
                                        Start = sq.Start,
                                        totalScore = sq.totalScore,
                                        IndividualAAs = sq.IndividualAAs,
                                        Score = sq.Score,
                                        Visibility = "No",
                                        DatabaseHitsValue = scalarvalue,/// count, ///dr["NumberofRows"] != DBNull.Value ? Convert.ToInt16(dr["NumberofRows"]) : 0
                                    });
                                    //    }
                                    //}
                                    //if (scalarResult == 1)
                                    //    scalarResult = 101;
                                    //using (SqlDataReader dr = cmd.ExecuteReader())
                                    //{
                                    //    while (dr.Read())
                                    //    {
                                    //var scalarResult = Convert.ToInt32(dr["numberofrows"]);
                                    //workerResult.Add(new FindSequenceTags.SequenceTag
                                    //{
                                    //    RawSequence = sq.Sequence,
                                    //    End = sq.End,
                                    //    Index = sq.Index,
                                    //    Ions = sq.Ions,
                                    //    MaxScore = sq.MaxScore,
                                    //    NumberofAA = sq.NumberofAA,
                                    //    Start = sq.Start,
                                    //    totalScore = sq.totalScore,
                                    //    IndividualAAs = sq.IndividualAAs,
                                    //    Score = sq.Score,
                                    //    Visibility = "No",
                                    //    DatabaseHitsValue = scalarResult
                                    //});
                                    //    }
                                    //}
                                }
                                else
                                {
                                    workerResult.Add(new FindSequenceTags.SequenceTag
                                    {
                                        RawSequence = sq.Sequence,
                                        End = sq.End,
                                        Index = sq.Index,
                                        Ions = sq.Ions,
                                        MaxScore = sq.MaxScore,
                                        NumberofAA = sq.NumberofAA,
                                        Start = sq.Start,
                                        totalScore = sq.totalScore,
                                        IndividualAAs = sq.IndividualAAs,
                                        Score = sq.Score,
                                        Visibility = "No",
                                        DatabaseHitsValue = 0
                                    });
                                }
                            }
                        }
                        else
                        {
                            workerResult.Add(new FindSequenceTags.SequenceTag
                            {
                                RawSequence = sq.Sequence,
                                End = sq.End,
                                Index = sq.Index,
                                Ions = sq.Ions,
                                MaxScore = sq.MaxScore,
                                NumberofAA = sq.NumberofAA,
                                Start = sq.Start,
                                totalScore = sq.totalScore,
                                IndividualAAs = sq.IndividualAAs,
                                Score = sq.Score,
                                Visibility = "No",
                                DatabaseHitsValue = 0
                            });
                        }
                    }

                //    cn.Close();
                //}
            //}
            //catch (Exception ex)
            //{

            //}
            return workerResult;
        }

        void bgsequencesearchindb_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            if (e.Result == null)
            {
                Debug.WriteLine("Null Result from bgsequencesearchindb_DoWork!");
                return;
            }

            if (e.Result is Exception) Debug.WriteLine("Exception in bgsequencesearchindb_DoWork: " + (e.Result as Exception).Message);

            // if we have the expected type, bind...
            if (e.Result is List<FindSequenceTags.SequenceTag>) BindAndShowTags(e.Result as List<FindSequenceTags.SequenceTag>);

            if (fromautoscan)
            {
                Button newbutton = new Button();
                string tag = string.Empty;

                //Assigning the tag based on the results.
                newbutton.Tag = SequenceforAutoScan; // (Properties.Settings.Default.SortByDBHits) ? (e.Result as List<FindSequenceTags.SequenceTag>).OrderByDescending(a => Convert.ToInt32(a.DatabaseHits != "> 100" ? a.DatabaseHits : "100") > 0).ThenByDescending(a => a.Sequence.Length).ToList().First().Sequence
                ///                    : (e.Result as List<FindSequenceTags.SequenceTag>).OrderByDescending(a => a.Sequence.Length).ToList().First().Sequence;
                btnfindsqs_Click(newbutton, null);
            }

        }

        void BindAndShowTags(List<FindSequenceTags.SequenceTag> tags)
        {

            Dispatcher.Invoke(new Action(() =>
            {
                dtgridsequences.DataContext = null;
                if (Properties.Settings.Default.SortByDBHits)
                {
                    //if (Properties.Settings.Default.UseBlast && DechargerVM.UseFasta)
                    //{
                    //    dtgridsequences.DataContext = tags.Where(a => a.Sequence.Length >= Properties.Settings.Default.SequenceTagLength).OrderByDescending(a => Convert.ToInt32(a.DatabaseHits != ">= 1" ? a.DatabaseHits : "1") > 0).ThenByDescending(a => a.Sequence.Length).ToList();
                    //}
                    //else
                    {
                        dtgridsequences.ItemsSource = null;
                        dtgridsequences.ItemsSource = tags.Where(a => a.Sequence.Length >= Properties.Settings.Default.SequenceTagLength).OrderByDescending(a => Convert.ToInt32(a.DatabaseHits != "> 100" ? a.DatabaseHits : "100") > 0).ThenByDescending(a => a.Sequence.Length).ToList();
                        dtgridsequences.DataContext = tags.Where(a => a.Sequence.Length >= Properties.Settings.Default.SequenceTagLength).OrderByDescending(a => Convert.ToInt32(a.DatabaseHits != "> 100" ? a.DatabaseHits : "100") > 0).ThenByDescending(a => a.Sequence.Length).ToList();
                    }
                }
                else
                {
                    dtgridsequences.ItemsSource = null;
                    dtgridsequences.ItemsSource = tags.Where(a => a.Sequence.Length >= Properties.Settings.Default.SequenceTagLength).OrderByDescending(a => Convert.ToInt32(a.DatabaseHits != "> 100" ? a.DatabaseHits : "100") > 0).ThenByDescending(a => a.Sequence.Length).ToList();
                    dtgridsequences.DataContext = tags.Where(a => a.Sequence.Length >= Properties.Settings.Default.SequenceTagLength).OrderByDescending(a => a.Sequence.Length).ToList();
                }
                dtgridsequences.Visibility = System.Windows.Visibility.Visible;
                btnMatch.IsEnabled = true;
                txtMatchSequence.IsEnabled = true;
                btnFindAA.Content = "Find Sequence Tags";
                SequenceBusyIndicator.IsBusy = false;
                //this.DataContext = this;
            }));
            Findtags();
        }



        private Paragraph paragraph;

        //private void SetParentInfo(SpectrumInfo sInfo)
        //{
        //    sInfo.ParentIon = null;

        //    if (MainPointProvider.ScanType(sInfo.ScanNumber) != "MS2") return;

        //    if (sInfo.ParentZ.HasValue && sInfo.ParentMass.HasValue) return;

        //    // Find the Parent Scan by going backwards
        //    var parentScanNumber = MainPointProvider.PreviousScan(sInfo.ScanNumber);

        //    while (parentScanNumber.HasValue && (MainPointProvider.ScanType(parentScanNumber.Value) != "MS"))
        //        parentScanNumber = MainPointProvider.PreviousScan(parentScanNumber.Value);

        //    if (!parentScanNumber.HasValue) return;

        //    var parentmz = MainPointProvider.ParentMZ(sInfo.ScanNumber);

        //    if (parentmz.HasValue)
        //    {
        //        // get surrounding MS1 scans to merge together

        //        var beforeMS = MainPointProvider.PreviousScan(parentScanNumber.Value);
        //        var afterMS = MainPointProvider.NextScan(parentScanNumber.Value);

        //        while ((MainPointProvider.ScanType(beforeMS.Value) != "MS"))
        //            beforeMS = MainPointProvider.PreviousScan(beforeMS.Value);

        //        while ((MainPointProvider.ScanType(afterMS.Value) != "MS"))
        //            afterMS = MainPointProvider.NextScan(afterMS.Value);

        //        List<Cluster> ionCandidatesDetected;

        //        bool usingThermoMerge = false;

        //        if (usingThermoMerge)
        //        {
        //            // Use Thermo API for merging scans
        //            var result = MainPointProvider.Average(beforeMS.Value, afterMS.Value, 1, parentmz.Value - 2d, parentmz.Value + 2d);
        //            ionCandidatesDetected = new ChargeDetector(result).DetectChargeStates();
        //        }
        //        else
        //        {
        //            // Use peak detected scans with limited m/z range to improve performance
        //            var b1 = MainPointProvider[beforeMS.Value].Range(parentmz.Value - 2d, parentmz.Value + 2d).ToPointSet(k => k.Key, v => v.Value);
        //            var p1 = MainPointProvider[parentScanNumber.Value].Range(parentmz.Value - 2d, parentmz.Value + 2d).ToPointSet(k => k.Key, v => v.Value);
        //            var a1 = MainPointProvider[afterMS.Value].Range(parentmz.Value - 2d, parentmz.Value + 2d).ToPointSet(k => k.Key, v => v.Value);

        //            List<Cluster> parentIons = new List<Cluster>();

        //            var pIons = new ChargeDetector(p1).DetectChargeStates();
        //            var bIons = new ChargeDetector(b1).DetectChargeStates();
        //            var aIons = new ChargeDetector(a1).DetectChargeStates();

        //            parentIons.AddRange(pIons);
        //            parentIons.AddRange(bIons);
        //            parentIons.AddRange(aIons);

        //            ionCandidatesDetected = SignalProcessor.ConsolidateIons(parentIons);
        //        }

        //        if (!ionCandidatesDetected.Any()) return;

        //        // Added a bias toward ions with more core peaks, and added selection bias for clusters that include the parent M/Z
        //        var candidates = ionCandidatesDetected.Where(p => p.Peaks.Where(x => x.IsCorePeak && (Math.Abs(parentmz.Value - x.MZ) < 0.01)).Any());
        //        if (candidates.Any()) sInfo.ParentIon = candidates.MaxBy(c => c.Intensity * (c.Peaks.Where(p => p.IsCorePeak).Count() * .25));
        //    }
        //}


        bool parentmassmerge = false;

        /// <summary>
        /// Merges all the Selected spectra from the datagrid
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void btnMerge_Click(object sender, RoutedEventArgs e)
        {
            var cells = grdMerge1.SelectedItems;
            parentmassmerge = true;

            var mergeList = new List<SpectrumInfo>();

            foreach (var aCell in grdMerge1.SelectedItems)
            {
                if (aCell is SpectrumInfo)
                {
                    var currentSpecInfo = aCell as SpectrumInfo;
                    mergeList.Add(currentSpecInfo);
                }
            }

            using (new WaitCursor())
            {
                DisplayNewSpectrum(mergeList); //Once all the spectra are merged it is displayed using this method
            }

            dtgridsequences.Visibility = System.Windows.Visibility.Collapsed; //The sequences are not shown once the merge happens
            btnFindAA.Visibility = System.Windows.Visibility.Visible; //The option to show new sequences
            ClearSequenceMatch();
            btnMatch.IsEnabled = false;
            txtMatchSequence.IsEnabled = false;
        }

        private void button2_Click(object sender, RoutedEventArgs e)
        {
            FindMonos();
            monosfound = true;
        }

        private List<MonoPeak> FindMonos(Spectrum spectrum, IEnumerable<Cluster> ions)
        {

            var returnMonos = new List<MonoPeak>();
            var revMonos = new List<MonoPeak>();

            try
            {
                // Enhanced Mono Mass Detection 
                // 1. Group ions by shared peaks
                // 2. Take MonoMass of ions in group with the highest score
                // 3. Add to CurrentMonoMasses List

                //CurrentMonos.Clear();
                SecondaryCurrentMonos.Clear();
                //ReverseCurrentMonos.Clear();
                ReverseSecondaryCurrentMonos.Clear();

                //MonoMassSeries.Visibility = System.Windows.Visibility.Visible;

                int j = 0;

                // Add Parent Ion if it exists so that it can be used for sequencing
                if (spectrum.ParentIon != null)
                {
                    returnMonos.Add(new MonoPeak()
                    {
                        Index = j++,
                        XValue = spectrum.ParentIon.MonoMass,
                        Score = spectrum.ParentIon.Score,
                        Charge = spectrum.ParentIon.Z
                    });
                }

                var alreadyGrouped = new List<Cluster>();


                foreach (var anIon in ions.OrderByDescending(i => i.Score))
                {
                    //CurrentMonoMasses.Add(new DataPoint() { XValue = anIon.MonoMass, YValue = anIon.Intensity, ZValue = anIon.Z, Score = anIon.Score });

                    //if (spectrum.ParentMass.HasValue)
                    //{
                    //    ReverseCurrentMonomasses.Add(new DataPoint() { XValue = spectrum.ParentMass - anIon.MonoMass, YValue = anIon.Intensity, ZValue = anIon.Z, Score = anIon.Score });
                    //    //CurrentMonoMasses.Add(new DataPoint() { XValue = CurrentSpectrum.ParentMass - anIon.MonoMass, YValue = anIon.Intensity, ZValue = anIon.Z, Score = anIon.Score });
                    //}

                    returnMonos.Add(new MonoPeak()
                    {
                        Index = j,
                        XValue = anIon.MonoMass,
                        Score = anIon.Score,
                        Charge = anIon.Z
                    });

                    if (spectrum.ParentMass.HasValue)
                    {
                        revMonos.Add(new MonoPeak()
                        {
                            Index = j,
                            XValue = spectrum.ParentMass.Value - anIon.MonoMass,
                            Score = anIon.Score,
                            Charge = anIon.Z
                        });
                    }

                    if (anIon.SecondaryMonoMass != null)
                    {
                        if (spectrum.ParentMass.HasValue)
                        {
                            ReverseSecondaryCurrentMonos.Add(new MonoPeak()
                            {
                                Index = j,
                                XValue = (spectrum.ParentMass.Value - anIon.SecondaryMonoMass.Value),
                                Score = anIon.Score,
                                Charge = anIon.Z
                            });
                        }

                        SecondaryCurrentMonos.Add(new MonoPeak()
                        {
                            Index = j,
                            XValue = (anIon.SecondaryMonoMass.Value),
                            Score = anIon.Score,
                            Charge = anIon.Z
                        });
                    }
                    else
                    {
                        SecondaryCurrentMonos.Add(new MonoPeak()
                        {
                            Index = j,
                            XValue = 0,
                            Score = anIon.Score,
                            Charge = anIon.Z
                        });
                    }
                    j++;

                }

                returnMonos = returnMonos.OrderBy(a => a.XValue).ToList();

                //ConsolidatedMonomasses();
                //ReverseConsolidatedMonomasses();
                //monosfound = false;
                //SetScaling();

            }
            catch (Exception ex)
            {
                App.Laststacktrace = ex.StackTrace;
                Action throwException = () => { throw ex; };
                Dispatcher.CurrentDispatcher.BeginInvoke(throwException);
            }

            return returnMonos;
        }


        /// <summary>
        /// FindMonos will find all the Monos for the 
        /// </summary>
        private void FindMonos()
        {
            try
            {
                // Enhanced Mono Mass Detection 
                // 1. Group ions by shared peaks
                // 2. Take MonoMass of ions in group with the highest score
                // 3. Add to CurrentMonoMasses List

                CurrentMonos.Clear();
                SecondaryCurrentMonos.Clear();
                ReverseCurrentMonos.Clear();
                ReverseSecondaryCurrentMonos.Clear();

                MonoMassSeries.Visibility = System.Windows.Visibility.Visible;

                int j = 0;

                // Add Parent Ion if it exists so that it can be used for sequencing
                if (CurrentSpectrum.ParentIon != null)
                {
                    CurrentMonos.Add(new MonoPeak()
                    {
                        Index = j++,
                        XValue = CurrentSpectrum.ParentIon.MonoMass,
                        Score = CurrentSpectrum.ParentIon.Score,
                        Charge = CurrentSpectrum.ParentIon.Z
                    });
                }

                var alreadyGrouped = new List<Cluster>();


                foreach (var anIon in CurrentIons.OrderByDescending(i => i.Score))
                {
                    CurrentMonoMasses.Add(new DataPoint() { XValue = anIon.MonoMass, YValue = anIon.Intensity, ZValue = anIon.Z, Score = anIon.Score });

                    if (CurrentSpectrum.ParentMass.HasValue)
                    {
                        ReverseCurrentMonomasses.Add(new DataPoint() { XValue = CurrentSpectrum.ParentMass - anIon.MonoMass, YValue = anIon.Intensity, ZValue = anIon.Z, Score = anIon.Score });
                        //CurrentMonoMasses.Add(new DataPoint() { XValue = CurrentSpectrum.ParentMass - anIon.MonoMass, YValue = anIon.Intensity, ZValue = anIon.Z, Score = anIon.Score });
                    }

                    CurrentMonos.Add(new MonoPeak()
                    {
                        Index = j,
                        XValue = anIon.MonoMass,
                        Score = anIon.Score,
                        Charge = anIon.Z
                    });

                    if (CurrentSpectrum.ParentMass.HasValue)
                    {
                        ReverseCurrentMonos.Add(new MonoPeak()
                        {
                            Index = j,
                            XValue = CurrentSpectrum.ParentMass.Value - anIon.MonoMass,
                            Score = anIon.Score,
                            Charge = anIon.Z
                        });
                    }

                    if (anIon.SecondaryMonoMass != null)
                    {
                        if (CurrentSpectrum.ParentMass.HasValue)
                        {
                            ReverseSecondaryCurrentMonos.Add(new MonoPeak()
                            {
                                Index = j,
                                XValue = (CurrentSpectrum.ParentMass.Value - anIon.SecondaryMonoMass.Value),
                                Score = anIon.Score,
                                Charge = anIon.Z
                            });
                        }

                        SecondaryCurrentMonos.Add(new MonoPeak()
                        {
                            Index = j,
                            XValue = (anIon.SecondaryMonoMass.Value),
                            Score = anIon.Score,
                            Charge = anIon.Z
                        });
                    }
                    else
                    {
                        SecondaryCurrentMonos.Add(new MonoPeak()
                        {
                            Index = j,
                            XValue = 0,
                            Score = anIon.Score,
                            Charge = anIon.Z
                        });
                    }
                    j++;

                }
                CurrentMonos = CurrentMonos.OrderBy(a => a.XValue).ToList();

                //ConsolidatedMonomasses();
                //ReverseConsolidatedMonomasses();
                monosfound = false;
                SetScaling();
            }
            catch (Exception ex)
            {
                App.Laststacktrace = ex.StackTrace;
                Action throwException = () => { throw ex; };
                Dispatcher.CurrentDispatcher.BeginInvoke(throwException);
            }
        }
        /// <summary>
        /// It has all the list of masses for the consolidated monos,
        /// which is used for calculating the sequence tags
        /// </summary>
        //List<Masses> consolidatedmonomasses = new List<Masses>();
        //List<Masses> reverseconsolidatedmonomasses = new List<Masses>();

        //private void ReverseConsolidatedMonomasses()
        //{
        //    reverseconsolidatedmonomasses.Clear();
        //    List<double> valuespresent = new List<double>();

        //    foreach (DataPoint monomass in ReverseCurrentMonomasses)
        //    {
        //        reverseconsolidatedmonomasses.Add(new Masses
        //        {
        //            Score = monomass.Score,
        //            Mass = Convert.ToDouble(monomass.XValue)
        //        });
        //    }
        //}

        //private void ConsolidatedMonomasses()
        //{
        //    consolidatedmonomasses.Clear();
        //    List<double> valuespresent = new List<double>();

        //    foreach (DataPoint monomass in CurrentMonoMasses)
        //    {
        //        consolidatedmonomasses.Add(new Masses
        //        {
        //            Score = monomass.Score,
        //            Mass = Convert.ToDouble(monomass.XValue)
        //        });
        //    }
        //}


        private double WeightedScore(List<DataPoint> values)
        {
            double averagescore = 0.00;
            double sum = 0.00;
            foreach (DataPoint value in values)
            {
                sum += value.Score;
            }
            return averagescore = sum / values.Count;
        }

        private double WeightedAverage(List<DataPoint> values)
        {
            double summationim = 0.00;
            double summationi = 0.00;
            foreach (var value in values)
            {
                summationim += Convert.ToDouble(value.YValue) * Convert.ToDouble(value.XValue);
                summationi += Convert.ToDouble(value.YValue);
            }
            return (summationim / summationi);
        }

        private void ClearRed_Click(object sender = null, RoutedEventArgs e = null)
        {
            BottomChart.Series[5].DataPoints.Clear();
            btnClearSpectrumAll.IsOpen = false;
        }

        private void ClearMonos_Click(object sender, RoutedEventArgs e)
        {
            MonoMassSeries.Visibility = System.Windows.Visibility.Hidden;
            MonoMassesfordbSequence.Visibility = System.Windows.Visibility.Hidden;
            CurrentMonos.Clear();
            //consolidatedmonomasses.Clear();
            ReverseCurrentMonomasses.Clear();
            CurrentMonoMasses.Clear();
            MonoMasslabel.DataPoints.Clear();
            btnClearSpectrumAll.IsOpen = false;
        }

        private void button4_Click(object sender, RoutedEventArgs e)
        {
            if (CurrentMonoMasses.Any())
            {
                Dispatcher.Invoke((Action)(() =>
                {
                    //this.DataContext = CurrentMonoMasses;
                    MonoMassSeries.Visibility = System.Windows.Visibility.Visible;
                    MonoMassSeries.DataContext = CurrentMonoMasses;
                }));
                return;
            }
            foreach (var anIon in CurrentIons)
                CurrentMonoMasses.Add(new DataPoint() { XValue = anIon.MonoMass, YValue = anIon.Intensity, ZValue = anIon.Z });
            //this.DataContext = CurrentMonoMasses;

            Dispatcher.Invoke((Action)(() =>
            {
                //this.DataContext = CurrentMonoMasses;
                MonoMassSeries.Visibility = System.Windows.Visibility.Visible;
                MonoMassSeries.DataContext = CurrentMonoMasses;
            }));

            Dispatcher.Invoke((Action)(() =>
            {
                if (CurrentSpectrum.Any())
                {
                    double min = 0;
                    double max = sequencetagmass = CurrentSpectrum.ParentIon != null ? CurrentSpectrum.ParentIon.MonoMass : CurrentSpectrum.MaxBy(p => p.Mass).Mass;

                    if (max <= CurrentSpectrum.ParentMass)
                        max = CurrentSpectrum.ParentMass.Value;

                    min = min - (max - min) * 0.035;  // This gives us a buffer on the ends of the X axis
                    max = max + (max - min) * 0.035;  // This gives us a buffer on the ends of the X axis

                    BottomChart.AxesX[0].AxisMinimum = min;
                    BottomChart.AxesX[0].AxisMaximum = max;

                    var theAxis = BottomChart.AxesX[0];

                    zoom(theAxis, min, max);
                }
            }));

            btnFindSequenceinSpectrum.IsOpen = false;
        }

        private void textBox1_TextChanged(object sender, TextChangedEventArgs e)
        {

        }

        private void button5_Click(object sender, RoutedEventArgs e)
        {
            CurrentSpectrum.Clear();

            foreach (var aCluster in CurrentIons.Where(i => i.Z >= int.Parse(textBox1.Text) && i.Z <= int.Parse(textBox2.Text)))
                CurrentSpectrum.AddRange(aCluster.Peaks); //.Where(p => p.MZ > aCluster.MonoMZ));

            CurrentSpectrum.SortByMZ();


            //double min = CurrentSpectrum.MinBy(p => p.MZ).MZ;
            //double max = CurrentSpectrum.MaxBy(p => p.MZ).MZ;

            //min = min - (max - min) * 0.035;  // This gives us a buffer on the ends of the X axis
            //max = max + (max - min) * 0.035;  // This gives us a buffer on the ends of the X axis




            double min = CurrentIons.SelectMany(i => i.Peaks).Min(p => p.Mass);
            double max = CurrentIons.SelectMany(i => i.Peaks).Max(p => p.Mass);

            CurrentSpectrum.Add(new ClusterPeak() { MZ = min, Intensity = 0 });
            CurrentSpectrum.Add(new ClusterPeak() { MZ = max, Intensity = 0 });

            //BottomChart.Series[0].DataSource = CurrentSpectrum.Range(min, max, (int)BottomChart.AxesX[0].ActualWidth * (Properties.Settings.Default.HighBin ? 2 : 1));
            BottomChart.Series[7].DataSource = CurrentSpectrum.Range(min, max, (int)BottomChart.AxesX[0].ActualWidth * (Properties.Settings.Default.HighBin ? 2 : 1));

        }

        private void XIC_Click(object sender, RoutedEventArgs e)
        {
            try
            {

                if (this.MainPointProvider is RMSProvider)
                {
                    var r = this.MainPointProvider as RMSProvider;

                    //double xvalue;
                    //xvalue = SpecRightClickSpot;

                    //var viewWidth = Math.Abs((double)((sender as PlotArea).Tag as Chart).AxesX[0].ViewMaximum - (double)((sender as PlotArea).Tag as Chart).AxesX[0].ViewMinimum);
                    //var widthPerPixel = viewWidth / ((sender as PlotArea).Tag as Chart).AxesX[0].ActualWidth;

                    //var totalTolerance = PixelTolerance * widthPerPixel * 3;

                    //var start = ((double)e.XValue) - totalTolerance;
                    //var end = ((double)e.XValue) + totalTolerance;

                    //var targets = FindBestXicTargets(start, end);

                    //this.MenuItem8.Header = "XIC for ";

                    //foreach (var aTarget in targets)
                    //    this.MenuItem8.Header += aTarget.Start.ToString("0.0") + " to " + aTarget.Start.ToString("0.0") + "; ";

                    var targetCluster = FindClosestCluster(SpecRightClickSpot.Start, SpecRightClickSpot.End);
                    //var targetClusters = FindChargeVariants(targetCluster);

                    var targetRange = FindBestXicTargets(targetCluster);

                    //ClusterPeak closestPeak = CurrentSpectrum[0];

                    // This is a Mass value, so we need to find the closest peak and get the M/Z value for the XIC
                    //foreach (var aPeak in CurrentSpectrum)
                    //    if (Math.Abs(closestPeak.Mass - xvalue) > Math.Abs(aPeak.Mass - xvalue)) closestPeak = aPeak;

                    //var points = r.ExtractIon(closestPeak.MZ - 3, closestPeak.MZ + 3);

                    var points = r.ExtractIon(targetRange);

                    //XICChartPoints.DataSource = points;
                    XIC_Chart.Series[0].DataSource = points;
                    XIC_Chart.Tag = targetCluster;

                    var xicTitle = new Title() { Text = "XIC of " };

                    //XIC_Chart.Titles.Add(new Title() { Text = "XIC of " + (closestPeak.MZ - 3).ToString("0.000") + " to " + (closestPeak.MZ + 3).ToString("0.000") });

                    double min = Double.MaxValue, max = 0;

                    // Let's get the min and max of all targets for a cleaner title...
                    foreach (var aTarget in targetRange)
                    {
                        min = Math.Min(aTarget.Start, min);
                        max = Math.Max(aTarget.End, max);
                    }

                    xicTitle.Text += min.ToString("0.00") + " to " + max.ToString("0.00");
                    //    this.MenuItem8.Header += aTarget.Start.ToString("0.0") + " to " + aTarget.Start.ToString("0.0") + "; ";

                    XIC_Chart.Titles.Clear();
                    XIC_Chart.Titles.Add(xicTitle);

                    if (Properties.Settings.Default.JumpToXIC) tabXIC.IsSelected = true;

                }
                else if (this.MainPointProvider is AgilentProvider)
                {
                    var r = this.MainPointProvider as AgilentProvider;

                    var targetCluster = FindClosestCluster(SpecRightClickSpot.Start, SpecRightClickSpot.End);

                    var targetRange = FindBestXicTargets(targetCluster);

                    //r.ExtractIons(targetRange);
                    var points = r.ExtractIon(targetRange);

                    XIC_Chart.Series[0].DataSource = points;
                    XIC_Chart.Tag = targetCluster;

                    var xicTitle = new Title() { Text = "XIC of " };

                    double min = Double.MaxValue, max = 0;

                    // Let's get the min and max of all targets for a cleaner title...
                    foreach (var aTarget in targetRange)
                    {
                        min = Math.Min(aTarget.Start, min);
                        max = Math.Max(aTarget.End, max);
                    }

                    xicTitle.Text += min.ToString("0.00") + " to " + max.ToString("0.00");

                    XIC_Chart.Titles.Clear();
                    XIC_Chart.Titles.Add(xicTitle);

                    if (Properties.Settings.Default.JumpToXIC) tabXIC.IsSelected = true;
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine(ex.Message);
            }

        }


        void CopyCmdExecuted(object target, ExecutedRoutedEventArgs e)
        {
            // Based on http://blogs.gerodev.com/post/Copy-Selected-Items-in-WPF-Listbox-to-Clipboard.aspx

            try
            {
                var lb = target as ItemsControl;
                string copyContent = String.Empty;

                if (lb.Items.Count <= 0) return;

                //if (lb.Items[0].HasMethod("Header"))

                //if (lb.Items[0] is ICsvHeader)
                //    copyContent = (lb.Items[0] as ICsvHeader).Header + Environment.NewLine;
                //else

                IEnumerable<string> propertyList;

                if (target is DataGrid)
                {
                    copyContent = string.Join("\t", (target as DataGrid).Columns.Where(x => x is DataGridTextColumn && x.Visibility != System.Windows.Visibility.Hidden).Select(c => c.Header)) + Environment.NewLine;
                    propertyList = (target as DataGrid).Columns.Where(x => x is DataGridTextColumn && x.Visibility != System.Windows.Visibility.Hidden).Select(c => c.SortMemberPath);
                }
                else if (target is ListView)
                {
                    copyContent = string.Join("\t", ((target as ListView).View as GridView).Columns.Select(c => c.Header.ToString())) + Environment.NewLine;
                    propertyList = ((target as ListView).View as GridView).Columns.Select(c => (c.DisplayMemberBinding as System.Windows.Data.Binding).Path.Path);
                }
                else
                {
                    throw new Exception("Unable to copy from object of type " + target.GetType());
                }


                foreach (var lbi in lb.Items)
                {
                    if (lbi != null)
                    {
                        //if (lbi is ICsvHeader)
                        //    copyContent += lbi;
                        //else
                        copyContent += SerializeToString(propertyList, lbi);
                        copyContent += Environment.NewLine;
                    }
                }

                Clipboard.SetText(copyContent);
            }
            catch (Exception ex)
            {
                System.Windows.MessageBox.Show("Copy Command Error: " + ex.Message);
            }
        }

        static string SerializeToString(IEnumerable<string> propertyNames, object o)
        {
            // Based on http://stackoverflow.com/questions/1179816/best-practices-for-serializing-objects-to-a-custom-string-format-for-use-in-an-o

            var propertyInfos = o.GetType().GetProperties();
            var result = new List<string>();

            foreach (var propertyName in propertyNames)
            {
                if (propertyInfos.Any(p => p.Name == propertyName))
                {
                    result.Add((propertyInfos.First(p => p.Name == propertyName).GetValue(o, null) ?? string.Empty).ToString());
                }
                else
                {
                    result.Add(string.Empty);
                }
            }

            return string.Join("\t", result);
        }


        void CopyCmdCanExecute(object sender, CanExecuteRoutedEventArgs e)
        {
            // Based on http://blogs.gerodev.com/post/Copy-Selected-Items-in-WPF-Listbox-to-Clipboard.aspx

            var lb = sender as ItemsControl;

            if (lb != null && lb.HasItems)
                e.CanExecute = true;
            else
                e.CanExecute = false;
        }

        void ClearCmdExecuted(object target, ExecutedRoutedEventArgs e)
        {
            // Based on http://blogs.gerodev.com/post/Copy-Selected-Items-in-WPF-Listbox-to-Clipboard.aspx

            Items.Clear();
        }

        void ClearCmdCanExecute(object sender, CanExecuteRoutedEventArgs e)
        {
            // Based on http://blogs.gerodev.com/post/Copy-Selected-Items-in-WPF-Listbox-to-Clipboard.aspx

            var lb = sender as ItemsControl;

            if (lb != null && lb.HasItems)
                e.CanExecute = true;
            else
                e.CanExecute = false;
        }
        //bool selectionzoom;


        /// <summary>
        /// Shows the selected tag in the spectrum
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void dtgridsequences_MouseDoubleClick(object sender, MouseButtonEventArgs e)
        {
            if (dtgridsequences.CurrentCell.Item == null || !(dtgridsequences.CurrentCell.Item is FindSequenceTags.SequenceTag)) return;

            var theAxis = BottomChart.AxesX[0];
            //int i = 0;
            //foreach (var item in e.AddedItems)
            //{
            //    double end = ((MSViewer.FindSequenceTags.SequenceTag)(((object[])(e.AddedItems))[i])).End;
            //    double start = ((MSViewer.FindSequenceTags.SequenceTag)(((object[])(e.AddedItems))[i])).IndividualAAs[0].Start;
            //    //selectionzoom = true;
            //    //zoom(theAxis, start - ((end - start) * 0.2), ((end - start) * 0.2) + end);
            //    i++;
            //}

            var sequences = dtgridsequences.DataContext as IEnumerable<FindSequenceTags.SequenceTag>;

            if (dtgridsequences.CurrentCell.Item == null || !(dtgridsequences.CurrentCell.Item is FindSequenceTags.SequenceTag)) return;
            FindSequenceTags.SequenceTag items = (FindSequenceTags.SequenceTag)(dtgridsequences.CurrentCell.Item);
            if (!sequences.Where(a => a.Index == items.Index).Any()) return;

            if (sequences.Where(a => a.Index == items.Index).First().Visibility == "Rev" || sequences.Where(a => a.Index == items.Index).First().Visibility == "Yes")
            {
                chkSequenceTags_Unchecked_1(null, null);
                return;
            }

            sequences.Where(a => a.Index == items.Index).First().Visibility = "Yes";
            foreach (FindSequenceTags.AminoAcids a in items.IndividualAAs)
            {
                lastbar = new AnnotationBar()
                {
                    Start = a.Start,
                    End = a.End,
                    Name = a.Name,
                    Index = items.Index,
                    StartScore = a.StartScore,
                    EndScore = a.EndScore
                };
                AnnotationbarScore = a.Score;
                AddRangeLabel();
            }
            dtgridsequences.Items.Refresh();

            // Refreshes the chart to show the range lable bars
            if (BottomChart.AxesY[0].AxisMaximum is double) BottomChart.AxesY[0].AxisMaximum = Math.Round(((double)BottomChart.AxesY[0].AxisMaximum));
            if (BottomChart.AxesY[0].AxisMaximum is float) BottomChart.AxesY[0].AxisMaximum = Math.Round(((float)BottomChart.AxesY[0].AxisMaximum));
            //SetScaling();
        }

        /// <summary>
        /// Shows the selected tag in the spectrum, but in reversed sequence/position
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void dtgridsequences_ShowReverseTag(object sender, RoutedEventArgs e)
        {
            if (dtgridsequences.CurrentCell.Item == null || !(dtgridsequences.CurrentCell.Item is FindSequenceTags.SequenceTag)) return;

            var theAxis = BottomChart.AxesX[0];
            //int i = 0;
            //foreach (var item in e.AddedItems)
            //{
            //    double end = ((MSViewer.FindSequenceTags.SequenceTag)(((object[])(e.AddedItems))[i])).End;
            //    double start = ((MSViewer.FindSequenceTags.SequenceTag)(((object[])(e.AddedItems))[i])).IndividualAAs[0].Start;
            //    //selectionzoom = true;
            //    //zoom(theAxis, start - ((end - start) * 0.2), ((end - start) * 0.2) + end);
            //    i++;
            //}

            var sequences = dtgridsequences.DataContext as IEnumerable<FindSequenceTags.SequenceTag>;

            if (dtgridsequences.CurrentCell.Item == null || !(dtgridsequences.CurrentCell.Item is FindSequenceTags.SequenceTag)) return;
            FindSequenceTags.SequenceTag items = (FindSequenceTags.SequenceTag)(dtgridsequences.CurrentCell.Item);
            if (!sequences.Where(a => a.Index == items.Index).Any()) return;

            if (sequences.Where(a => a.Index == items.Index).First().Visibility == "Rev" || sequences.Where(a => a.Index == items.Index).First().Visibility == "Yes")
            {
                chkSequenceTags_Unchecked_1(null, null);
                return;
            }

            sequences.Where(a => a.Index == items.Index).First().Visibility = "Rev";
            foreach (FindSequenceTags.AminoAcids a in items.IndividualAAs)
            {
                lastbar = new AnnotationBar()
                {
                    Start = CurrentSpectrum.ParentMass.Value - a.Start,
                    End = CurrentSpectrum.ParentMass.Value - a.End,
                    Name = a.Name.Reverse(),
                    Index = items.Index,
                    StartScore = a.StartScore,
                    EndScore = a.EndScore
                };
                AnnotationbarScore = a.Score;
                AddRangeLabel();
            }
            dtgridsequences.Items.Refresh();

            // Refreshes the chart to show the range label bars
            if (BottomChart.AxesY[0].AxisMaximum is double) BottomChart.AxesY[0].AxisMaximum = Math.Round(((double)BottomChart.AxesY[0].AxisMaximum));
            if (BottomChart.AxesY[0].AxisMaximum is float) BottomChart.AxesY[0].AxisMaximum = Math.Round(((float)BottomChart.AxesY[0].AxisMaximum));
            //SetScaling();
        }


        private void Window_Closed_1(object sender, EventArgs e)
        {
            try
            {
                //string fileName = "SaveLayout";
                //var serializer = new XmlLayoutSerializer(dockManager);
                //using (var stream = new StreamWriter(string.Format(@".\AvalonDock_{0}.config", fileName)))
                //    serializer.Serialize(stream);
            }
            catch (Exception ex)
            {

            }
        }

        /// <summary>
        /// Remove the selected bar
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void chkSequenceTags_Unchecked_1(object sender, RoutedEventArgs e)
        {
            if (dtgridsequences.CurrentCell.Item == null || !(dtgridsequences.CurrentCell.Item is FindSequenceTags.SequenceTag)) return;
            FindSequenceTags.SequenceTag item = (FindSequenceTags.SequenceTag)dtgridsequences.CurrentCell.Item;
            if ((dtgridsequences.CurrentCell.Item as FindSequenceTags.SequenceTag).Visibility == "No") return;

            if ((dtgridsequences.CurrentCell.Item as FindSequenceTags.SequenceTag).Visibility == "Yes")
            {
                foreach (FindSequenceTags.AminoAcids a in item.IndividualAAs)
                {
                    var bar = new AnnotationBar()
                    {
                        Start = a.Start,
                        End = a.End,
                        Name = a.Name,
                        Index = item.Index,
                    };

                    //AnnotationbarScore = a.Score;
                    RemoveRangeLabel(bar, a.Score);
                }
            }
            else
            {
                foreach (FindSequenceTags.AminoAcids a in item.IndividualAAs)
                {
                    var bar = new AnnotationBar()
                    {
                        Start = CurrentSpectrum.ParentMass.Value - a.Start,
                        End = CurrentSpectrum.ParentMass.Value - a.End,
                        Name = new string(Enumerable.Reverse(a.Name).ToArray()),
                        Index = item.Index,
                    };

                    //AnnotationbarScore = a.Score;
                    RemoveRangeLabel(bar, a.Score);
                }
            }

            (dtgridsequences.CurrentCell.Item as FindSequenceTags.SequenceTag).Visibility = "No";

            dtgridsequences.Items.Refresh();
        }

        /// <summary>
        /// Updates the relative intensity values based on the visible items
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void chkHideScansWithNoMass_CheckChanged(object sender, RoutedEventArgs e)
        {
            try
            {
                if (mergeView == null) return;

                int i = 0;
                foreach (var aSpec in mgrspectra)
                {
                    if (chkHideScansWithMS1.IsChecked.Value == true)
                    {
                        if (chkHideScansWithNoMass.IsChecked.Value == false)
                        {
                            aSpec.IsVisible = true;
                        }
                        else if (chkHideScansWithNoMass.IsChecked.Value == true)
                        {
                            if (aSpec.MsLevel == SpecMsLevel.MS)
                            {
                                aSpec.IsVisible = true;
                            }
                            else
                            {
                                aSpec.IsVisible = false;
                            }
                            if (!aSpec.ParentMass.HasValue)
                            {
                                aSpec.IsVisible = false;
                            }
                            if (aSpec.MsLevel == SpecMsLevel.MS)
                            {
                                aSpec.IsVisible = true;
                            }
                        }
                    }
                    else if (chkHideScansWithMS1.IsChecked.Value == false)
                    {
                        if (chkHideScansWithNoMass.IsChecked.Value == true)
                        {
                            if (aSpec.MsLevel != SpecMsLevel.MS)
                            {
                                aSpec.IsVisible = true;
                            }
                            else
                            {
                                aSpec.IsVisible = false;
                            }
                            if (aSpec.ParentMass.HasValue)
                            {
                                aSpec.IsVisible = true;
                            }
                            else
                            {
                                aSpec.IsVisible = false;
                            }
                        }
                        if (chkHideScansWithNoMass.IsChecked.Value == false)
                        {
                            if (aSpec.ParentMass.HasValue)
                            {
                                aSpec.IsVisible = true;
                            }
                            else
                            {
                                aSpec.IsVisible = false;
                            }
                            if (aSpec.MsLevel == SpecMsLevel.MS)
                            {
                                aSpec.IsVisible = false;
                                i = i + 1;
                            }
                            else
                            {
                                aSpec.IsVisible = true;
                            }
                        }
                    }
                }

                UpdateRelativeIntensities();

                mergeView = new ListCollectionView(mgrspectra);

                // Based on: http://social.msdn.microsoft.com/Forums/en-US/915db4e8-0ccf-4c5b-97d3-b8898fcf4bac/filtering-observable-collection-using-collectionview?forum=wpf
                mergeView.Filter = (item) =>
                {
                    if (item == null) return false;
                    if (item is SpectrumInfo == false) return false;

                    // This is the filter to make the correct scans show up                    
                    return (item as SpectrumInfo).IsVisible;
                };
                this.grdMerge1.ItemsSource = mergeView;
                grdMerge1.DataContext = mergeView;
            }
            catch (Exception ex)
            {

            }

        }

        private void UpdateRelativeIntensities()
        {
            if (mgrspectra == null || !mgrspectra.Any(s => s.IsVisible)) return;

            var maxIntensity = mgrspectra.Where(s => s.IsVisible).Max(s => s.Intensity);
            foreach (var aSpec in mgrspectra.Where(s => s.IsVisible)) aSpec.RelativeIntensity = aSpec.Intensity / maxIntensity;
        }


        //private void UpdateRelativeIntensities()
        //{
        //    if (mergeView == null || mergeView.Count <= 1) return;

        //    var theView = mergeView.Cast<SpectrumInfo>();

        //    if (theView == null || !theView.Any()) return;

        //    var maxIntensity = theView.Max(s => s.Intensity);
        //    foreach (var aSpec in theView) aSpec.RelativeIntensity = aSpec.Intensity / maxIntensity;
        //}


        //private void chkHideScansWithNoMass_Checked(object sender, RoutedEventArgs e)
        //{
        //    if (mergeView == null) return;

        //    // Based on: http://social.msdn.microsoft.com/Forums/en-US/915db4e8-0ccf-4c5b-97d3-b8898fcf4bac/filtering-observable-collection-using-collectionview?forum=wpf
        //    mergeView.Filter = (item) =>
        //    {
        //        // This is the filter to make the Protein list only show results with a Protein ID
        //        return (item as SpectrumInfo).ParentMass.HasValue;
        //    };

        //    mergeView.Filter = null;  // clear? 
        //}

        //private void chkHideScansWithNoMass_Unchecked(object sender, RoutedEventArgs e)
        //{
        //    if (mergeView == null) return;

        //    mergeView.Filter = null;  // clear? 
        //}

        private void mnuDelete_Click_1(object sender, RoutedEventArgs e)
        {
            UpdateMonosOnDelete();
        }

        void UpdateMonosOnDelete()
        {
            if (dtgridMonoMasses.SelectedItem == null || !(dtgridMonoMasses.SelectedItem is DataPoint)) return;

            if (dtgridMonoMasses.SelectedItems.Count > 1)
            {
                int j = dtgridMonoMasses.SelectedItems.Count;
                int i = 0;
                while (i < j)
                {
                    if (dtgridMonoMasses.SelectedItem.ToString() != "{NewItemPlaceholder}")
                        CurrentMonoMasses.Remove(CurrentMonoMasses.Where(a => (a.XValue == ((DataPoint)(dtgridMonoMasses.SelectedItems[0])).XValue) && a.YValue == ((DataPoint)(dtgridMonoMasses.SelectedItems[0])).YValue && a.ZValue == ((DataPoint)(dtgridMonoMasses.SelectedItems[0])).ZValue).First());
                    i++;
                }
            }
            else
            {
                DataPoint item = (DataPoint)(dtgridMonoMasses.SelectedItem);
                CurrentMonoMasses.Remove(CurrentMonoMasses.Where(a => (a.XValue == item.XValue) && a.YValue == item.YValue && a.ZValue == item.ZValue).First());
            }

            ///FindAllSequenceTags(); //MERGE: Possible need to comment it out.
            //FindAllSequenceTags(CurrentIons);
        }

        private void mnuMono_Click_1(object sender, RoutedEventArgs e)
        {
            switch (Convert.ToString(((System.Windows.Controls.HeaderedItemsControl)(e.Source)).Header))
            {
                case "Primary":
                    imgActual.Visibility = System.Windows.Visibility.Visible;
                    imgMono.Visibility = System.Windows.Visibility.Collapsed;
                    imgPredicted.Visibility = System.Windows.Visibility.Collapsed;
                    //imgThermo.Visibility = System.Windows.Visibility.Collapsed;
                    setscale = scaleby.Primary;
                    SetScaling();
                    break;

                case "Mono":
                    imgActual.Visibility = System.Windows.Visibility.Collapsed;
                    imgMono.Visibility = System.Windows.Visibility.Visible;
                    imgPredicted.Visibility = System.Windows.Visibility.Collapsed;
                    //imgThermo.Visibility = System.Windows.Visibility.Collapsed;
                    setscale = scaleby.Mono;
                    SetScaling();
                    break;

                case "Predicted":
                    imgActual.Visibility = System.Windows.Visibility.Collapsed;
                    imgMono.Visibility = System.Windows.Visibility.Collapsed;
                    imgPredicted.Visibility = System.Windows.Visibility.Visible;
                    //imgThermo.Visibility = System.Windows.Visibility.Collapsed;
                    setscale = scaleby.Predicted;
                    SetScaling();
                    break;

                case "Thermo":
                    imgActual.Visibility = System.Windows.Visibility.Collapsed;
                    imgMono.Visibility = System.Windows.Visibility.Collapsed;
                    imgPredicted.Visibility = System.Windows.Visibility.Collapsed;
                    //imgThermo.Visibility = System.Windows.Visibility.Visible;
                    setscale = scaleby.Thermo;
                    SetScaling();
                    break;
                default:
                    break;
            }
        }
        /// <summary>
        /// Sets the scaling of the chart based on
        /// the users choice of having it set by
        /// either
        /// 1)Actual values
        /// 2)Predicted values
        /// 3)Primary values
        /// 4)Thermo values
        /// Uses the global variable setscale 
        /// for doing that.
        /// </summary>
        private void SetScaling()
        {
            if (zoomWidth > 0.0 && zoomWidth < 0.005) return;

            switch (setscale)
            {
                case scaleby.Primary:
                    //if (zoomWidth == 0) return;
                    Dispatcher.Invoke((Action)(() =>
                    {
                        try
                        {
                            setdefaultscaling();
                        }
                        catch { }
                    }), new TimeSpan(0, 0, 3));
                    break;
                case scaleby.Mono:
                    Dispatcher.Invoke((Action)(() =>
                    {
                        try
                        {
                            if (zoomWidth == 0.0)
                            {
                                if (this.MonoMassSeries.DataPoints.Where(i => (double)(i.XValue) > (double)BottomChart.AxesX[0].AxisMinimum && (double)i.XValue < (double)BottomChart.AxesX[0].AxisMaximum).Any())
                                {
                                    this.BottomChart.AxesY[0].AxisMaximum = this.MonoMassSeries.DataPoints.Where(i => (double)(i.XValue) > (double)BottomChart.AxesX[0].AxisMinimum && (double)i.XValue < (double)BottomChart.AxesX[0].AxisMaximum).MaxBy(p => p.YValue).YValue;
                                }
                                else
                                {
                                    setdefaultscaling();
                                }
                            }
                            else
                            {
                                var zoomMin = (double)BottomChart.AxesX[0].AxisMinimum + ((((double)BottomChart.AxesX[0].AxisMaximum - zoomWidth) - (double)BottomChart.AxesX[0].AxisMinimum) * (lastScrollLocation / 100.0));
                                var zoomMax = zoomMin + zoomWidth;
                                if (this.MonoMassSeries.DataPoints.Where(i => (double)(i.XValue) > zoomMin && (double)i.XValue < zoomMax).Any())
                                {
                                    this.BottomChart.AxesY[0].AxisMaximum = this.MonoMassSeries.DataPoints.Where(i => (double)(i.XValue) > zoomMin && (double)i.XValue < zoomMax).MaxBy(p => p.YValue).YValue;
                                }
                                else
                                {
                                    setdefaultscaling();
                                }
                            }
                        }
                        catch { }
                    }), new TimeSpan(0, 0, 3));
                    break;
                case scaleby.Predicted:
                    Dispatcher.Invoke((Action)(() =>
                    {
                        try
                        {
                            if (zoomWidth == 0.0)
                            {
                                if (Predictedseries.DataPoints.Where(i => (double)(i.XValue) > (double)BottomChart.AxesX[0].AxisMinimum && (double)i.XValue < (double)BottomChart.AxesX[0].AxisMaximum).Any())
                                {
                                    var predictedMax = this.Predictedseries.DataPoints.Where(i => Convert.ToDouble(i.XValue) > (double)BottomChart.AxesX[0].AxisMinimum && Convert.ToDouble(i.XValue) < (double)BottomChart.AxesX[0].AxisMaximum).MaxBy(p => p.YValue).YValue;

                                    this.BottomChart.AxesY[0].AxisMaximum = predictedMax;
                                }
                                else
                                {
                                    setdefaultscaling();
                                }
                            }
                            else
                            {
                                var zoomMin = (double)BottomChart.AxesX[0].AxisMinimum + ((((double)BottomChart.AxesX[0].AxisMaximum - zoomWidth) - (double)BottomChart.AxesX[0].AxisMinimum) * (lastScrollLocation / 100.0));
                                var zoomMax = zoomMin + zoomWidth;
                                if (this.Predictedseries.DataPoints.Where(i => Convert.ToDouble(i.XValue) > zoomMin && Convert.ToDouble(i.XValue) < zoomMax).Any())
                                {
                                    var predictedMax = this.Predictedseries.DataPoints.Where(i => Convert.ToDouble(i.XValue) > zoomMin && Convert.ToDouble(i.XValue) < zoomMax).MaxBy(p => p.YValue).YValue;

                                    this.BottomChart.AxesY[0].AxisMaximum = predictedMax;
                                }
                                else
                                {
                                    setdefaultscaling();
                                }
                            }
                        }
                        catch { }
                    }), new TimeSpan(0, 0, 3));
                    break;
                case scaleby.Thermo:
                    if (ThermoPoint == null || ThermoPoint.Count() <= 0) break;

                    Dispatcher.Invoke((Action)(() =>
                    {
                        if (zoomWidth == 0.0)
                        {
                            if (ThermoPoint.MinBy(tm => tm.Mass).Mass > (double)BottomChart.AxesX[0].AxisMinimum && ThermoPoint.MaxBy(tm => tm.Mass).Mass < (double)BottomChart.AxesX[0].AxisMaximum)
                            {
                                this.BottomChart.AxesY[0].AxisMaximum = this.ThermoPoint.MaxBy(m => m.Intensity).Intensity;
                            }
                            else
                            {
                                setdefaultscaling();
                            }
                        }
                        else
                        {
                            var zoomMin = (double)BottomChart.AxesX[0].AxisMinimum + ((((double)BottomChart.AxesX[0].AxisMaximum - zoomWidth) - (double)BottomChart.AxesX[0].AxisMinimum) * (lastScrollLocation / 100.0));
                            var zoomMax = zoomMin + zoomWidth;
                            if (ThermoPoint.MaxBy(tm => tm.Mass).Mass > zoomMin && ThermoPoint.MinBy(tm => tm.Mass).Mass < zoomMax)
                            {
                                this.BottomChart.AxesY[0].AxisMaximum = this.ThermoPoint.Where(a => a.Mass > zoomMin && a.Mass < zoomMax).MaxBy(a => a.Intensity).Intensity;
                            }
                            else
                            {
                                setdefaultscaling();
                            }
                        }
                    }), new TimeSpan(0, 0, 3));
                    break;
                default:

                    break;
            }
        }

        /// <summary>
        /// Sets the scaling to CurrentSpectrum.
        /// </summary>
        private void setdefaultscaling()
        {
            if (BottomChart.AxesX[0].AxisMaximum == null || BottomChart.AxesX[0].AxisMinimum == null) return;

            var axisMax = (double)BottomChart.AxesX[0].AxisMaximum;
            var axisMin = (double)BottomChart.AxesX[0].AxisMinimum;

            var zoomMin = axisMin + (((axisMax - zoomWidth) - axisMin) * (lastScrollLocation / 100.0));
            var zoomMax = zoomMin + zoomWidth;

            CurrentSpectrum.SortByMass();

            if (zoomWidth != 0)
            {
                if (CurrentSpectrum.GetMaxYValueForXRange(zoomMin, zoomMax, Properties.Settings.Default.UseHybridIntensities) == 0)
                {
                    var YMax = ReverseCurrentSpectrum.GetMaxYValueForXRange(zoomMin, zoomMax, Properties.Settings.Default.UseHybridIntensities);
                    if (YMax <= 1) return;
                    this.BottomChart.AxesY[0].AxisMaximum = YMax;
                    return;
                }
                else if (ReverseCurrentSpectrum.GetMaxYValueForXRange(zoomMin, zoomMax, Properties.Settings.Default.UseHybridIntensities) == 0)
                {
                    var YMax = CurrentSpectrum.GetMaxYValueForXRange(zoomMin, zoomMax, Properties.Settings.Default.UseHybridIntensities);
                    if (YMax <= 1) return;
                    this.BottomChart.AxesY[0].AxisMaximum = YMax;
                    return;
                }
                if (forwardorreverse == null)
                {
                    var YMax = Math.Max(CurrentSpectrum.GetMaxYValueForXRange(zoomMin, zoomMax, Properties.Settings.Default.UseHybridIntensities), ReverseCurrentSpectrum.GetMaxYValueForXRange(zoomMin, zoomMax, Properties.Settings.Default.UseHybridIntensities));
                    if (YMax <= 1) return;
                    this.BottomChart.AxesY[0].AxisMaximum = YMax;
                }
                else if (forwardorreverse != null && forwardorreverse == true)
                {
                    var YMax = CurrentSpectrum.GetMaxYValueForXRange(zoomMin, zoomMax, Properties.Settings.Default.UseHybridIntensities);
                    if (YMax <= 1) return;
                    this.BottomChart.AxesY[0].AxisMaximum = YMax;
                }
                else if (forwardorreverse != null && forwardorreverse == false)
                {
                    var YMax = ReverseCurrentSpectrum.GetMaxYValueForXRange(zoomMin, zoomMax, Properties.Settings.Default.UseHybridIntensities);
                    if (YMax <= 1) return;
                    this.BottomChart.AxesY[0].AxisMaximum = YMax;
                }
            }
            else
            {
                if (!CurrentSpectrum.Any()) return;

                if (!ReverseCurrentSpectrum.Any()) return;

                float xmax;

                if (Properties.Settings.Default.UseHybridIntensities)
                {
                    xmax = Math.Max(CurrentSpectrum.MaxBy(a => a.HybridIntensity).HybridIntensity, ReverseCurrentSpectrum.MaxBy(a => a.HybridIntensity).HybridIntensity);
                }
                else
                {
                    xmax = Math.Max(CurrentSpectrum.MaxBy(a => a.Intensity).Intensity, ReverseCurrentSpectrum.MaxBy(a => a.Intensity).Intensity);
                }

                if (xmax <= 1) return;

                this.BottomChart.AxesY[0].AxisMaximum = xmax;
            }
        }
        BackgroundWorker bgDetectParents = new BackgroundWorker();

        //bool ParentIonsDetected = false;

        List<SpectrumInfo> newspecinfo = new List<SpectrumInfo>();

        bool forceparentmassfrommgrspectra = false;

        /// <summary>
        /// Detects the all of the ParentMass of all the scans. 
        /// If the scan is of type MSMS.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void btnDetectParents_Click(object sender, RoutedEventArgs e)
        {
            DetectParentMasses(mgrspectra);
        }


        /// <summary>
        /// Detect Parent Masses and show busy dialogs to show progress and cancel
        /// </summary>
        /// <param name="spectraInfo">List of scans to detect</param>
        /// <param name="indices">Scan Index list to detect</param>
        private void DetectParentMasses(IEnumerable<SpectrumInfo> spectraInfo)
        {
            ///Show the progress bar
            Dispatcher.Invoke(new Action(() =>
            {
                this.busyTic.IsBusy = true;
                this.BusyProgressText = "Detecting Parent Ions...";
                btnDetectParents.IsEnabled = false;
            }));

            ///If the Detect Parents is already clicked then should cancel the current
            if (bgDetectParents.IsBusy)
            {
                Debug.Print("Cancelling old worker. " + bgDetectParents.GetHashCode());
                bgDetectParents.CancelAsync();
                Thread.Sleep(20);
            }

            bgDetectParents = new BackgroundWorker() { WorkerSupportsCancellation = true };  ///Allow to cancel the worker
            bgDetectParents.RunWorkerCompleted += bgDetectParents_RunWorkerCompleted; ///On worker completed should stop the busy indicator.
            bgDetectParents.DoWork += (s, args) =>
            {
                Debug.Print("Detect Parents DoWork Start. " + s.GetHashCode());
                var worker = s as BackgroundWorker;
                float i = 0;
                try
                {
                    var specCount = spectraInfo.Count();
                    List<SpectrumInfo> lstnewspecinfo = new List<SpectrumInfo>();
                    foreach (var aScanInfo in spectraInfo)
                    {
                        if (worker.CancellationPending)
                        {
                            break;
                        }

                        this.BusyProgressValue = (i++ / (float)specCount) * 100;

                        if (forceparentmassfrommgrspectra)
                        {
                            if (aScanInfo.ParentMass.HasValue)
                            {
                                lstnewspecinfo.Add(MainPointProvider.ForceParentInfo(aScanInfo));
                            }
                            else
                            {
                                if (aScanInfo.MsLevel != SpecMsLevel.MS)
                                {
                                    MainPointProvider.SetParentInfo(aScanInfo, Properties.Settings.Default.PrecursorFromProductEnabled);
                                    lstnewspecinfo.Add(aScanInfo);
                                }
                                //lstnewspecinfo.Add(MainPointProvider.SetParentInfo(aScanInfo));
                            }

                        }
                        else if (settingparentmassfromMergeSpectra)
                        {
                            newspecinfo.Add(MainPointProvider.ForceParentInfo(aScanInfo));
                        }
                        else
                        {
                            if (aScanInfo.ParentMass.HasValue)
                            {
                                lstnewspecinfo.Add(MainPointProvider.ForceParentInfo(aScanInfo));
                            }
                            else
                            {
                                if (aScanInfo.MsLevel != SpecMsLevel.MS)
                                {
                                    MainPointProvider.SetParentInfo(aScanInfo, Properties.Settings.Default.PrecursorFromProductEnabled);
                                    lstnewspecinfo.Add(aScanInfo);
                                }
                                //lstnewspecinfo.Add(MainPointProvider.SetParentInfo(aScanInfo));
                            }

                            //MainPointProvider.SetParentInfo(aScanInfo);
                        }
                    }

                    if (lstnewspecinfo.Count != 0)
                    {
                        forceparentmassfrommgrspectra = false;
                        settingparentmassfromMergeSpectra = false;
                        foreach (var mgspec in mgrspectra)
                        {
                            if (lstnewspecinfo.Any(a => a.ScanNumber == mgspec.ScanNumber))
                            {
                                var newspecinfo = lstnewspecinfo.First(a => a.ScanNumber == mgspec.ScanNumber);
                                if (newspecinfo.ParentIon != null)
                                {
                                    mgspec.ParentIon = newspecinfo.ParentIon;
                                    mgspec.ParentMass = newspecinfo.ParentMass;
                                    mgspec.ParentZ = newspecinfo.ParentZ;
                                }
                            }
                        }
                    }
                    // Calculate TimeSort Values
                    spectraInfo.PopulateTimeSort();
                }
                catch (Exception ex)
                {
                    args.Result = ex;
                }
            };

            chkHideScansWithNoMass.IsEnabled = false;

            // Disable the Merging Ions updates that the Parent ion detection will fire.  
            SignalProcessor.FireChangeEvents = false;
            bgDetectParents.RunWorkerAsync();
        }

        void bgDetectParents_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            if (e.Result != null && e.Result is Exception)
            {
                System.Windows.MessageBox.Show((e.Result as Exception).Message + "\n\n" + (e.Result as Exception).StackTrace, "Error while detecting parent ions!", MessageBoxButton.OK, MessageBoxImage.Error);
            }

            // Re-Enable the Merging Ions updates  
            SignalProcessor.FireChangeEvents = true;

            this.busyTic.IsBusy = false;

            chkHideScansWithNoMass_CheckChanged(null, null);

            chkHideScansWithNoMass.IsEnabled = true;
            if (settingparentmassfromMergeSpectra)
            {
                mgrspectra.Clear();
                if (settingparentmassfromMergeSpectra)
                {
                    foreach (var nspec in newspecinfo)
                    {
                        mgrspectra.Add(nspec);
                    }
                }
                mergeView = new ListCollectionView(newspecinfo);
            }
            else
            {
                mergeView = new ListCollectionView(mgrspectra);
            }
            Dispatcher.Invoke(new Action(() =>
            {
                // Based on: http://social.msdn.microsoft.com/Forums/en-US/915db4e8-0ccf-4c5b-97d3-b8898fcf4bac/filtering-observable-collection-using-collectionview?forum=wpf
                mergeView.Filter = (item) =>
                {
                    if (item == null) return false;
                    if (item is SpectrumInfo == false) return false;

                    // This is the filter to make the correct scans show up                    
                    return (item as SpectrumInfo).IsVisible;
                };
                this.grdMerge1.ItemsSource = mergeView;
                grdMerge1.DataContext = mergeView;
            }));
            btnDetectParents.IsEnabled = true;
            settingparentmassfromMergeSpectra = false;
            SortDataGrid(grdMerge1, 0);  // Column 0 is the hidden TimeSort column
        }

        public static void SortDataGrid(DataGrid dataGrid, int columnIndex = 0, ListSortDirection sortDirection = ListSortDirection.Ascending)
        {
            // http://stackoverflow.com/questions/16956251/sort-a-wpf-datagrid-programmatically

            var column = dataGrid.Columns[columnIndex];

            var dtgrid = dataGrid;

            // Clear current sort descriptions
            dtgrid.Items.SortDescriptions.Clear();

            // Add the new sort description
            dtgrid.Items.SortDescriptions.Add(new SortDescription(column.SortMemberPath, sortDirection));

            // Apply sort
            foreach (var col in dtgrid.Columns)
            {
                col.SortDirection = null;
            }
            column.SortDirection = sortDirection;

            dataGrid = dtgrid;

            // Refresh items to display sort
            dataGrid.Items.Refresh();
        }

        private void CommandBinding_Executed_1(object sender, ExecutedRoutedEventArgs e)
        {
            UpdateMonosOnDelete();
        }


        private void btngrpbyParent_Click_1(object sender, RoutedEventArgs e)
        {
            Dispatcher.Invoke(new Action(() =>
            {
                grdMerge1.Items.Refresh();
            }));
        }


        private void ThermoSlider_ValueChanged_1(object sender, RoutedPropertyChangedEventArgs<double> e)
        {
            if (BottomChart == null) return;

            try
            {
                BottomChart.Series[0].Opacity = 1 - e.NewValue;
                ReverseSeries.Opacity = 1 - e.NewValue;
                ThermoFischer.Opacity = e.NewValue;
                if (e.NewValue > 0.1)
                {
                    ReverseSeries.Opacity = 0;
                    sldDirectionSlider.IsEnabled = false;
                }
                else
                {
                    sldDirectionSlider.IsEnabled = true;
                }
            }
            catch { }
        }

        private void ClearAminoAcids_Click(object sender = null, RoutedEventArgs e = null, SearchResult sequ = null, bool blastp = false, string blastpstring = null)
        {
            AnnotationBars1.DataPoints.Clear();
            AnnotationBars2.DataPoints.Clear();
            AnnotationBars3.DataPoints.Clear();
            GrayBarSeries.DataPoints.Clear();
            AnnotationBarsBlue.DataPoints.Clear();
            RedBarSeries.DataPoints.Clear();
            WaterLossSeries.DataPoints.Clear();
            CTerminusLine.DataPoints.Clear();


            if (dtgridsequences.DataContext != null && dtgridsequences.DataContext is IEnumerable<FindSequenceTags.SequenceTag> && (dtgridsequences.DataContext as IEnumerable<FindSequenceTags.SequenceTag>).Count() > 0)
            {
                if (sequ != null)
                {

                    if ((dtgrdSearchSequence.ItemsSource is List<MSViewer.SearchResult>) && (dtgrdSearchSequence.ItemsSource as List<MSViewer.SearchResult>).Where(a => a.Checked).Any())  //(dtgrdSearchSequence.ItemsSource is List<MSViewer.SequenceSearch>) &&
                    {
                        sequ = (dtgrdSearchSequence.ItemsSource as List<MSViewer.SearchResult>).Where(a => a.Checked).First();
                    }

                    var alltagsindtgridsequences = (dtgridsequences.DataContext as List<FindSequenceTags.SequenceTag>);// sequ.AllsqsTags.Where(a => a.Sequence.Length >= Properties.Settings.Default.SequenceTagLength).ToList();
                    List<FindSequenceTags.SequenceTag> sequencetags = new List<FindSequenceTags.SequenceTag>();

                    sequencetags = (from sq in sequ.InternalMT.Where(a => a.confidence == AminAcidConfidence.Sure && a.Length > 1).ToList()
                                    join dt in alltagsindtgridsequences on sq.SequenceTag equals dt.Sequence.Replace("I", "L")
                                    select dt).ToList();



                    if (blastp)
                    {
                        string firstseq = string.Empty;

                        if (sequ.InternalMT.Any(a => a.SequenceTag != null
                             && (blastpstring.Contains(a.SequenceTag) || blastpstring.Contains(a.SequenceTag.Reverse()))))
                        {
                            if (alltagsindtgridsequences.Any(a => a.Sequence == (blastpstring) || a.Sequence == (blastpstring.Reverse())))
                            {
                                sequencetags.Add(alltagsindtgridsequences.Where(a => a.Sequence == (blastpstring) || a.Sequence.Contains(ReverseString.Reverse(blastpstring))).First());
                            }
                        }

                        foreach (var dt in sequ.InternalMT.Where(a => a.confidence == AminAcidConfidence.Sure && a.Length > 1).ToList())
                        {
                            if (dt.SequenceTag == null) continue;
                            if (alltagsindtgridsequences.Any(a => a.Sequence.Contains(dt.SequenceTag) || a.Sequence.Contains(ReverseString.Reverse(dt.SequenceTag))))
                            {
                                if (sequencetags.Any(a => (a.Sequence.Contains(dt.SequenceTag) || a.Sequence.Contains(ReverseString.Reverse(dt.SequenceTag))))) continue;
                                sequencetags.Add(alltagsindtgridsequences.Where(a => a.Sequence.Contains(dt.SequenceTag) || a.Sequence.Contains(ReverseString.Reverse(dt.SequenceTag))).First());
                            }
                        }
                    }


                    int iii = 0;
                    int countalltags = alltagsindtgridsequences.Count;
                    while (iii < countalltags)
                    {
                        alltagsindtgridsequences[iii].bkgcolor = "0";
                        iii++;
                    }
                    iii = 0;

                    string selectedseq = string.Empty;

                    if ((dtgrdSearchSequence.ItemsSource is List<MSViewer.SearchResult>))
                    {
                        selectedseq = sequ.CoveredSequence;
                    }
                    string selectedseqIwithL = selectedseq.Replace("I", "L");
                    while (iii < countalltags)
                    {
                        if (sequencetags.Any(a => a.Sequence == (alltagsindtgridsequences[iii].Sequence)) || sequencetags.Any(a => a.Sequence == ReverseString.Reverse(alltagsindtgridsequences[iii].Sequence))) ///If the sequence is part of the sequence list and also part of the selected sequence then should show it in green.
                        {
                            if ((selectedseqIwithL.Contains(alltagsindtgridsequences[iii].Sequence) ||
                            ReverseString.Reverse(selectedseqIwithL).Contains(alltagsindtgridsequences[iii].Sequence)))
                            {
                                alltagsindtgridsequences[iii].bkgcolor = "2";
                            }
                            else
                            {
                                alltagsindtgridsequences[iii].bkgcolor = "1";
                            }
                        }
                        else if (selectedseqIwithL.Contains(alltagsindtgridsequences[iii].Sequence) || ReverseString.Reverse(selectedseqIwithL).Contains(alltagsindtgridsequences[iii].Sequence)) //If there is a partial match then should highlight it yellow.
                        {
                            alltagsindtgridsequences[iii].bkgcolor = "1";
                        }
                        iii++;
                    }

                    alltagsindtgridsequences = alltagsindtgridsequences.OrderByDescending(a => a.bkgcolor).ToList();

                    dtgridsequences.DataContext = null;
                    dtgridsequences.DataContext = alltagsindtgridsequences;

                }
                foreach (var aTag in (dtgridsequences.DataContext as IEnumerable<FindSequenceTags.SequenceTag>)) aTag.Visibility = "No";
            }
            dtgridsequences.Items.Refresh();
            btnClearSpectrumAll.IsOpen = false;
        }


        private void DirectionSlider_ValueChanged(object sender, RoutedPropertyChangedEventArgs<double> e)
        {
            if (BottomChart == null) return;
            try
            {
                if (e.NewValue >= 0.45 && e.NewValue <= 0.55)
                {
                    lblReverse.Opacity = 1.0;
                    lblForward.Opacity = 1.0;
                    BottomChartPoints.Opacity = 1.0;
                    ReverseSeries.Opacity = 1.0;
                    forwardorreverse = null;
                }
                else if (e.NewValue > 0.55)
                {
                    lblForward.Opacity = 1.0;
                    BottomChartPoints.Opacity = 1.0;
                    ReverseSeries.Opacity = 1.00 - 2 * (e.NewValue - 0.5);
                    lblReverse.Opacity = 1.00 - 2 * (e.NewValue - 0.5);
                    forwardorreverse = true;
                }
                else if (e.NewValue < 0.45)
                {
                    lblReverse.Opacity = 1.0;
                    lblForward.Opacity = 2 * e.NewValue;
                    BottomChartPoints.Opacity = 2 * e.NewValue;
                    ReverseSeries.Opacity = 1.0;
                    forwardorreverse = false;
                }
                SetScaling();
            }
            catch
            {
            }
        }

        private void btnFindSequence_Click(object sender, RoutedEventArgs e)
        {
            using (new WaitCursor())
            {
                if (!monosfound && CurrentSpectrum.ParentIon != null)
                {
                    FindMonos();
                    monosfound = true;
                }

                Findtags();
                btnFindSequenceinSpectrum.IsOpen = false;
            }
        }

        private void btnClearAll(object sender, RoutedEventArgs e)
        {
            try
            {
                ClearMonos_Click(null, null);
                ClearAminoAcids_Click();
                ClearRed_Click();

                btnClearMarkers1_Click(null, null);
                btnClearMarkers2_Click(null, null);
                GreenMarkersSeriesLite.DataPoints.Clear();
                RedMarkersSeriesLite.DataPoints.Clear();

                AmmoniaLossSeries.DataPoints.Clear();
                MonoMassesfordbSequence.Visibility = System.Windows.Visibility.Hidden;
                //sequences.Clear();
                dtgridsequences.DataContext = null; //.Items.Refresh();
                dtgridsequences.Visibility = System.Windows.Visibility.Collapsed;
                ClearSequenceMatch();
                txtMatchSequence.IsEnabled = false;
                btnMatch.IsEnabled = false;
                btnFindAA.Visibility = System.Windows.Visibility.Visible;
                MonoMassesfordbSequence.DataSource = null;
                btnClearSpectrumAll.IsOpen = false;
            }
            catch
            {
                Debug.Print("Unexpected Exception in ClearAll.");
            }
        }

        private void txtSearch_TextChanged(object sender, TextChangedEventArgs e)
        {

        }

        List<SequenceMatching> matches = new List<SequenceMatching>();

        string matchseq = string.Empty;

        private void btnMatch_Click(object sender, RoutedEventArgs e)
        {
            //ApplyHighlighting.Findmatches();
            //return;

            matches.Clear();
            TextRange matchsequence = new TextRange(txtMatchSequence.Document.ContentStart, txtMatchSequence.Document.ContentEnd);
            matchseq = matchsequence.Text;
            string ModifiedSequenceForL = matchsequence.Text.Replace('I', 'L');


            char[] reverse = ModifiedSequenceForL.ToCharArray();

            Array.Reverse(reverse);

            string reversesequence = new string(reverse);

            int mlength = reversesequence.Length;

            int length = matchsequence.Text.Length;

            this.paragraph = new Paragraph();
            txtMatchSequence.Document = new FlowDocument(paragraph);

            foreach (FindSequenceTags.SequenceTag sq in FindAllSequenceTags(CurrentIons, sequencetagmass))
            {
                var mt = ModifiedSequenceForL.IndexOf(sq.Sequence);

                if (mt != -1)
                {
                    matches.Add(new SequenceMatching
                    {
                        start = mt,
                        end = sq.Sequence.Length + mt - 1,
                        sequence = matchsequence.Text.Substring(mt, sq.Sequence.Length),
                        match = true,
                    });
                }

                mt = reversesequence.IndexOf(sq.Sequence);

                if (mt != -1)
                {
                    matches.Add(new SequenceMatching
                    {
                        start = length - sq.Sequence.Length - mt,
                        end = length - mt - 1,
                        sequence = matchsequence.Text.Substring(length - sq.Sequence.Length - mt, sq.Sequence.Length),
                        match = true,
                    });
                }
            }

            matches = matches.OrderByDescending(a => a.sequence.Length).ToList();

            List<SequenceMatching> newmatchlist = new List<SequenceMatching>();
            List<SequenceMatching> removematching = new List<SequenceMatching>();
            int countmatch = 1;
            foreach (SequenceMatching a in matches)
            {
                foreach (SequenceMatching b in matches.GetRange(countmatch, matches.Count - countmatch))
                {
                    if (b.start >= a.start && b.end <= a.end)
                    {
                        if (newmatchlist.Where(m => m.sequence.Contains(b.sequence)).Any()) continue;
                        newmatchlist.Add(new SequenceMatching
                        {
                            end = a.end,
                            start = a.start,
                            sequence = a.sequence,
                            match = a.match,

                        });
                        removematching.Add(b);
                    }
                    else if (b.start <= a.start & b.end >= a.start & !(b.end >= a.end))
                    {
                        if (newmatchlist.Where(m => m.sequence.Contains(b.sequence)).Any()) continue;
                        newmatchlist.Add(new SequenceMatching
                        {
                            end = a.end,
                            start = b.start,
                            sequence = b.sequence + matchseq.Substring(b.end + 1, a.end - b.end),
                            match = true
                        });
                        removematching.Add(b);
                    }
                    else if (!(b.start <= a.start) & b.end >= a.end & b.start <= a.end)
                    {
                        if (newmatchlist.Where(m => m.sequence.Contains(b.sequence)).Any()) continue;
                        newmatchlist.Add(new SequenceMatching
                        {
                            end = b.end,
                            start = a.start,
                            sequence = a.sequence + matchseq.Substring(a.end + 1, b.end - a.end),
                            match = true
                        });
                        removematching.Add(a);
                    }
                }
                countmatch++;
            }


            removematching = removematching.GroupBy(a => a.sequence).Select(b => b.First()).ToList();

            foreach (SequenceMatching sq in removematching)
            {
                matches.Remove(matches.Where(a => a.sequence == sq.sequence).First());
            }

            removematching.Clear();


            foreach (SequenceMatching mtch in newmatchlist.OrderByDescending(a => a.sequence.Length))
            {
                var ss = (from SequenceMatching sss in newmatchlist
                          where sss.sequence.StartsWith(mtch.sequence)
                          select sss).ToList();

                if (ss.Count > 1)
                {
                    removematching.Add(new SequenceMatching
                    {
                        sequence = mtch.sequence
                    });
                }
            }

            removematching = removematching.GroupBy(a => a.sequence).Select(b => b.First()).ToList();

            foreach (SequenceMatching sq in removematching)
            {
                newmatchlist.Remove(newmatchlist.Where(a => a.sequence == sq.sequence).First());
            }

            removematching.Clear();
            foreach (SequenceMatching mtch in newmatchlist.OrderByDescending(a => a.sequence.Length))
            {
                var ss = (from SequenceMatching sss in newmatchlist
                          where sss.sequence.EndsWith(mtch.sequence)
                          select sss).ToList();

                if (ss.Count > 1)
                {
                    removematching.Add(new SequenceMatching
                    {
                        sequence = mtch.sequence
                    });
                }
            }

            foreach (SequenceMatching sq in removematching)
            {
                newmatchlist.Remove(newmatchlist.Where(a => a.sequence == sq.sequence).First());
            }
            removematching.Clear();



            matches.AddRange(newmatchlist);

            foreach (SequenceMatching mtch in matches.OrderByDescending(a => a.sequence.Length))
            {
                var ss = (from SequenceMatching sss in matches
                          where sss.sequence.StartsWith(mtch.sequence)
                          select sss).ToList();

                if (ss.Count > 1)
                {
                    removematching.Add(new SequenceMatching
                    {
                        sequence = mtch.sequence
                    });
                }
            }

            removematching = removematching.GroupBy(a => a.sequence).Select(b => b.First()).ToList();

            foreach (SequenceMatching sq in removematching)
            {
                matches.Remove(matches.Where(a => a.sequence == sq.sequence).First());
            }

            removematching.Clear();
            foreach (SequenceMatching mtch in matches.OrderByDescending(a => a.sequence.Length))
            {
                var ss = (from SequenceMatching sss in matches
                          where sss.sequence.EndsWith(mtch.sequence)
                          select sss).ToList();

                if (ss.Count > 1)
                {
                    removematching.Add(new SequenceMatching
                    {
                        sequence = mtch.sequence
                    });
                }
            }

            foreach (SequenceMatching sq in removematching)
            {
                matches.Remove(matches.Where(a => a.sequence == sq.sequence).First());
            }

            removematching.Clear();


            string[] splitstring = matches.Select(a => a.sequence).ToArray();

            string[] abc = matchsequence.Text.Split(splitstring, StringSplitOptions.RemoveEmptyEntries);

            foreach (string a in abc)
            {
                int index = matchsequence.Text.IndexOf(a);
                matches.Add(new SequenceMatching
                {
                    start = index,
                    end = a.Length + index,
                    sequence = a,
                    match = false
                });
            }

            matches = matches.OrderBy(a => a.start).ToList();

            foreach (SequenceMatching match in matches)
            {
                if (!match.match)
                {
                    paragraph.Inlines.Add(new Run(match.sequence)
                    {
                        FontSize = 14.5
                    });
                }
                else
                {
                    paragraph.Inlines.Add(new Bold(new Run(match.sequence))
                    {
                        FontSize = 14.5,
                        Foreground = System.Windows.Media.Brushes.Green,
                        Background = System.Windows.Media.Brushes.Yellow
                    });
                }
            }
        }


        private void ClearSequenceMatch()
        {
            paragraph = new Paragraph();
            paragraph.Inlines.Clear();
            txtMatchSequence.SelectAll();
            string selectedtext = txtMatchSequence.Selection.Text;
            txtMatchSequence.Selection.Text = "";
            this.paragraph = new Paragraph();
            txtMatchSequence.Document = new FlowDocument(paragraph);
            paragraph.Inlines.Add(new Run(matchseq)
            {
                FontSize = 14.5
            });
        }

        /// <summary>
        /// Clears all the filters in the Protein Tab
        /// </summary>
        private void ClearFilters()
        {
            txtFilterSequences.Text = string.Empty;
            txtsrchDescription.Text = string.Empty;
            txtAccessionSearch.Text = string.Empty;
            var urisource = new Uri("pack://application:,,,/" + assemblyname + ";component/Icons/White-funnel-th.png");
            System.Windows.Controls.Image imgaccessiondown = FindVisualChildByName<System.Windows.Controls.Image>(dtgrdSearchSequence, "imgAccessiondown");
            imgaccessiondown.Tag = "imgdown";
            imgaccessiondown.Source = new BitmapImage(urisource);
            System.Windows.Controls.Image imgDescriptiondown = FindVisualChildByName<System.Windows.Controls.Image>(dtgrdSearchSequence, "imgdownDescription");
            imgDescriptiondown.Tag = "imgdown";
            imgDescriptiondown.Source = new BitmapImage(urisource);
            System.Windows.Controls.Image imgsequencedown = FindVisualChildByName<System.Windows.Controls.Image>(dtgrdSearchSequence, "imgSequencesSearch");
            imgsequencedown.Tag = "imgdown";
            imgsequencedown.Source = new BitmapImage(urisource);
        }

        bool fromsearchtags = false;
        private void btnfindsqs_Click(object sender, RoutedEventArgs e)
        {
            if (isnotconfirmedornot)
            {
                clearspectrumfortheaminoacids();
                return;
            }

            var x = sender as Button;
            string tag = Convert.ToString(x.Tag);
            Pairmatch = tag;
            if (!fromautoscan)
                tabProteinSearch.Focus();
            SequenceMatch = tag;
            fromsearchtags = true;
            ClearFilters();
            var alltagsindtgridsequences = (dtgridsequences.DataContext as List<FindSequenceTags.SequenceTag>).Where(a => a.Sequence.Length >= Properties.Settings.Default.SequenceTagLength).ToList();

            int i = 0;
            int count = alltagsindtgridsequences.Count;
            while (i < count)
            {
                alltagsindtgridsequences[i].Checked = false;
                i++;
            }

            Dispatcher.Invoke(new Action(() =>
            {
                dtgridsequences.DataContext = null;
                dtgridsequences.DataContext = alltagsindtgridsequences;
            }));

            if (CurrentSpectrum.ParentIon == null)
            {
                BackgroundWorker bgworkersetparentmassfromsqstags = new BackgroundWorker();
                bgworkersetparentmassfromsqstags.DoWork += bgworkersetparentmassfromsqstags_DoWork;
                bgworkersetparentmassfromsqstags.RunWorkerAsync(tag);
            }
            else
            {
                SearchDataGrid(tag);
            }
        }

        void clearspectrumfortheaminoacids()
        {
            Dispatcher.Invoke(new Action(() =>
            {
                isnotconfirmedornot = false;
                AnnotationBars1.DataPoints.Clear();
                AnnotationBars2.DataPoints.Clear();
                AnnotationBars3.DataPoints.Clear();
                GrayBarSeries.DataPoints.Clear();
                AnnotationBarsBlue.DataPoints.Clear();
                RedBarSeries.DataPoints.Clear();
                WaterLossSeries.DataPoints.Clear();
                CTerminusLine.DataPoints.Clear();
                txtSearchbox.Text = string.Empty;
                BoundSequences.Clear();
                dtgrdSearchSequence.ItemsSource = null;
            }));
        }


        void bgworkersetparentmassfromsqstags_DoWork(object sender, DoWorkEventArgs e)
        {
            Dispatcher.Invoke(new Action(() =>
            {
                string tag = (e.Argument as string);
                Window setparentfromsqstgs = new Window();
                setparentfromsqstgs.Content = new SetParentMass(tag);
                SetParentMass.SetParentM.SaveParentOrNot = false;
                setparentfromsqstgs.Title = "Set Parent Mass";
                setparentfromsqstgs.Height = 220;
                setparentfromsqstgs.Width = 320;
                setparentfromsqstgs.ResizeMode = ResizeMode.NoResize;
                EventArgs ee = new EventArgs();
                setparentfromsqstgs.Closed += setparentfromsqstgs_Closed;
                setparentfromsqstgs.Owner = this;
                setparentfromsqstgs.WindowStartupLocation = System.Windows.WindowStartupLocation.CenterOwner;
                setparentfromsqstgs.Activate();
                setparentfromsqstgs.ShowDialog();
            }));
        }

        /// <summary>
        /// Initial All the spectra
        /// </summary>
        /// <param name="scannumber"></param>
        void InitialParentMassSetup(int scannumber = 0)
        {
            foreach (SpectrumInfo mgs in MainPointProvider.GetInitialParentInfo())
            {
                mgrspectra.Add(new SpectrumInfo
                {
                    TimeSort = mgs.ScanNumber, // initially just sort by scan number
                    ScanNumber = mgs.ScanNumber,
                    Title = mgs.Title,
                    RetentionTime = mgs.RetentionTime,
                    ParentIon = null,
                    Intensity = mgs.Intensity,
                    RelativeIntensity = mgs.RelativeIntensity,
                    MsLevel = mgs.MsLevel
                });
            }
            if (scannumber != 0)
            {
                if (mgrspectra.Any(a => a.ScanNumber == scannumber))
                {
                    mgrspectra.
                                Where(a => a.ScanNumber == scannumber).
                                Select(c =>
                                {
                                    c.ParentMass = SetParentMass.ParentMass.Mass;
                                    c.ParentZ = SetParentMass.ParentMass.Charge;
                                    c.ParentIon = new Cluster();
                                    c.ParentIon.Z = SetParentMass.ParentMass.Charge;
                                    c.ParentIon.MonoMZ = SetParentMass.ParentMass.ParentMZ;
                                    c.ParentIon.MonoMass = SetParentMass.ParentMass.Mass;
                                    c.ParentIon.Intensity = 1;
                                    return c;
                                });
                }
            }
        }

        


        void setparentfromsqstgs_Closed(object sender, EventArgs e)
        {
            Dispatcher.Invoke(new Action(() =>
            {
                if (SetParentMass.SetParentM.SaveParentOrNot)
                {
                    if (CurrentSpectrum.ParentIon == null)
                    {
                        CurrentSpectrum.ParentIon = new Cluster();
                        CurrentSpectrum.ParentIon.Intensity = CurrentIons.Max(a => a.Intensity);
                    }
                    if (mgrspectra != null)
                    {
                        if (mgrspectra.Any(a => a.ScanNumber == CurrentSpectrum.ScanNumber))
                        {
                            var prnt = new Cluster();
                            prnt.Z = SetParentMass.ParentMass.Charge;
                            prnt.MonoMZ = SetParentMass.ParentMass.ParentMZ;
                            prnt.MonoMass = SetParentMass.ParentMass.Mass;
                            prnt.Intensity = CurrentSpectrum.MaxBy(a => a.Intensity).Intensity;

                            mgrspectra.Where(a => a.ScanNumber == CurrentSpectrum.ScanNumber).First().ParentIon = prnt;

                            mgrspectra.Where(a => a.ScanNumber == CurrentSpectrum.ScanNumber).First().ParentMass = SetParentMass.ParentMass.Mass;
                            mgrspectra.Where(a => a.ScanNumber == CurrentSpectrum.ScanNumber).First().ParentZ = SetParentMass.ParentMass.Charge;

                            //mgrspectra.
                            //            Where(a => a.ScanNumber == CurrentSpectrum.ScanNumber).
                            //            Select(c =>
                            //            {
                            //                c.ParentMass = SetParentMass.ParentMass.Mass; // AddParentMassforMergeSpectra.MergeParentMass.ParentMass;
                            //                c.ParentZ = SetParentMass.ParentMass.Charge; //AddParentMassforMergeSpectra.MergeParentMass.ParentZ;
                            //                c.ParentIon = new Cluster();
                            //                c.ParentIon.Z = SetParentMass.ParentMass.Charge;
                            //                c.ParentIon.MonoMZ = SetParentMass.ParentMass.ParentMZ;
                            //                c.ParentIon.MonoMass = SetParentMass.ParentMass.Mass;
                            //                c.ParentIon.Intensity = CurrentSpectrum.MaxBy(a => a.Intensity).Intensity;
                            //                return c;
                            //            });
                        }
                    }
                    else
                    {
                        mgrspectra = new ObservableCollection<SpectrumInfo>();
                        InitialParentMassSetup(CurrentSpectrum.ScanNumber);
                    }
                    currentparent.ParentZ = SetParentMass.ParentMass.Charge;
                    addparentmassfromMergeSpectra = true;
                    CurrentSpectrum.ParentIon.MonoMass = SetParentMass.ParentMass.Mass;
                    CurrentSpectrum.ParentMZ = SetParentMass.ParentMass.ParentMZ;
                    CurrentSpectrum.ParentIon.MonoMZ = SetParentMass.ParentMass.ParentMZ;
                    CurrentSpectrum.ParentIon.Description = "MZ = " + SetParentMass.ParentMass.ParentMZ + "\nZ = " + SetParentMass.ParentMass.Charge;
                    CurrentSpectrum.ParentMass = SetParentMass.ParentMass.Mass;
                    ParentMass = SetParentMass.ParentMass.Mass;
                    SearchDataGrid(SetParentMass.SetParentM.SequenceTag);
                    SetParentManual();
                }
            }));
        }

        private void mnuclrsqtgs_Click(object sender, RoutedEventArgs e)
        {
            //sequences.Clear();
            //dtgridsequences.Items.Refresh();
            dtgridsequences.DataContext = null;
            dtgridsequences.Visibility = System.Windows.Visibility.Collapsed;
            ClearSequenceMatch();
            txtMatchSequence.IsEnabled = false;
            btnMatch.IsEnabled = false;
            btnFindAA.Visibility = System.Windows.Visibility.Visible;
            btnClearSpectrumAll.IsOpen = false;
        }

        private void btnSearchDatabaseSequences_Click(object sender, RoutedEventArgs e)
        {
            //if (string.IsNullOrWhiteSpace(txtSearchbox.Text) || txtSearchbox.Text.Trim().Length < 4)
            //{
            //    System.Windows.MessageBox.Show("Minimum search length of four amino acids is required.", "Query too short or invalid", MessageBoxButton.OK, MessageBoxImage.Exclamation);
            //    return;
            //}

            Pairmatch = txtSearchbox.Text;
            SequenceMatch = txtSearchbox.Text;
            fromsearchtags = false;

            SearchDataGrid(txtSearchbox.Text);

            filtersearch.Description = new FilterDescription();
            filtersearch.Accessions = new FilterAccessions();
            filtersearch.Sequences = new FilterSequences();
            filtersearch.Species = new FilterSpecies();
        }

        /// <summary>
        /// Clears all the previous search terms on the header of the search.
        /// Note: Makre sure this is called only after the main form is loaded! 
        /// </summary>
        private void ClearSearchContents()
        {
            System.Uri urisource;

            var imgdownDesc = FindVisualChildByName<System.Windows.Controls.Image>(dtgrdSearchSequence, "imgSequencesSearch");

            if (imgdownDesc != null)
            { 
                urisource = new Uri("pack://application:,,,/" + assemblyname + ";component/Icons/White-funnel-th.png");
                imgdownDesc.Tag = "imgDown";
                imgdownDesc.Source = new BitmapImage(urisource);
            }

            var imgAccessiondown = FindVisualChildByName<System.Windows.Controls.Image>(dtgrdSearchSequence, "imgAccessiondown");

            if (imgAccessiondown != null)
            {
                urisource = new Uri("pack://application:,,,/" + assemblyname + ";component/Icons/White-funnel-th.png");
                imgAccessiondown.Tag = "imgDown";
                imgAccessiondown.Source = new BitmapImage(urisource);
            }

            var imgdownDescription = FindVisualChildByName<System.Windows.Controls.Image>(dtgrdSearchSequence, "imgdownDescription");

            if (imgdownDescription != null)
            {
                urisource = new Uri("pack://application:,,,/" + assemblyname + ";component/Icons/White-funnel-th.png");
                imgdownDescription.Tag = "imgDown";
                imgdownDescription.Source = new BitmapImage(urisource);
            }

            if (CTerminusLine.DataPoints != null) CTerminusLine.DataPoints.Clear();

            txtFilterSequences.Text = "";
            txtsrchDescription.Text = "";
            txtAccessionSearch.Text = "";

            if (BoundSequences != null) BoundSequences.Clear();

            var cmbSpecies = FindVisualChildByName<System.Windows.Controls.ComboBox>(dtgrdSearchSequence, "cmbSpecies");
            if (cmbSpecies != null && cmbSpecies.Items != null)
            {
                cmbSpecies.Items.Clear();
                cmbSpecies.Items.Add("All Species");
            }

        }


        void SearchStoryBoard()
        {
            Dispatcher.Invoke(new Action(() =>
            {
                if (!firsttimestoryboard)
                {
                    Storyboard myStoryboard;
                    myStoryboard = (Storyboard)this.Resources["SearchStrybrd"];
                    lblDataSource.Visibility = System.Windows.Visibility.Visible;
                    BeginStoryboard(myStoryboard);
                    //myStoryboard.Begin(this);
                }
                firsttimestoryboard = true;
                Canvas.SetZIndex(dtgrdSearchSequence, 100);
                Canvas.SetZIndex(rctFilterSequences, 100);
                Canvas.SetZIndex(btnFilterSequences, 100);
                Canvas.SetZIndex(btnClearFilterSequences, 100);
                Canvas.SetZIndex(txtFilterSequences, 100);
                Canvas.SetZIndex(cmbFilterSequences, 100);
                Canvas.SetZIndex(rctsrchDescription, 100);
                Canvas.SetZIndex(txtsrchDescription, 100);
                Canvas.SetZIndex(btnsrchDescription, 100);
                Canvas.SetZIndex(cmbfilterdesc, 100);
                Canvas.SetZIndex(btnDescriptionclrFilter, 100);
                Canvas.SetZIndex(rctAccessionSearch, 100);
                Canvas.SetZIndex(btnAccessionSearch, 100);
                Canvas.SetZIndex(txtAccessionSearch, 100);
                Canvas.SetZIndex(cmbAccessionSearch, 100);
                Canvas.SetZIndex(btnAccessionclrFilter, 100);
            }));
        }

        //bool IwLSubstitutionforSequence = true; ///Use this for database search which has I with L substituted.


        //private void chkilsub_Checked(object sender, RoutedEventArgs e)
        //{
        //    IwLSubstitutionforSequence = true;
        //}

        //private void chkilsub_Unchecked(object sender, RoutedEventArgs e)
        //{
        //    IwLSubstitutionforSequence = false;
        //}

        private void btnClearMarkers1_Click(object sender, RoutedEventArgs e)
        {
            RedMarkersSeries.DataPoints.Clear();
            RedMarkersSeriesLite.DataPoints.Clear();
            RedMarkersSeriesBright.DataPoints.Clear();
            txtMarkers.Clear();
        }

        private void btnClearMarkers2_Click(object sender, RoutedEventArgs e)
        {
            GreenMarkersSeries.DataPoints.Clear();
            GreenMarkersSeriesLite.DataPoints.Clear();
            GreenMarkersSeriesBright.DataPoints.Clear();
            txtMarkers2.Clear();
        }

        private void cmbSequences_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            DisplayDescription();
            if ((string)((System.Windows.Controls.ComboBox)(sender)).SelectionBoxItem == "All Species" && (string)((System.Windows.Controls.ComboBox)(sender)).SelectionBoxItem != "" && searchseq && ((System.Windows.Controls.Primitives.Selector)(sender)).SelectedItem == "All Species")
            {
                searchseq = true;
            }
            else if (searchseq && ((System.Windows.Controls.Primitives.Selector)(sender)).SelectedItem as string != "All Species")
            {
                var seqfilteredbyspecies = BoundSequences.Where(a => a.Species == Convert.ToString(((System.Windows.Controls.Primitives.Selector)(sender)).SelectedItem)).ToList();
                //tempdbsequences = seqfilteredbyspecies.ToList();
                Dispatcher.Invoke(new Action(() =>
                {
                    dtgrdSearchSequence.ItemsSource = seqfilteredbyspecies.ToList();
                }));
            }
            else if (((System.Windows.Controls.Primitives.Selector)(sender)).SelectedItem as string == "All Species" && !searchseq)
            {
                searchseq = true;
            }
            else if (((System.Windows.Controls.Primitives.Selector)(sender)).SelectedItem as string == "All Species" && searchseq)
            {
                Dispatcher.Invoke(new Action(() =>
                {
                    dtgrdSearchSequence.ItemsSource = BoundSequences;
                }));
            }
        }

        private void imgdown_MouseDown(object sender, MouseButtonEventArgs e)
        {
            System.Windows.Controls.Image imgdown = FindVisualChildByName<System.Windows.Controls.Image>(dtgrdSearchSequence, "imgdown");
            if (Convert.ToString(imgdown.Tag) == "imgdown")
            {
                rctsrchDescription.Visibility = System.Windows.Visibility.Visible;
                txtsrchDescription.Visibility = System.Windows.Visibility.Visible;
                btnsrchDescription.Visibility = System.Windows.Visibility.Visible;
                //cmbfilterdesc.Visibility = System.Windows.Visibility.Visible;
                imgdown.Tag = "imgUp";
                var urisource = new Uri("pack://application:,,,/" + assemblyname + ";component/Icons/black-funnel-th.png");
                imgdown.Source = new BitmapImage(urisource);
            }
            else if (Convert.ToString(imgdown.Tag) == "imgUp")
            {
                rctsrchDescription.Visibility = System.Windows.Visibility.Collapsed;
                txtsrchDescription.Visibility = System.Windows.Visibility.Collapsed;
                btnsrchDescription.Visibility = System.Windows.Visibility.Collapsed;
                cmbfilterdesc.Visibility = System.Windows.Visibility.Collapsed;
                imgdown.Tag = "imgdown";
                var urisource = new Uri("pack://application:,,,/" + assemblyname + ";component/Icons/White-funnel-th.png");
                imgdown.Source = new BitmapImage(urisource);
            }
        }

        private void btnsrchDescription_Click(object sender, RoutedEventArgs e)
        {
            DisplayDescription();
            if (txtsrchDescription.Text != "" && txtsrchDescription.Text != null)
            {
                System.Windows.Controls.Image imgdownDesc = FindVisualChildByName<System.Windows.Controls.Image>(dtgrdSearchSequence, "imgdownDescription");
                imgdownDesc.Tag = "imgDown";
                var urisource = new Uri("pack://application:,,,/" + assemblyname + ";component/Icons/black-funnel-th.png");
                imgdownDesc.Source = new BitmapImage(urisource);
                dtgrdSearchSequence.ItemsSource = FilterAllSequences();
            }
            else
            {
                System.Windows.MessageBox.Show("Please enter a description.");
            }
        }

        private void btnAccessionSearch_Click(object sender, RoutedEventArgs e)
        {
            DisplayDescription();
            if (txtAccessionSearch.Text != "" && txtAccessionSearch.Text != null)
            {
                System.Windows.Controls.Image imgdownDesc = FindVisualChildByName<System.Windows.Controls.Image>(dtgrdSearchSequence, "imgAccessiondown");
                imgdownDesc.Tag = "imgDown";
                var urisource = new Uri("pack://application:,,,/" + assemblyname + ";component/Icons/black-funnel-th.png");
                imgdownDesc.Source = new BitmapImage(urisource);
                dtgrdSearchSequence.ItemsSource = FilterAllSequences();
            }
            else
            {
                System.Windows.MessageBox.Show("Please enter an accession.");
            }
        }

        private void btnFilterSequences_Click(object sender, RoutedEventArgs e)
        {
            DisplayDescription();
            if (txtFilterSequences.Text != "" && txtFilterSequences.Text != null)
            {
                System.Windows.Controls.Image imgdownDesc = FindVisualChildByName<System.Windows.Controls.Image>(dtgrdSearchSequence, "imgSequencesSearch");
                imgdownDesc.Tag = "imgDown";
                var urisource = new Uri("pack://application:,,,/" + assemblyname + ";component/Icons/black-funnel-th.png");
                imgdownDesc.Source = new BitmapImage(urisource);
                dtgrdSearchSequence.ItemsSource = FilterAllSequences();
            }
            else
            {
                System.Windows.MessageBox.Show("Please enter a sequence.");
            }
        }

        private void cmbSpecies_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            DisplayDescription();
            System.Windows.Controls.ComboBox cmbSpecies = FindVisualChildByName<System.Windows.Controls.ComboBox>(dtgrdSearchSequence, "cmbSpecies");

            if (Convert.ToString(cmbSpecies.SelectionBoxItem) == "")
            {
                return;
            }
            else
            {
                dtgrdSearchSequence.ItemsSource = FilterAllSequences();
            }
        }

        IEnumerable<SearchResult> FilterAllSequences(bool clearfilter = false)
        {
            System.Windows.Controls.ComboBox cmbSpecies = FindVisualChildByName<System.Windows.Controls.ComboBox>(dtgrdSearchSequence, "cmbSpecies");

            Dispatcher.Invoke(new Action(() =>
            {
                rctAccessionSearch.Visibility = System.Windows.Visibility.Collapsed;
                btnAccessionSearch.Visibility = System.Windows.Visibility.Collapsed;
                txtAccessionSearch.Visibility = System.Windows.Visibility.Collapsed;
                cmbAccessionSearch.Visibility = System.Windows.Visibility.Collapsed;
                btnAccessionclrFilter.Visibility = System.Windows.Visibility.Collapsed;
                rctFilterSequences.Visibility = System.Windows.Visibility.Collapsed;
                btnFilterSequences.Visibility = System.Windows.Visibility.Collapsed;
                btnClearFilterSequences.Visibility = System.Windows.Visibility.Collapsed;
                txtFilterSequences.Visibility = System.Windows.Visibility.Collapsed;
                cmbFilterSequences.Visibility = System.Windows.Visibility.Collapsed;
                rctsrchDescription.Visibility = System.Windows.Visibility.Collapsed;
                txtsrchDescription.Visibility = System.Windows.Visibility.Collapsed;
                btnsrchDescription.Visibility = System.Windows.Visibility.Collapsed;
                cmbfilterdesc.Visibility = System.Windows.Visibility.Collapsed;
                btnDescriptionclrFilter.Visibility = System.Windows.Visibility.Collapsed;
            }));

            if (Convert.ToString(cmbSpecies.SelectionBoxItem) == "" && !DechargerVM.UseFasta) return null;



            var searchboundsequences = (from s in BoundSequences
                                        let IsAccFilterOff = string.IsNullOrWhiteSpace(txtAccessionSearch.Text)
                                        let IsDescFilterOff = string.IsNullOrWhiteSpace(txtsrchDescription.Text)
                                        let IsSpeciesFilterOff = Convert.ToString(cmbSpecies.SelectedItem) == "All Species"
                                        let IsSeqFilterOff = string.IsNullOrWhiteSpace(txtFilterSequences.Text)
                                        where (IsAccFilterOff || ApplyFilter(s.Accession, txtAccessionSearch.Text, Convert.ToString(cmbfilterdesc.SelectionBoxItem)))
                                        && (IsDescFilterOff || ApplyFilter(s.Description, txtsrchDescription.Text, Convert.ToString(cmbfilterdesc.SelectionBoxItem)))
                                        && (IsSpeciesFilterOff || ApplyFilter(s.Species, Convert.ToString(cmbSpecies.SelectedItem), Convert.ToString(cmbSpecies.SelectedItem)))
                                        && (IsSeqFilterOff || ApplyFilter(s.Sequence, txtFilterSequences.Text, Convert.ToString(cmbFilterSequences.SelectionBoxItem)))
                                        select s);

            if (BoundSequences.Any() == false)
            {
                imgSearchInfo.Visibility = System.Windows.Visibility.Hidden;
                imgSearchWarning.Visibility = System.Windows.Visibility.Hidden;
            }
            else if (searchboundsequences.Count() > 100)
            {
                imgSearchInfo.Visibility = System.Windows.Visibility.Hidden;
                imgSearchWarning.Visibility = System.Windows.Visibility.Visible;
                imgSearchWarning.ToolTip = "Displaying the first 100 sequences out of " + searchboundsequences.Count() + " sequences" + ((Properties.Settings.Default.SearchAllSpecies || DechargerVM.UseFasta) ? string.Empty : "\n*Species Filter Applied");
                searchboundsequences = searchboundsequences.Take(100).ToList();
            }
            else
            {
                imgSearchWarning.Visibility = System.Windows.Visibility.Hidden;
                imgSearchInfo.Visibility = System.Windows.Visibility.Visible;
                imgSearchInfo.ToolTip = "Displaying all " + searchboundsequences.Count() + " sequences" + ((Properties.Settings.Default.SearchAllSpecies || DechargerVM.UseFasta) ? string.Empty : "\n*Species Filter Applied");
            }

            return searchboundsequences;
        }

        private void btnAccessionclrFilter_Click(object sender, RoutedEventArgs e)
        {
            DisplayDescription();
            System.Windows.Controls.Image imgdown = FindVisualChildByName<System.Windows.Controls.Image>(dtgrdSearchSequence, "imgAccessiondown");
            txtAccessionSearch.Text = "";
            cmbAccessionSearch.SelectedIndex = 0;
            imgdown.Tag = "imgdown";
            var urisource = new Uri("pack://application:,,,/" + assemblyname + ";component/Icons/White-funnel-th.png");
            imgdown.Source = new BitmapImage(urisource);
            dtgrdSearchSequence.ItemsSource = FilterAllSequences(true);
        }

        private void btnDescriptionclrFilter_Click(object sender, RoutedEventArgs e)
        {
            DisplayDescription();
            txtsrchDescription.Text = "";
            cmbfilterdesc.SelectedIndex = 0;
            System.Windows.Controls.Image imgdown = FindVisualChildByName<System.Windows.Controls.Image>(dtgrdSearchSequence, "imgdownDescription");
            imgdown.Tag = "imgdown";
            var urisource = new Uri("pack://application:,,,/" + assemblyname + ";component/Icons/White-funnel-th.png");
            imgdown.Source = new BitmapImage(urisource);
            dtgrdSearchSequence.ItemsSource = FilterAllSequences(true);
        }

        private void btnClearFilterSequences_Click(object sender, RoutedEventArgs e)
        {
            DisplayDescription();
            txtFilterSequences.Text = "";
            cmbFilterSequences.SelectedIndex = 0;
            System.Windows.Controls.Image imgdown = FindVisualChildByName<System.Windows.Controls.Image>(dtgrdSearchSequence, "imgSequencesSearch");
            imgdown.Tag = "imgUp";
            var urisource = new Uri("pack://application:,,,/" + assemblyname + ";component/Icons/White-funnel-th.png");
            imgdown.Source = new BitmapImage(urisource);
            dtgrdSearchSequence.ItemsSource = FilterAllSequences(true);
        }


        bool ApplyFilter(string source, string target, string function)
        {
            switch (function)
            {
                case "Contains": return source.ToLower().Contains(target.ToLower());
                case "Startswith": return source.ToLower().StartsWith(target.ToLower());
                case "Equals": return source.ToLower() == target.ToLower();
                case "All Species": return true;
                default:
                    if (target == function)
                    {
                        return source.ToLower() == target.ToLower();
                    }
                    break;
            }
            return true;
        }

        private void btnsearchArrow_Click(object sender, RoutedEventArgs e)
        {
            Dispatcher.Invoke(new Action(() =>
            {
                System.Windows.Controls.Image imgdown = FindVisualChildByName<System.Windows.Controls.Image>(dtgrdSearchSequence, "imgdownDescription");
                if (rctsrchDescription.Visibility != System.Windows.Visibility.Visible)
                {
                    imgdown.Tag = "imgUp";
                    rctAccessionSearch.Visibility = System.Windows.Visibility.Collapsed;
                    btnAccessionSearch.Visibility = System.Windows.Visibility.Collapsed;
                    txtAccessionSearch.Visibility = System.Windows.Visibility.Collapsed;
                    cmbAccessionSearch.Visibility = System.Windows.Visibility.Collapsed;
                    btnAccessionclrFilter.Visibility = System.Windows.Visibility.Collapsed;
                    rctFilterSequences.Visibility = System.Windows.Visibility.Collapsed;
                    btnFilterSequences.Visibility = System.Windows.Visibility.Collapsed;
                    btnClearFilterSequences.Visibility = System.Windows.Visibility.Collapsed;
                    txtFilterSequences.Visibility = System.Windows.Visibility.Collapsed;
                    cmbFilterSequences.Visibility = System.Windows.Visibility.Collapsed;
                    rctsrchDescription.Visibility = System.Windows.Visibility.Visible;
                    rctsrchDescription.Height = 70.0;
                    txtsrchDescription.Visibility = System.Windows.Visibility.Visible;
                    btnsrchDescription.Visibility = System.Windows.Visibility.Visible;
                    btnsrchDescription.Height = 25.0;
                    //cmbfilterdesc.Visibility = System.Windows.Visibility.Visible;
                    cmbfilterdesc.Height = 23.0;
                    btnDescriptionclrFilter.Visibility = System.Windows.Visibility.Visible;
                    btnDescriptionclrFilter.Height = 25.0;
                    txtsrchDescription.Focus();
                }
                else if (rctsrchDescription.Visibility == System.Windows.Visibility.Visible)
                {
                    imgdown.Tag = "imgdown";
                    rctsrchDescription.Visibility = System.Windows.Visibility.Collapsed;
                    txtsrchDescription.Visibility = System.Windows.Visibility.Collapsed;
                    btnsrchDescription.Visibility = System.Windows.Visibility.Collapsed;
                    cmbfilterdesc.Visibility = System.Windows.Visibility.Collapsed;
                    btnDescriptionclrFilter.Visibility = System.Windows.Visibility.Collapsed;
                }
            }));
        }

        private void btnAccessionSearchArrow_Click(object sender, RoutedEventArgs e)
        {
            Dispatcher.Invoke(new Action(() =>
            {
                System.Windows.Controls.Image imgdown = FindVisualChildByName<System.Windows.Controls.Image>(dtgrdSearchSequence, "imgAccessiondown");
                if (rctAccessionSearch.Visibility != System.Windows.Visibility.Visible)
                {
                    imgdown.Tag = "imgUp";
                    rctFilterSequences.Visibility = System.Windows.Visibility.Collapsed;
                    btnFilterSequences.Visibility = System.Windows.Visibility.Collapsed;
                    btnClearFilterSequences.Visibility = System.Windows.Visibility.Collapsed;
                    txtFilterSequences.Visibility = System.Windows.Visibility.Collapsed;
                    cmbFilterSequences.Visibility = System.Windows.Visibility.Collapsed;
                    rctsrchDescription.Visibility = System.Windows.Visibility.Collapsed;
                    txtsrchDescription.Visibility = System.Windows.Visibility.Collapsed;
                    btnsrchDescription.Visibility = System.Windows.Visibility.Collapsed;
                    cmbfilterdesc.Visibility = System.Windows.Visibility.Collapsed;
                    btnDescriptionclrFilter.Visibility = System.Windows.Visibility.Collapsed;
                    rctAccessionSearch.Visibility = System.Windows.Visibility.Visible;
                    rctAccessionSearch.Height = 70.0;
                    btnAccessionSearch.Visibility = System.Windows.Visibility.Visible;
                    btnAccessionSearch.Height = 25.0;
                    txtAccessionSearch.Visibility = System.Windows.Visibility.Visible;
                    //cmbAccessionSearch.Visibility = System.Windows.Visibility.Visible;
                    cmbAccessionSearch.Height = 23.0;
                    btnAccessionclrFilter.Visibility = System.Windows.Visibility.Visible;
                    btnAccessionclrFilter.Height = 25.0;
                    txtAccessionSearch.Focus();
                }
                else if (rctAccessionSearch.Visibility == System.Windows.Visibility.Visible)
                {
                    imgdown.Tag = "imgdown";
                    rctAccessionSearch.Visibility = System.Windows.Visibility.Collapsed;
                    btnAccessionSearch.Visibility = System.Windows.Visibility.Collapsed;
                    txtAccessionSearch.Visibility = System.Windows.Visibility.Collapsed;
                    cmbAccessionSearch.Visibility = System.Windows.Visibility.Collapsed;
                    btnAccessionclrFilter.Visibility = System.Windows.Visibility.Collapsed;
                }
            }));
        }

        private void btnSequencesfilter_Click(object sender, RoutedEventArgs e)
        {
            Dispatcher.Invoke(new Action(() =>
            {
                System.Windows.Controls.Image imgdown = FindVisualChildByName<System.Windows.Controls.Image>(dtgrdSearchSequence, "imgSequencesSearch");
                if (rctFilterSequences.Visibility != System.Windows.Visibility.Visible)
                {
                    imgdown.Tag = "imgUp";
                    rctAccessionSearch.Visibility = System.Windows.Visibility.Collapsed;
                    btnAccessionSearch.Visibility = System.Windows.Visibility.Collapsed;
                    txtAccessionSearch.Visibility = System.Windows.Visibility.Collapsed;
                    cmbAccessionSearch.Visibility = System.Windows.Visibility.Collapsed;
                    btnAccessionclrFilter.Visibility = System.Windows.Visibility.Collapsed;
                    rctsrchDescription.Visibility = System.Windows.Visibility.Collapsed;
                    txtsrchDescription.Visibility = System.Windows.Visibility.Collapsed;
                    btnsrchDescription.Visibility = System.Windows.Visibility.Collapsed;
                    cmbfilterdesc.Visibility = System.Windows.Visibility.Collapsed;
                    btnDescriptionclrFilter.Visibility = System.Windows.Visibility.Collapsed;
                    rctFilterSequences.Visibility = System.Windows.Visibility.Visible;
                    rctFilterSequences.Height = 70.0;
                    btnFilterSequences.Visibility = System.Windows.Visibility.Visible;
                    btnFilterSequences.Height = 25.0;
                    btnClearFilterSequences.Visibility = System.Windows.Visibility.Visible;
                    btnClearFilterSequences.Height = 25.0;
                    txtFilterSequences.Visibility = System.Windows.Visibility.Visible;
                    //cmbFilterSequences.Visibility = System.Windows.Visibility.Visible;
                    cmbFilterSequences.Height = 23.0;
                    //btnClearFilterSequences.Margin.Left = 400.0;
                    txtFilterSequences.Focus();
                }
                else if (rctFilterSequences.Visibility == System.Windows.Visibility.Visible)
                {
                    rctFilterSequences.Visibility = System.Windows.Visibility.Collapsed;
                    btnFilterSequences.Visibility = System.Windows.Visibility.Collapsed;
                    btnClearFilterSequences.Visibility = System.Windows.Visibility.Collapsed;
                    txtFilterSequences.Visibility = System.Windows.Visibility.Collapsed;
                    cmbFilterSequences.Visibility = System.Windows.Visibility.Collapsed;
                    imgdown.Tag = "imgdown";
                }
            }));
        }

        private void btnsrchDescription_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.Key == Key.Enter)
            {
                btnsrchDescription.RaiseEvent(new RoutedEventArgs(Button.ClickEvent));
            }
        }

        private void txtAccessionSearch_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.Key == Key.Enter)
            {
                btnAccessionSearch.RaiseEvent(new RoutedEventArgs(Button.ClickEvent));
            }
        }

        private void txtFilterSequences_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.Key == Key.Enter)
            {
                btnFilterSequences.RaiseEvent(new RoutedEventArgs(Button.ClickEvent));
            }
        }

        private void txtSearchbox_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.Key == Key.Enter)
            {
                btnSearchDatabaseSequences.RaiseEvent(new RoutedEventArgs(SplitButton.ClickEvent));
            }
        }

        private void grdMerge1_MouseDoubleClick(object sender, MouseButtonEventArgs e)
        {
            btnMerge.RaiseEvent(new RoutedEventArgs(Button.ClickEvent));
        }

        private void Label_MouseRightButtonDown(object sender, MouseButtonEventArgs e)
        {
            lblsearchWatermark.Opacity = 0.33;
            txtSearchbox.Focus();
        }

        private void txtSearchbox_LostFocus(object sender, RoutedEventArgs e)
        {
            if (txtSearchbox.Text == "" || txtSearchbox.Text == null)
            {
                lblsearchWatermark.Visibility = System.Windows.Visibility.Visible;
                lblsearchWatermark.Opacity = 0.67;
            }
        }

        private void txtSearchbox_KeyUp(object sender, KeyEventArgs e)
        {

        }

        private void txtSearchbox_TextChanged(object sender, TextChangedEventArgs e)
        {
            if (txtSearchbox.Text != "" && txtSearchbox.Text != null)
            {
                lblsearchWatermark.Opacity = 0;
                lblsearchWatermark.Visibility = System.Windows.Visibility.Hidden;
            }
            else if (txtSearchbox.Text == "")
            {
                lblsearchWatermark.Visibility = System.Windows.Visibility.Visible;
                lblsearchWatermark.Opacity = 0.33;
            }
        }

        private void btnShowDBSequence_Click(object sender, RoutedEventArgs e)
        {
            // this is the "Display" button in the proteins tab.  
            // it should take the selected protein and diplay that sequence match against the currently presented spectrum.

            // we should be pulling the clicked target from the event args and context, not selected item

            //((System.Windows.FrameworkElement)e.Source).DataContext as SearchResult

            if (fromautoscanvalidate)
            {
                // Call Drawthesequence() within a worker thread

                BackgroundWorker bgworkerdrawseq = new BackgroundWorker();

                bgworkerdrawseq.DoWork += bgworkerdrawseq_DoWork;
                bgworkerdrawseq.RunWorkerCompleted += bgworkerdrawseq_RunWorkerCompleted;

                bgworkerdrawseq.RunWorkerAsync(dtgrdSearchSequence.SelectedItem);
                fromautoscanvalidate = false;
            }
            else
            {
                // Call from the current thread
                Drawthesequence(dtgrdSearchSequence.SelectedItem as SearchResult);
            }
        }

        void bgworkerdrawseq_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            btnProteinVerifyCurrentSequence_Click(null, null);
        }

        void bgworkerdrawseq_DoWork(object sender, DoWorkEventArgs e)
        {
            if (e.Argument == null || (e.Argument is SearchResult == false)) return;

            Dispatcher.Invoke(new Action(() =>
            {
                Drawthesequence(e.Argument as SearchResult);
            }));
        }




        void Drawthesequence(SearchResult sr)
        {

            //        var sr = (SearchResult)dtgrdSearchSequence.SelectedItem;
            if (sr == null) return;

            string scannumber = txtScanNum.Text;
            if (scannumber == "" || scannumber == null) return;

            //if (DechargerVM.CurrentFilesLoaded.SpectralDataFilename != null)
            if (DechargerVM.SpectralDataIsAvailable) // && MainPointProvider != null)
            {
                if (!(scannumber.ToLower().Contains("merged")))
                {
                    double rt = MainPointProvider.RetentionTime(Convert.ToInt32(scannumber));

                    var rng = new Range()
                    {
                        Start = rt,
                        End = rt
                    };

                    var specinfo = GetSpecList(rng);

                    if (!(specinfo.Where(a => a.MsLevel == SpecMsLevel.MSMS).Any()))
                    {
                        return;
                    }
                }
                else if (!(CurrentSpectrum.Title.Contains("Consolidated MS2 Scans:")))
                {
                    return;
                }
            }

            if (sr.InternalMT.Count == 0)
            {
                return;
            }

            List<DataPoint> Monomasses = new List<DataPoint>();

            Dispatcher.Invoke(new Action(() =>
            {
                //this.DataContext = null;

                if (dtgrdSearchSequence.ItemsSource != null && dtgrdSearchSequence.ItemsSource is List<SearchResult>)
                {
                    List<SearchResult> srch = new List<SearchResult>();
                    foreach (var a in dtgrdSearchSequence.ItemsSource as List<SearchResult>)
                    {
                        if (a == sr)
                        {
                            a.Checked = true;
                            srch.Add(a);
                        }
                        else
                        {
                            a.Checked = false;
                            srch.Add(a);
                        }
                        dtgrdSearchSequence.ItemsSource = null;
                        dtgrdSearchSequence.ItemsSource = srch;
                    }
                }

                MonoMassesfordbSequence.Visibility = System.Windows.Visibility.Visible;
                ClearAminoAcids_Click(null, null, sr, true, txtSearchbox.Text);
            }));


            try
            {
                if (sr == null) return;
                ///If there are any sequence tags found then we will find the corresponding highlighting 
                if (sr.Allthesequencetags.First() != "")
                {
                    string matchseq = sr.Sequence;
                    string ModifiedSequenceForL = sr.Sequence.Replace('I', 'L');
                    int ii = 0; // sequ.matchstartends.Count;
                    while (ii < sr.matchstartends.Count)
                    {
                        if (sr.matchstartends[ii].SequenceTag == null)
                        {
                            ii++;
                            continue;
                        }
                        sr.matchstartends[ii].RawSequenceTag = sr.matchstartends[ii].SequenceTag = sr.matchstartends[ii].MainSequence ? sr.Sequence.Substring(sr.matchstartends[ii].Start, sr.matchstartends[ii].End - sr.matchstartends[ii].Start) : ReverseString.Reverse(sr.Sequence.Substring(sr.matchstartends[ii].Start, sr.matchstartends[ii].End - sr.matchstartends[ii].Start));
                        ii++;
                    }

                    List<Cluster> ReverseCrntIons = new List<Cluster>();
                    int lengthofmodifiedsequenceforl = ModifiedSequenceForL.Length;
                    bool forwardorreverse = false;
                    string mainsequencetag = Pairmatch;
                    double startvaluetocompare = sr.AllsqsTags.OrderByDescending(a => a.Sequence.Length).First().Start;
                    double endvaluetocompare = sr.AllsqsTags.OrderByDescending(a => a.Sequence.Length).First().End;
                    List<MSViewer.MatchStartEnds> matchstartends = new List<MSViewer.MatchStartEnds>();
                    char[] reversechar = mainsequencetag.ToCharArray();
                    Array.Reverse(reversechar);
                    ///Necessary parameters
                    ///
                    ///1) AllsqsTags
                    ///2) mainsequencetag
                    ///
                    ///
                    matchstartends = sr.InternalMT;

                    var mm = (from m in Monomasses
                              group m by new { m.XValue, m.YValue }
                                    into grp
                              select new DataPoint
                              {
                                  YValue = grp.Key.YValue,
                                  XValue = grp.Key.XValue
                              }).ToList();

                    List<DataPoint> allthemonomasses = new List<DataPoint>();
                    foreach (DataPoint dt in CurrentMonoMasses.OrderBy(a => a.XValue).ToList())
                    {
                        allthemonomasses.Add(new DataPoint()
                        {
                            XValue = Convert.ToDouble(dt.XValue),
                            YValue = setdbmonointensity
                        });
                    }

                    foreach (DataPoint dt in ReverseCurrentMonomasses.OrderByDescending(a => a.XValue).ToList())
                    {
                        allthemonomasses.Add(new DataPoint()
                        {
                            XValue = Convert.ToDouble(dt.XValue),
                            YValue = setdbmonointensity
                        });
                    }

                    bool direction;
                    MatchStartEnds firstmtse = new MatchStartEnds();
                    int countforhighlight = 0;
                    MatchStartEnds lstmtse = new MatchStartEnds();
                    if (!matchstartends.Where(a => a.confidence == AminAcidConfidence.Sure).OrderByDescending(a => a.Length).First().MainSequence)
                    {
                        matchstartends = matchstartends.Where(a => a.SequenceTag != null).OrderBy(a => a.End).ThenBy(a => a.Start).ThenBy(a => a.Length).ToList();
                        firstmtse = matchstartends.Where(a => a.SequenceTag != null).First();
                        lstmtse = matchstartends.Where(a => a.SequenceTag != null).Last();
                        //if (matchstartends[matchstartends.Count - 1].confidence == Confidence.NotSure)
                        //{
                        //    if (matchstartends[matchstartends.Count - 1].Gap > 0.2)
                        //    {
                        //        matchstartends[matchstartends.Count - 1].Gap = matchstartends[matchstartends.Count - 1].Gap - Molecules.Water;
                        //        matchstartends[matchstartends.Count - 1].StartMonoMass = Molecules.Water;
                        //        //matchstartends[matchstartends.Count - 1].StartMonoMass = matchstartends[matchstartends.Count - 1].EndMonoMass - Molecules.Water;
                        //    }
                        //}
                        countforhighlight = firstmtse.Start;
                        direction = false;
                    }
                    else
                    {
                        matchstartends = matchstartends.Where(a => a.SequenceTag != null).OrderByDescending(a => a.End).ThenByDescending(a => a.Start).ThenBy(a => a.Length).ToList();
                        firstmtse = matchstartends.Where(a => a.SequenceTag != null).First();

                        //if (matchstartends[0].confidence == Confidence.NotSure)
                        //{
                        //    if (matchstartends[0].Gap > 0.2)
                        //    {
                        //        matchstartends[0].Gap = matchstartends[0].Gap - Molecules.Water;
                        //        matchstartends[0].EndMonoMass = matchstartends[0].EndMonoMass - Molecules.Water;
                        //    }
                        //}
                        countforhighlight = firstmtse.End;
                        direction = true;
                    }

                    double initialend = Math.Round(firstmtse.EndMonoMass, 1);
                    double currentend = Math.Round(firstmtse.EndMonoMass, 1);
                    double currentstart = 0;

                    bool reversedirection = direction;
                    int modificationcount = 0;
                    AnnotationBar bar = null;
                    int localcount = 0;
                    MatchStartEnds currentmtse = new MatchStartEnds();


                    int maxend = matchstartends.Max(a => a.End);

                    bool hasanotsuremaxend = false;

                    if (matchstartends.First(a => a.End == maxend).confidence == AminAcidConfidence.NotSure)
                    {
                        hasanotsuremaxend = true;
                    }


                    foreach (MatchStartEnds mtse in matchstartends)
                    {
                        currentmtse = mtse;
                        if (mtse.confidence == AminAcidConfidence.Sure)
                        {
                            if (mtse.MainSequence == direction)
                            {
                                if (direction)
                                    localcount = mtse.End - modificationcount;
                                else
                                    localcount = mtse.Start + modificationcount;
                                string localsequence = mtse.SequenceTag;
                                if (publicseq.Where(a => a.Sequence == mtse.SequenceTag).Any())
                                {
                                    localsequence = publicseq.Where(a => a.Sequence == mtse.SequenceTag).First().RawSequence;
                                }
                                if (Regex.IsMatch(localsequence, @"[a-z]"))
                                {
                                    int i = localsequence.Length - 1;
                                    int j = localsequence.Length - 1;
                                    foreach (char s in Enumerable.Reverse(localsequence))
                                    {
                                        if (localcount == countforhighlight)
                                        {
                                            if (direction)
                                                countforhighlight--;
                                            else
                                                countforhighlight++;
                                            if (i != j)
                                            {
                                                j--;
                                                j--;
                                                i--;
                                                modificationcount++;
                                                if (direction)
                                                    localcount--;
                                                else
                                                    localcount++;
                                                continue;
                                            }
                                            i--;
                                            string lclstrng = Convert.ToString(s);
                                            if (Regex.IsMatch(lclstrng, @"[a-z]"))
                                            {
                                                lclstrng = localsequence[i] + lclstrng;
                                                currentstart = currentend - AminoAcidHelpers.AminoAcidMass2[lclstrng];
                                            }
                                            else
                                            {
                                                currentstart = currentend - sequencelength(lclstrng);
                                                j--;
                                            }
                                            Monomasses.AddRange(allthemonomasses.Where(a => Math.Abs(Convert.ToDouble(a.XValue) - currentend) <= PPMCalc.CurrentPPM(currentend) + 0.1).ToList());
                                            Monomasses.AddRange(allthemonomasses.Where(a => Math.Abs(Convert.ToDouble(a.XValue) - currentstart) <= PPMCalc.CurrentPPM(currentstart) + 0.1).ToList());
                                            bar = new AnnotationBar()
                                            {
                                                End = currentend,
                                                Start = currentstart,
                                                Name = Convert.ToString(lclstrng),
                                                EndScore = 4000,
                                                StartScore = 4000,
                                                Index = Convert.ToString(currentend) + lclstrng + Convert.ToString(currentstart)
                                            };
                                            AddDBRangeLabel(bar, 0.009);
                                            currentend = currentstart;
                                        }
                                        if (direction)
                                            localcount--;
                                        else
                                            localcount++;
                                    }
                                }
                                else
                                {
                                    foreach (char s in Enumerable.Reverse(localsequence))
                                    {
                                        if (localcount == countforhighlight)
                                        {
                                            if (direction)
                                                countforhighlight--;
                                            else
                                                countforhighlight++;
                                            string lclstrng = Convert.ToString(s);
                                            currentstart = currentend - sequencelength(lclstrng);
                                            Monomasses.AddRange(allthemonomasses.Where(a => Math.Abs(Convert.ToDouble(a.XValue) - currentend) <= PPMCalc.CurrentPPM(currentend) + 0.1).ToList());
                                            Monomasses.AddRange(allthemonomasses.Where(a => Math.Abs(Convert.ToDouble(a.XValue) - currentstart) <= PPMCalc.CurrentPPM(currentstart) + 0.1).ToList());
                                            bar = new AnnotationBar()
                                            {
                                                End = currentend,
                                                Start = currentstart,
                                                Name = Convert.ToString(lclstrng),
                                                EndScore = 4000,
                                                StartScore = 4000,
                                                Index = Convert.ToString(currentend) + lclstrng + Convert.ToString(currentstart)
                                            };
                                            AddDBRangeLabel(bar, 0.009);
                                            currentend = currentstart;
                                        }
                                        if (direction)
                                            localcount--;
                                        else
                                            localcount++;
                                    }
                                }
                            }
                            else
                            {
                                if (direction)
                                    localcount = mtse.End - modificationcount;
                                else
                                    localcount = mtse.Start + modificationcount;
                                string localsequence = mtse.SequenceTag;
                                if (publicseq.Where(a => a.Sequence == mtse.SequenceTag).Any())
                                {
                                    localsequence = publicseq.Where(a => a.Sequence == mtse.SequenceTag).First().RawSequence;
                                }
                                if (Regex.IsMatch(Convert.ToString(localsequence), @"[a-z]"))
                                {
                                    int i = 0;
                                    int j = 0;
                                    foreach (char s in localsequence)
                                    {
                                        if (localcount == countforhighlight)
                                        {
                                            if (direction)
                                                countforhighlight--;
                                            else
                                                countforhighlight++;
                                            if (i != j)
                                            {
                                                j++;
                                                modificationcount++;
                                                if (direction)
                                                    localcount--;
                                                else
                                                    localcount++;
                                                continue;
                                            }
                                            i++;


                                            string lclstrng = Convert.ToString(s);
                                            if (Regex.IsMatch(Convert.ToString(localsequence[i]), @"[a-z]"))
                                            {
                                                lclstrng = lclstrng + Convert.ToString(localsequence[i]);
                                                currentstart = currentend - AminoAcidHelpers.AminoAcidMass2[lclstrng];
                                            }
                                            else
                                            {
                                                currentstart = currentend - sequencelength(lclstrng);
                                                j++;
                                            }
                                            Monomasses.AddRange(allthemonomasses.Where(a => Math.Abs(Convert.ToDouble(a.XValue) - currentend) <= PPMCalc.CurrentPPM(currentend) + 0.1).ToList());
                                            Monomasses.AddRange(allthemonomasses.Where(a => Math.Abs(Convert.ToDouble(a.XValue) - currentstart) <= PPMCalc.CurrentPPM(currentstart) + 0.1).ToList());
                                            bar = new AnnotationBar()
                                            {
                                                End = currentend,
                                                Start = currentstart,
                                                Name = Convert.ToString(lclstrng),
                                                EndScore = 4000,
                                                StartScore = 4000,
                                                Index = Convert.ToString(currentend) + lclstrng + Convert.ToString(currentstart)
                                            };
                                            AddDBRangeLabel(bar, 0.009);
                                            currentend = currentstart;
                                        }
                                        if (direction)
                                            localcount--;
                                        else
                                            localcount++;
                                    }
                                }
                                else
                                {
                                    foreach (char s in localsequence)
                                    {
                                        if (localcount == countforhighlight)
                                        {
                                            if (direction)
                                                countforhighlight--;
                                            else
                                                countforhighlight++;
                                            string lclstrng = Convert.ToString(s);
                                            currentstart = currentend - sequencelength(lclstrng);
                                            Monomasses.AddRange(allthemonomasses.Where(a => Math.Abs(Convert.ToDouble(a.XValue) - currentend) <= PPMCalc.CurrentPPM(currentend) + 0.1).ToList());
                                            Monomasses.AddRange(allthemonomasses.Where(a => Math.Abs(Convert.ToDouble(a.XValue) - currentstart) <= PPMCalc.CurrentPPM(currentstart) + 0.1).ToList());
                                            bar = new AnnotationBar()
                                            {
                                                End = currentend,
                                                Start = currentstart,
                                                Name = Convert.ToString(lclstrng),
                                                EndScore = 4000,
                                                StartScore = 4000,
                                                Index = Convert.ToString(currentend) + lclstrng + Convert.ToString(currentstart)
                                            };
                                            AddDBRangeLabel(bar, 0.009);
                                            currentend = currentstart;
                                        }
                                        if (direction)
                                            localcount--;
                                        else
                                            localcount++;
                                    }
                                }
                            }
                        }
                        else if (mtse.confidence == AminAcidConfidence.Low)
                        {
                            AnnotationbarScore = 0.050;
                            if (direction)
                                localcount = mtse.End - modificationcount;
                            else
                                localcount = mtse.Start + modificationcount;
                            if (firstmtse.SequenceTag == mtse.SequenceTag)
                            {
                                if (Math.Abs(mtse.Gap) > 0)
                                {
                                    currentstart = currentend - mtse.Gap;
                                    bar = new AnnotationBar()
                                    {
                                        End = currentend,
                                        Start = currentstart,
                                        Name = Convert.ToString(18),
                                        EndScore = 1000,
                                        StartScore = 1000,
                                        Index = Convert.ToString(currentend) + Convert.ToString(18) + Convert.ToString(currentstart)
                                    };
                                    //end = true;
                                    AddDBRangeLabel(bar, 0.050, true, false);
                                    currentend = currentstart;
                                }
                            }
                            if (mtse.MainSequence == direction)
                            {
                                if (Regex.IsMatch(mtse.SequenceTag, @"[a-z]"))
                                {
                                    int i = mtse.SequenceTag.Length - 1;
                                    int j = mtse.SequenceTag.Length - 1;
                                    foreach (char s in mtse.SequenceTag.Reverse())
                                    {
                                        if (localcount == countforhighlight)
                                        {
                                            if (direction)
                                                countforhighlight--;
                                            else
                                                countforhighlight++;
                                            if (i != j)
                                            {
                                                j--;
                                                modificationcount++;
                                                if (direction)
                                                    localcount--;
                                                else
                                                    localcount++;
                                                continue;
                                            }
                                            i--;
                                            string lclstrng = Convert.ToString(s);
                                            if (Regex.IsMatch(lclstrng, @"[a-z]"))
                                            {
                                                lclstrng = mtse.SequenceTag[i] + lclstrng;
                                                currentstart = currentend - AminoAcidHelpers.AminoAcidMass2[lclstrng];
                                            }
                                            else
                                            {
                                                currentstart = currentend - sequencelength(lclstrng);
                                                j--;
                                            }
                                            bool start = false;
                                            bool end = false;
                                            if (allthemonomasses.Any(a => Math.Abs(Convert.ToDouble(a.XValue) - currentend) <= PPMCalc.CurrentPPM(currentend) + 0.1))
                                            {
                                                bar = new AnnotationBar()
                                                {
                                                    End = currentend,
                                                    Start = currentstart,
                                                    Name = Convert.ToString(lclstrng),
                                                    EndScore = 1000,
                                                    StartScore = 1000,
                                                    Index = Convert.ToString(currentend) + lclstrng + Convert.ToString(currentstart)
                                                };
                                                end = true;
                                                AddDBRangeLabel(bar, 0.050, true, false);
                                            }
                                            if (allthemonomasses.Any(a => Math.Abs(Convert.ToDouble(a.XValue) - currentstart) <= PPMCalc.CurrentPPM(currentstart) + 0.1))
                                            {
                                                bar = new AnnotationBar()
                                                {
                                                    End = currentend,
                                                    Start = currentstart,
                                                    Name = Convert.ToString(lclstrng),
                                                    EndScore = 1000,
                                                    StartScore = 1000,
                                                    Index = Convert.ToString(currentend) + lclstrng + Convert.ToString(currentstart)
                                                };
                                                start = true;
                                                AddDBRangeLabel(bar, 0.050, false, true);
                                            }
                                            Monomasses.AddRange(allthemonomasses.Where(a => Math.Abs(Convert.ToDouble(a.XValue) - currentend) <= PPMCalc.CurrentPPM(currentend) + 0.1).ToList());
                                            Monomasses.AddRange(allthemonomasses.Where(a => Math.Abs(Convert.ToDouble(a.XValue) - currentstart) <= PPMCalc.CurrentPPM(currentstart) + 0.1).ToList());
                                            if (start && end)
                                            {

                                            }
                                            else if (start)
                                            {
                                                bar = new AnnotationBar()
                                                {
                                                    End = currentend,
                                                    Start = currentstart,
                                                    Name = Convert.ToString(lclstrng),
                                                    EndScore = 1000,
                                                    StartScore = 1000,
                                                    Index = Convert.ToString(currentend) + lclstrng + Convert.ToString(currentstart)
                                                };
                                                AddDBRangeLabel(bar, 0.0502, true, false);
                                            }
                                            else if (end)
                                            {
                                                bar = new AnnotationBar()
                                                {
                                                    End = currentend,
                                                    Start = currentstart,
                                                    Name = Convert.ToString(lclstrng),
                                                    EndScore = 1000,
                                                    StartScore = 1000,
                                                    Index = Convert.ToString(currentend) + lclstrng + Convert.ToString(currentstart)
                                                };
                                                AddDBRangeLabel(bar, 0.0502, false, true);
                                            }
                                            else
                                            {
                                                bar = new AnnotationBar()
                                                {
                                                    End = currentend,
                                                    Start = currentstart,
                                                    Name = Convert.ToString(lclstrng),
                                                    EndScore = 1000,
                                                    StartScore = 1000,
                                                    Index = Convert.ToString(currentend) + lclstrng + Convert.ToString(currentstart)
                                                };
                                                AddDBRangeLabel(bar, 0.050);
                                            }
                                            currentend = currentstart;
                                        }
                                        if (direction)
                                            localcount--;
                                        else
                                            localcount++;
                                    }
                                }
                                else
                                {
                                    foreach (char s in mtse.SequenceTag.Reverse())
                                    {
                                        if (localcount == countforhighlight)
                                        {
                                            if (direction)
                                                countforhighlight--;
                                            else
                                                countforhighlight++;
                                            string lclstrng = Convert.ToString(s);
                                            currentstart = currentend - sequencelength(lclstrng);
                                            bool start = false;
                                            bool end = false;
                                            if (allthemonomasses.Any(a => Math.Abs(Convert.ToDouble(a.XValue) - currentend) <= PPMCalc.CurrentPPM(currentend) + 0.1))
                                            {
                                                bar = new AnnotationBar()
                                                {
                                                    End = currentend,
                                                    Start = currentstart,
                                                    Name = Convert.ToString(lclstrng),
                                                    EndScore = 1000,
                                                    StartScore = 1000,
                                                    Index = Convert.ToString(currentend) + lclstrng + Convert.ToString(currentstart)
                                                };
                                                end = true;
                                                AddDBRangeLabel(bar, 0.050, true, false);
                                            }
                                            if (allthemonomasses.Any(a => Math.Abs(Convert.ToDouble(a.XValue) - currentstart) <= PPMCalc.CurrentPPM(currentstart) + 0.1))
                                            {
                                                bar = new AnnotationBar()
                                                {
                                                    End = currentend,
                                                    Start = currentstart,
                                                    Name = Convert.ToString(lclstrng),
                                                    EndScore = 1000,
                                                    StartScore = 1000,
                                                    Index = Convert.ToString(currentend) + lclstrng + Convert.ToString(currentstart)
                                                };
                                                start = true;
                                                AddDBRangeLabel(bar, 0.050, false, true);
                                            }
                                            Monomasses.AddRange(allthemonomasses.Where(a => Math.Abs(Convert.ToDouble(a.XValue) - currentend) <= PPMCalc.CurrentPPM(currentend) + 0.1).ToList());
                                            Monomasses.AddRange(allthemonomasses.Where(a => Math.Abs(Convert.ToDouble(a.XValue) - currentstart) <= PPMCalc.CurrentPPM(currentstart) + 0.1).ToList());
                                            if (start && end)
                                            {

                                            }
                                            else if (start)
                                            {
                                                bar = new AnnotationBar()
                                                {
                                                    End = currentend,
                                                    Start = currentstart,
                                                    Name = Convert.ToString(lclstrng),
                                                    EndScore = 1000,
                                                    StartScore = 1000,
                                                    Index = Convert.ToString(currentend) + lclstrng + Convert.ToString(currentstart)
                                                };
                                                AddDBRangeLabel(bar, 0.0502, true, false);
                                            }
                                            else if (end)
                                            {
                                                bar = new AnnotationBar()
                                                {
                                                    End = currentend,
                                                    Start = currentstart,
                                                    Name = Convert.ToString(lclstrng),
                                                    EndScore = 1000,
                                                    StartScore = 1000,
                                                    Index = Convert.ToString(currentend) + lclstrng + Convert.ToString(currentstart)
                                                };
                                                AddDBRangeLabel(bar, 0.0502, false, true);
                                            }
                                            else
                                            {
                                                bar = new AnnotationBar()
                                                {
                                                    End = currentend,
                                                    Start = currentstart,
                                                    Name = Convert.ToString(lclstrng),
                                                    EndScore = 1000,
                                                    StartScore = 1000,
                                                    Index = Convert.ToString(currentend) + lclstrng + Convert.ToString(currentstart)
                                                };
                                                AddDBRangeLabel(bar, 0.050);
                                            }

                                            currentend = currentstart;
                                        }
                                        if (direction)
                                            localcount--;
                                        else
                                            localcount++;
                                    }
                                }
                            }
                            else
                            {
                                if (direction)
                                    localcount = mtse.End - modificationcount;
                                else
                                    localcount = mtse.Start + modificationcount;
                                if (Regex.IsMatch(mtse.SequenceTag, @"[a-z]"))
                                {
                                    int i = 0;
                                    int j = 0;
                                    foreach (char s in mtse.SequenceTag)
                                    {
                                        if (localcount == countforhighlight)
                                        {
                                            if (direction)
                                                countforhighlight--;
                                            else
                                                countforhighlight++;
                                            if (i != j)
                                            {
                                                j++;
                                                modificationcount++;
                                                if (direction)
                                                    localcount--;
                                                else
                                                    localcount++;
                                                continue;
                                            }
                                            i++;
                                            string lclstrng = Convert.ToString(s);
                                            if (Regex.IsMatch(Convert.ToString(mtse.SequenceTag[i]), @"[a-z]"))
                                            {
                                                lclstrng = lclstrng + Convert.ToString(mtse.SequenceTag[i]);
                                                currentstart = currentend - AminoAcidHelpers.AminoAcidMass2[lclstrng];
                                            }
                                            else
                                            {
                                                currentstart = currentend - sequencelength(lclstrng);
                                                j++;
                                            }
                                            bool start = false;
                                            bool end = false;
                                            if (allthemonomasses.Any(a => Math.Abs(Convert.ToDouble(a.XValue) - currentend) <= PPMCalc.CurrentPPM(currentend) + 0.1))
                                            {
                                                bar = new AnnotationBar()
                                                {
                                                    End = currentend,
                                                    Start = currentstart,
                                                    Name = Convert.ToString(lclstrng),
                                                    EndScore = 1000,
                                                    StartScore = 1000,
                                                    Index = Convert.ToString(currentend) + lclstrng + Convert.ToString(currentstart)
                                                };
                                                end = true;
                                                AddDBRangeLabel(bar, 0.050, true, false);
                                            }
                                            if (allthemonomasses.Any(a => Math.Abs(Convert.ToDouble(a.XValue) - currentstart) <= PPMCalc.CurrentPPM(currentstart) + 0.1))
                                            {
                                                bar = new AnnotationBar()
                                                {
                                                    End = currentend,
                                                    Start = currentstart,
                                                    Name = Convert.ToString(lclstrng),
                                                    EndScore = 1000,
                                                    StartScore = 1000,
                                                    Index = Convert.ToString(currentend) + lclstrng + Convert.ToString(currentstart)
                                                };
                                                start = true;
                                                AddDBRangeLabel(bar, 0.050, false, true);
                                            }
                                            Monomasses.AddRange(allthemonomasses.Where(a => Math.Abs(Convert.ToDouble(a.XValue) - currentend) <= PPMCalc.CurrentPPM(currentend) + 0.1).ToList());
                                            Monomasses.AddRange(allthemonomasses.Where(a => Math.Abs(Convert.ToDouble(a.XValue) - currentstart) <= PPMCalc.CurrentPPM(currentstart) + 0.1).ToList());
                                            if (start && end)
                                            {

                                            }
                                            else if (start)
                                            {
                                                bar = new AnnotationBar()
                                                {
                                                    End = currentend,
                                                    Start = currentstart,
                                                    Name = Convert.ToString(lclstrng),
                                                    EndScore = 1000,
                                                    StartScore = 1000,
                                                    Index = Convert.ToString(currentend) + lclstrng + Convert.ToString(currentstart)
                                                };
                                                AddDBRangeLabel(bar, 0.0502, true, false);
                                            }
                                            else if (end)
                                            {
                                                bar = new AnnotationBar()
                                                {
                                                    End = currentend,
                                                    Start = currentstart,
                                                    Name = Convert.ToString(lclstrng),
                                                    EndScore = 1000,
                                                    StartScore = 1000,
                                                    Index = Convert.ToString(currentend) + lclstrng + Convert.ToString(currentstart)
                                                };
                                                AddDBRangeLabel(bar, 0.0502, false, true);
                                            }
                                            else
                                            {
                                                bar = new AnnotationBar()
                                                {
                                                    End = currentend,
                                                    Start = currentstart,
                                                    Name = Convert.ToString(lclstrng),
                                                    EndScore = 1000,
                                                    StartScore = 1000,
                                                    Index = Convert.ToString(currentend) + lclstrng + Convert.ToString(currentstart)
                                                };
                                                AddDBRangeLabel(bar, 0.050);
                                            }
                                            currentend = currentstart;
                                        }
                                        if (direction)
                                            localcount--;
                                        else
                                            localcount++;
                                    }
                                }
                                else
                                {
                                    foreach (char s in mtse.SequenceTag)
                                    {
                                        if (localcount == countforhighlight)
                                        {
                                            if (direction)
                                                countforhighlight--;
                                            else
                                                countforhighlight++;
                                            string lclstrng = Convert.ToString(s);
                                            currentstart = currentend - sequencelength(lclstrng);
                                            bool start = false;
                                            bool end = false;
                                            if (allthemonomasses.Any(a => Math.Abs(Convert.ToDouble(a.XValue) - currentend) <= PPMCalc.CurrentPPM(currentend) + 0.1))
                                            {
                                                bar = new AnnotationBar()
                                                {
                                                    End = currentend,
                                                    Start = currentstart,
                                                    Name = Convert.ToString(lclstrng),
                                                    EndScore = 1000,
                                                    StartScore = 1000,
                                                    Index = Convert.ToString(currentend) + lclstrng + Convert.ToString(currentstart)
                                                };
                                                AddDBRangeLabel(bar, 0.050, true, false);
                                                end = true;
                                            }
                                            if (allthemonomasses.Any(a => Math.Abs(Convert.ToDouble(a.XValue) - currentstart) <= PPMCalc.CurrentPPM(currentstart) + 0.1))
                                            {
                                                bar = new AnnotationBar()
                                                {
                                                    End = currentend,
                                                    Start = currentstart,
                                                    Name = Convert.ToString(lclstrng),
                                                    EndScore = 1000,
                                                    StartScore = 1000,
                                                    Index = Convert.ToString(currentend) + lclstrng + Convert.ToString(currentstart)
                                                };
                                                AddDBRangeLabel(bar, 0.050, false, true);
                                                start = true;
                                            }

                                            Monomasses.AddRange(allthemonomasses.Where(a => Math.Abs(Convert.ToDouble(a.XValue) - currentend) <= PPMCalc.CurrentPPM(currentend) + 0.1).ToList());
                                            Monomasses.AddRange(allthemonomasses.Where(a => Math.Abs(Convert.ToDouble(a.XValue) - currentstart) <= PPMCalc.CurrentPPM(currentstart) + 0.1).ToList());
                                            if (start && end)
                                            {

                                            }
                                            else if (start)
                                            {
                                                bar = new AnnotationBar()
                                                {
                                                    End = currentend,
                                                    Start = currentstart,
                                                    Name = Convert.ToString(lclstrng),
                                                    EndScore = 1000,
                                                    StartScore = 1000,
                                                    Index = Convert.ToString(currentend) + lclstrng + Convert.ToString(currentstart)
                                                };
                                                AddDBRangeLabel(bar, 0.0502, true, false);
                                            }
                                            else if (end)
                                            {
                                                bar = new AnnotationBar()
                                                {
                                                    End = currentend,
                                                    Start = currentstart,
                                                    Name = Convert.ToString(lclstrng),
                                                    EndScore = 1000,
                                                    StartScore = 1000,
                                                    Index = Convert.ToString(currentend) + lclstrng + Convert.ToString(currentstart)
                                                };
                                                AddDBRangeLabel(bar, 0.0502, false, true);
                                            }
                                            else
                                            {
                                                bar = new AnnotationBar()
                                                {
                                                    End = currentend,
                                                    Start = currentstart,
                                                    Name = Convert.ToString(lclstrng),
                                                    EndScore = 1000,
                                                    StartScore = 1000,
                                                    Index = Convert.ToString(currentend) + lclstrng + Convert.ToString(currentstart)
                                                };
                                                AddDBRangeLabel(bar, 0.050);
                                            }
                                            currentend = currentstart;
                                        }
                                        if (direction)
                                            localcount--;
                                        else
                                            localcount++;
                                    }
                                }
                            }
                            if (firstmtse.SequenceTag != mtse.SequenceTag)
                            {
                                if (Math.Abs(mtse.Gap) > 0)
                                {
                                    currentstart = currentend - mtse.Gap;
                                    bar = new AnnotationBar()
                                    {
                                        End = currentend,
                                        Start = currentstart,
                                        Name = Convert.ToString(18),
                                        EndScore = 1000,
                                        StartScore = 1000,
                                        Index = Convert.ToString(currentend) + Convert.ToString(18) + Convert.ToString(currentstart)
                                    };
                                    //end = true;
                                    AddDBRangeLabel(bar, 0.050, true, false);
                                    currentend = currentstart;
                                }
                            }
                        }
                        else if (mtse.confidence == AminAcidConfidence.Gap)
                        {
                            if (direction)
                                localcount = mtse.End - modificationcount;
                            else
                                localcount = mtse.Start + modificationcount;
                            int gapc = 0;
                            while (localcount != countforhighlight)
                            {
                                if (direction)
                                    localcount--;
                                else
                                    localcount++;
                                gapc++;
                            }
                            if (direction)
                                countforhighlight = mtse.Start;
                            else
                                countforhighlight = mtse.End;
                            currentstart = currentend - sequencelength(mtse.SequenceTag.Substring(gapc, mtse.SequenceTag.Length - gapc)) - mtse.Gap;
                            bar = new AnnotationBar()
                            {
                                End = currentend,
                                Start = currentstart,
                                Name = mtse.SequenceTag.Substring(gapc, mtse.SequenceTag.Length - gapc) + " +  Δ" + mtse.Gap.ToString(MassValueFormat),
                                EndScore = 1000,
                                StartScore = 1000,
                                Index = Convert.ToString(currentend) + mtse.SequenceTag + Convert.ToString(currentstart)
                            };
                            AddDBRangeLabel(bar, 0.300);
                            currentend = currentstart;
                        }
                        else if (mtse.confidence == AminAcidConfidence.NotSure)
                        {
                            if (direction)
                                localcount = mtse.End - modificationcount;
                            else
                                localcount = mtse.Start + modificationcount;
                            int gapc = 0;
                            while (localcount != countforhighlight)
                            {
                                if (direction)
                                    localcount--;
                                else
                                    localcount++;
                                gapc++;
                            }
                            if (direction)
                                countforhighlight = mtse.Start;
                            else
                                countforhighlight = mtse.End;



                            if (mtse.End == maxend && hasanotsuremaxend) ///Checking if this is the correct mtse to add a water loss to.
                            {
                                currentstart = currentend - sequencelength(mtse.SequenceTag.Substring(gapc, mtse.SequenceTag.Length - gapc)) - mtse.Gap;/// -Molecules.Water;
                                if ((ParentMass - mtse.EndMonoMass) > (mtse.StartMonoMass)) /// Verifying which end it is. If this is the case then it is close to zero, otherwise close to ParentMass
                                {
                                    bar = new AnnotationBar() // If it is close to the Zero, since the drawing starts from the Parent Mass need to paint the mtse first then the water molecule
                                    {
                                        End = currentend,
                                        Start = Molecules.Water,
                                        Name = mtse.SequenceTag.Substring(gapc, mtse.SequenceTag.Length - gapc) + (mtse.Gap != 0 ? (" +  Δ " + (mtse.Gap - Molecules.Water).ToString(MassValueFormat)) : string.Empty),
                                        EndScore = 1000,
                                        StartScore = 1000,
                                        Index = Convert.ToString(currentend) + mtse.SequenceTag + Convert.ToString(currentstart) + " +  Δ " + (mtse.Gap - Molecules.Water).ToString(MassValueFormat)
                                    };
                                    AddDBRangeLabel(bar, 0.100);
                                    currentend = currentstart;

                                    bar = new AnnotationBar()
                                    {
                                        End = Molecules.Water,
                                        Start = 0,
                                        Name = "C-Terminus",
                                        //Name = "18",
                                        EndScore = 1000,
                                        StartScore = 1000,
                                        Index = Convert.ToString(currentend) + Convert.ToString(currentstart) + "18"
                                    };
                                    AddDBRangeLabel(bar, 0.0600);
                                }
                                else /// Close to ParentMass
                                {    // If it is close to the ParentMass, since the drawing starts from the Parent Mass need to paint the water molecule then the 
                                    bar = new AnnotationBar()
                                    {
                                        End = ParentMass,
                                        Start = ParentMass - Molecules.Water,
                                        Name = "C-Terminus",
                                        //Name = "18",
                                        EndScore = 1000,
                                        StartScore = 1000,
                                        Index = Convert.ToString(currentend) + Convert.ToString(currentstart) + "18"
                                    };
                                    AddDBRangeLabel(bar, 0.0600);

                                    bar = new AnnotationBar()
                                    {
                                        End = ParentMass - Molecules.Water,
                                        Start = currentstart,
                                        Name = mtse.SequenceTag.Substring(gapc, mtse.SequenceTag.Length - gapc) + (mtse.Gap != 0 ? (" +  Δ " + (mtse.Gap - Molecules.Water).ToString(MassValueFormat)) : string.Empty),
                                        EndScore = 1000,
                                        StartScore = 1000,
                                        Index = Convert.ToString(currentend) + mtse.SequenceTag + Convert.ToString(currentstart) + " +  Δ " + (mtse.Gap - Molecules.Water).ToString(MassValueFormat)
                                    };
                                    AddDBRangeLabel(bar, 0.100);
                                    currentend = currentstart;
                                }
                            }
                            else
                            {
                                currentstart = currentend - sequencelength(mtse.SequenceTag.Substring(gapc, mtse.SequenceTag.Length - gapc)) - mtse.Gap;
                                bar = new AnnotationBar()
                                {
                                    End = currentend,
                                    Start = currentstart,
                                    Name = mtse.SequenceTag.Substring(gapc, mtse.SequenceTag.Length - gapc) + (mtse.Gap != 0 ? (" +  Δ " + (mtse.Gap).ToString(MassValueFormat)) : string.Empty),
                                    EndScore = 1000,
                                    StartScore = 1000,
                                    Index = Convert.ToString(currentend) + mtse.SequenceTag + Convert.ToString(currentstart) + " +  Δ " + (mtse.Gap).ToString(MassValueFormat)
                                };
                                AddDBRangeLabel(bar, 0.100);
                                currentend = currentstart;
                            }
                            //if (direction)
                            //{
                            //    if (firstmtse.Start == mtse.Start)
                            //    {
                            //        currentstart = currentend - sequencelength(mtse.SequenceTag.Substring(gapc, mtse.SequenceTag.Length - gapc)) - mtse.Gap - Molecules.Water;
                            //        bar = new AnnotationBar()
                            //        {
                            //            End = currentend,
                            //            Start = currentstart,
                            //            Name = mtse.SequenceTag.Substring(gapc, mtse.SequenceTag.Length - gapc) + (mtse.Gap != 0 ? (" +  Δ " + Convert.ToString(mtse.Gap - Molecules.Water)) : string.Empty),
                            //            EndScore = 1000,
                            //            StartScore = 1000,
                            //            Index = Convert.ToString(currentend) + mtse.SequenceTag + Convert.ToString(currentstart) + " +  Δ " + Convert.ToString(mtse.Gap - Molecules.Water)
                            //        };
                            //        AddDBRangeLabel(bar, 0.100);
                            //        currentend = currentstart;
                            //    }
                            //    else
                            //    {
                            //        currentstart = currentend - sequencelength(mtse.SequenceTag.Substring(gapc, mtse.SequenceTag.Length - gapc)) - mtse.Gap;
                            //        bar = new AnnotationBar()
                            //        {
                            //            End = currentend,
                            //            Start = currentstart,
                            //            Name = mtse.SequenceTag.Substring(gapc, mtse.SequenceTag.Length - gapc) + (mtse.Gap != 0 ? (" +  Δ " + Convert.ToString(mtse.Gap)) : string.Empty),
                            //            EndScore = 1000,
                            //            StartScore = 1000,
                            //            Index = Convert.ToString(currentend) + mtse.SequenceTag + Convert.ToString(currentstart) + " +  Δ " + Convert.ToString(mtse.Gap)
                            //        };
                            //        AddDBRangeLabel(bar, 0.100);
                            //        currentend = currentstart;
                            //    }
                            //}
                            //else
                            //{
                            //    if (lstmtse.Start == mtse.Start)
                            //    {
                            //        currentstart = currentend - sequencelength(mtse.SequenceTag.Substring(gapc, mtse.SequenceTag.Length - gapc)) - mtse.Gap - Molecules.Water;
                            //        bar = new AnnotationBar()
                            //        {
                            //            End = currentend,
                            //            Start = currentstart,
                            //            Name = mtse.SequenceTag.Substring(gapc, mtse.SequenceTag.Length - gapc) + (mtse.Gap != 0 ? (" +  Δ " + Convert.ToString(mtse.Gap - Molecules.Water)) : string.Empty),
                            //            EndScore = 1000,
                            //            StartScore = 1000,
                            //            Index = Convert.ToString(currentend) + mtse.SequenceTag + Convert.ToString(currentstart) + " +  Δ " + Convert.ToString(mtse.Gap - Molecules.Water)
                            //        };
                            //        AddDBRangeLabel(bar, 0.100);
                            //        currentend = currentstart;
                            //    }
                            //    else
                            //    {
                            //        currentstart = currentend - sequencelength(mtse.SequenceTag.Substring(gapc, mtse.SequenceTag.Length - gapc)) - mtse.Gap;
                            //        bar = new AnnotationBar()
                            //        {
                            //            End = currentend,
                            //            Start = currentstart,
                            //            Name = mtse.SequenceTag.Substring(gapc, mtse.SequenceTag.Length - gapc) + (mtse.Gap != 0 ? (" +  Δ " + Convert.ToString(mtse.Gap)) : string.Empty),
                            //            EndScore = 1000,
                            //            StartScore = 1000,
                            //            Index = Convert.ToString(currentend) + mtse.SequenceTag + Convert.ToString(currentstart) + " +  Δ " + Convert.ToString(mtse.Gap)
                            //        };
                            //        AddDBRangeLabel(bar, 0.100);
                            //        currentend = currentstart;
                            //    }
                            //}
                        }
                    }

                    if (Math.Abs(currentend - Molecules.Water) < 0.2)
                    {
                        //currentmtse.RawSequenceTag currentmtse.SequenceTag

                        bar = new AnnotationBar()
                        {
                            End = 0,
                            Start = currentend,
                            Name = "C-Terminus",
                            //Name = "18",
                            EndScore = 1000,
                            StartScore = 1000,
                            Index = Convert.ToString(currentend) + Convert.ToString(currentstart) + "18"
                        };
                        AddDBRangeLabel(bar, 0.0600);
                    }
                    else if (Math.Abs((sr.ParentMass - initialend) - Molecules.Water) < 0.2)
                    {
                        bar = new AnnotationBar()
                        {
                            End = sr.ParentMass,
                            Start = initialend,
                            Name = "C-Terminus",
                            //Name = "18",
                            EndScore = 1000,
                            StartScore = 1000,
                            Index = Convert.ToString(currentend) + Convert.ToString(currentstart) + "18"
                        };
                        AddDBRangeLabel(bar, 0.0600);
                    }


                    if ((currentend - Molecules.Water) > 0.2)
                    {
                        bar = new AnnotationBar()
                        {
                            End = currentend,
                            Start = 0,
                            Name = " +  Δ" + Convert.ToString(currentend),
                            EndScore = 1000,
                            StartScore = 1000,
                            Index = Convert.ToString(currentend)
                        };
                        AddDBRangeLabel(bar, 0.300);
                    }



                    Monomasses = Monomasses.GroupBy(a => a.XValue).Select(a => a.First()).ToList();

                    List<DataPoint> tempmonomasses = new List<DataPoint>();
                    List<double> monomasslist = new List<double>();
                    foreach (List<double> dbmslst in matchstartends.Where(a => a.confidence == AminAcidConfidence.Sure).Select(a => a.MonoMasses).ToList())
                    {
                        if (dbmslst != null)
                            monomasslist.AddRange(dbmslst);
                    }

                    monomasslist = monomasslist.GroupBy(a => a).Select(a => a.First()).ToList();

                    foreach (double dt in monomasslist)
                    {
                        tempmonomasses.Add(new DataPoint()
                        {
                            XValue = dt,
                            YValue = setdbmonointensity
                        });
                    }

                    MonoMassesfordbSequence.DataSource = Monomasses;
                }
            }

            catch (Exception ex)
            {
                Debug.WriteLine("Exception: " + ex.Message);
            }
            finally
            {
                if (CurrentSpectrum.Any())
                {
                    double min = 0;
                    double max = sequencetagmass = CurrentSpectrum.ParentIon != null ? CurrentSpectrum.ParentIon.MonoMass : CurrentSpectrum.MaxBy(p => p.Mass).Mass;

                    if (max <= CurrentSpectrum.ParentMass)
                        max = CurrentSpectrum.ParentMass.Value;

                    min = min - (max - min) * 0.035;  // This gives us a buffer on the ends of the X axis
                    max = max + (max - min) * 0.035;  // This gives us a buffer on the ends of the X axis

                    BottomChart.AxesX[0].AxisMinimum = min;
                    BottomChart.AxesX[0].AxisMaximum = max;

                    var theAxis = BottomChart.AxesX[0];

                    zoom(theAxis, min, max);
                }

                if (true)
                {
                    dtgrdSearchSequence.SelectedIndex = 0;
                }
            }

        }

        /// <summary>
        /// Sequence Length based on all the match lists. Even the one's which have modification
        /// </summary>
        /// <param name="sequence"></param>
        /// <returns></returns>
        private static double sequencelengthusingmodifiedaminoacids(string sequence)
        {
            double adjdj = 0;
            double length = 0;
            string newemptystring = string.Empty;
            try
            {
                int i = 0;
                int j = 0;
                foreach (string a in sequence.Select(a => a.ToString()).ToArray())
                {
                    if (i != j)
                    {
                        j++;
                        continue;
                    }
                    i++;

                    if (Regex.IsMatch(Convert.ToString(sequence[i]), @"^[a-z*]+$"))
                    {
                        length += AminoAcidHelpers.AminoAcidMass2[a + sequence[i]];
                    }
                    else
                    {
                        length += AminoAcidHelpers.AminoAcidMass2[a];
                        j++;
                    }
                }
            }
            catch (Exception ex)
            {
                return double.NaN;
            }

            return length;
        }

        public double sequencelength(string sequence)
        {
            double length = 0;

            foreach (char c in sequence)
            {
                if (AminoAcidHelpers.AminoAcids.ContainsKey(c) == false) return double.NaN;

                length += AminoAcidHelpers.AminoAcids[c];
            }

            return length;
        }
        private void btnMergeFullMSScans_Click(object sender, RoutedEventArgs e)
        {
            Dispatcher.Invoke((Action)(() =>
            {
                busymergespectra.IsBusy = true;
            }));
            BackgroundWorker bgworkerforParentIonMerge = new BackgroundWorker();
            bgworkerforParentIonMerge.DoWork += bgworkerforParentIonMerge_DoWork;
            bgworkerforParentIonMerge.RunWorkerCompleted += bgworkerforParentIonMerge_RunWorkerCompleted;
            bgworkerforParentIonMerge.RunWorkerAsync();
        }

        void bgworkerforParentIonMerge_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            Dispatcher.Invoke((Action)(() =>
            {
                busymergespectra.IsBusy = false;
                var mergeList = new List<SpectrumInfo>();
                var specs = (grdMerge1.Items.SourceCollection as System.Collections.ObjectModel.ObservableCollection<SpectrumInfo>);
                foreach (SpectrumInfo spec in specs.Where(a => a.IsParentScan).ToList())
                {
                    mergeList.Add(spec);
                }

                using (new WaitCursor())
                {
                    DisplayNewSpectrum(mergeList);
                }
                dtgridsequences.Visibility = System.Windows.Visibility.Collapsed; //The sequences are not shown once the merge happens
                btnFindAA.Visibility = System.Windows.Visibility.Visible; //The option to show new sequences
                ClearSequenceMatch();
                btnMatch.IsEnabled = false;
                txtMatchSequence.IsEnabled = false;
            }));
        }

        void bgworkerforParentIonMerge_DoWork(object sender, DoWorkEventArgs e)
        {

        }

        DateTime genTime = DateTime.Now;

        private void UpdateGenTimeCallback(object sender, EventArgs e)
        {
            if (DateTime.Now.Subtract(genTime).TotalDays >= 1)
            {
                lblRunTime.Content = DateTime.Now.Subtract(genTime).ToString(@"dd\:hh\:mm\:ss");
            }
            else if (DateTime.Now.Subtract(genTime).TotalHours >= 1)
            {
                lblRunTime.Content = DateTime.Now.Subtract(genTime).ToString(@"hh\:mm\:ss");
            }
            else
            {
                lblRunTime.Content = DateTime.Now.Subtract(genTime).ToString(@"mm\:ss");
            }
        }

        List<List<SpectrumInfo>> GetindividualSpectrum(ObservableCollection<SpectrumInfo> mgrspectra)
        {
            List<List<SpectrumInfo>> relativespectralinfo = new List<List<SpectrumInfo>>();

            var mgr_05 = mgrspectra.Where(a => a.RelativeIntensity >= 0.5).OrderByDescending(a => a.RelativeIntensity).ToList();

            int mgr_05_count = mgr_05.Count;
            int j = 0;
            for (int i = 0; i < mgr_05_count;)
            {
                i = i + Math.Min(Math.Abs(mgr_05_count - i), 50);
                if (i <= mgr_05_count)
                {
                    relativespectralinfo.Add(mgr_05.GetRange(j, i - j));
                    j = i;
                }
                else
                {
                    break;
                }
            }

            var mgr_05_01 = mgrspectra.Where(a => a.RelativeIntensity < 0.5 && a.RelativeIntensity >= 0.1).OrderByDescending(a => a.RelativeIntensity).ToList();

            j = 0;
            int mgr_05_01_count = mgr_05_01.Count;

            for (int i = 0; i < mgr_05_01_count;)
            {
                i = i + Math.Min(Math.Abs(mgr_05_01_count - i), 50);

                if (i <= mgr_05_01_count)
                {
                    relativespectralinfo.Add(mgr_05_01.GetRange(j, (i - j)));
                    j = i;
                }
                else
                {
                    break;
                }
            }

            var mgr_01 = mgrspectra.Where(a => a.RelativeIntensity < 0.1).OrderByDescending(a => a.RelativeIntensity).ToList();

            j = 0;
            int mgr_01_count = mgr_01.Count;

            for (int i = 0; i < mgr_01_count;)
            {
                i = i + Math.Min(Math.Abs(mgr_01_count - i), 50);

                if (i <= mgr_01_count)
                {
                    relativespectralinfo.Add(mgr_01.GetRange(j, i - j));
                    j = i;
                }
                else
                {
                    break;
                }
            }

            return relativespectralinfo;
        }

        /// <summary>
        /// Generate the file header based on the file name.
        /// </summary>
        /// <param name="FileName"></param>
        void WriteSequenceSearchHeadertoFile(string FileName)
        {
            StringBuilder strbldr = new StringBuilder();
            strbldr.Append("ScanNumbers,");
            strbldr.Append("ParentMass,");
            strbldr.Append("Parentz_s,");
            strbldr.Append("BlastTagforTopProtein,");
            strbldr.Append("Description,");
            strbldr.Append("Start,");
            strbldr.Append("End,");
            strbldr.Append("tStart,");
            strbldr.Append("tEnd,");
            strbldr.Append("Hits,");
            strbldr.Append("DeltaMassVersusProtein,");
            strbldr.Append("Sequence" + "\n");
            //FileName = filenamegenerator(FileName);

            try
            {
                File.AppendAllText(FileName, Convert.ToString(strbldr));
            }
            catch (Exception ex)
            {
                throw ex;
            }
        }

        /// <summary>
        /// Generates a file based current file name
        /// Creates a new file name if the file already exists
        /// </summary>
        /// <param name="FileName"></param>
        /// <returns></returns>
        string filenamegenerator(string FileName)
        {
            if (File.Exists(FileName + ".csv"))
            {
                int i = 1;
                while (true)
                {
                    if (File.Exists(FileName + i.ToString() + ".csv"))
                    {
                        i++;
                    }
                    else
                    {
                        FileName = FileName + i.ToString() + ".csv";
                        break;
                    }
                }
            }
            return FileName;
        }

        /// <summary>
        /// Write the current Sequence to a csv file based on FileName and the given sequence
        /// </summary>
        /// <param name="FileName"></param>
        /// <param name="sqssearch"></param>
        void WriteSequenceSearchtoFile(string FileName, SearchResult sqssearch)
        {
            try
            {
                StringBuilder strbldr = new StringBuilder();

                strbldr.Append(sqssearch.ScanNumbers.Replace(",", " ") + ",");
                strbldr.Append(Convert.ToString(sqssearch.ParentMass) + ",");
                strbldr.Append(sqssearch.Parentz_s.Replace(",", " ") + ",");
                strbldr.Append(sqssearch.BlastTagforTopProtein + ",");
                strbldr.Append(sqssearch.Description + ",");
                strbldr.Append(Convert.ToString(sqssearch.Start) + ",");
                strbldr.Append(Convert.ToString(sqssearch.End) + ",");
                strbldr.Append(Convert.ToString(sqssearch.tStart) + ",");
                strbldr.Append(Convert.ToString(sqssearch.tEnd) + ",");
                strbldr.Append(Convert.ToString(sqssearch.YellowandGreenTagHits) + ",");
                strbldr.Append(Convert.ToString(Math.Round(sqssearch.DeltaMassVersusProtein, 4)) + ",");
                strbldr.Append(sqssearch.Sequence + "\n");
                File.AppendAllText(FileName, Convert.ToString(strbldr));
            }
            catch (IOException ex)
            {
                System.Windows.MessageBox.Show(this, "Failed to write results to the temporary file. Close file to allow writing.");
            }
        }

        void bindautoscanvalues(int autoscanindi, int autoascanmerged)
        {
            lblAutoScanNumberofScans.Content = "Number of individual scans queried =" + autoscanindi + "  Number of Merged scans queried =" + autoascanmerged;
        }

        ObservableCollection<SearchResult> publicresults = new ObservableCollection<SearchResult>();
        private void btnGenerateSearchSummary_Click(object sender, RoutedEventArgs e)
        {
            if (cTokenSource != null)
            {
                cTokenSource.Cancel();
                btnGenerateSearchSummary.IsEnabled = false;
                return;
            }

            if (MainPointProvider == null)
            {
                System.Windows.MessageBox.Show("Mass Spectral data must be loaded before you can Auto Scan it.  ", "No raw data loaded", MessageBoxButton.OK, MessageBoxImage.Exclamation);
                return;
            }

            Dictionary<Guid, List<string>> alltheblastptagsforsequences = new Dictionary<Guid, List<string>>();
            NetworkIssues = false;
            var allthevalues = new Dictionary<Guid, BlastpTags>();
            //txtblkSequenceSearchResult.Visibility = System.Windows.Visibility.Hidden;

            //string path = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);

            //string currentfilefolderpath = path + "\\AutoScanResults";

            //if (!System.IO.Directory.Exists(currentfilefolderpath))
            //{
            //    System.IO.Directory.CreateDirectory(currentfilefolderpath);
            //}

            if (!NetworkInterface.GetIsNetworkAvailable())
            {
                if (!DechargerVM.UseFasta)
                {
                    lblDataSource.Text = "Load FASTA for search.";
                    btnSequenceSearchSource.ToolTip = "Load FASTA for search.";
                    System.Windows.MessageBox.Show("No network connectivity. Use a FASTA file for search.");
                    return;
                }
            }

            //int numberofautoscans = 0;
            //int numberofmergedautoscans = 0;

            App.FASTAName = Convert.ToString(btnSequenceSearchSource.ToolTip);

            //var allvalueswithnohits = new Dictionary<Guid, BlastpTags>();



            btnGenerateSearchSummary.Content = "Cancel";
            genTime = DateTime.Now;
            genTimer.Start();

            //string currentfilename = path + "\\AutoScanResults" + "\\" + DechargerVM.SpectralDataFilename + "_AutoScanResults" + ".csv";
            //currentfilename = filenamegenerator(currentfilename);
            //WriteSequenceSearchHeadertoFile(currentfilename);

            //var modifieditems = new ObservableCollection<ModificationsList>();
            DechargerVM.ClearResults();  // Reset the View Model
                                         //DechargerVM.SpectralDataFileHash = new FileInfo(MainPointProvider.Filename).Sha256Hash();
            UpdateWorkspaceTitle();

            DechargerVM.SearchStartTime = DateTime.Now;

            DechargerVM.SpectralDataFilename = MainPointProvider.Source.Name;

            ///When using the SourceHash for the Agilent file, it is throwing an error.
            //if (DechargerVM.CurrentFileType == clsFileType.MSFileType.Agilent)
            //{
            //    DechargerVM.SpectralDataFileHash = Convert.ToString(MainPointProvider.Source.GetHashCode());
            //}
            //else
            //{
            DechargerVM.SpectralDataFileHash = MainPointProvider.SourceHash;
            //}

            publicresults = DechargerVM.SearchResults;
            int start = int.Parse(txtStart.Text);
            int end = (txtEnd.Text.Trim() == "*" ? MainPointProvider.ScanIndex(MainPointProvider.TIC.MaxKey) : int.Parse(txtEnd.Text));

            //var modificationslist = new ListCollectionView(modifieditems);

            if (DechargerVM.UseFasta)
            {
                dtgridautoscandescriptionhyperlink.Visibility = System.Windows.Visibility.Hidden;
                dtgridautoscandescriptiontext.Visibility = System.Windows.Visibility.Visible;
            }
            else
            {
                dtgridautoscandescriptionhyperlink.Visibility = System.Windows.Visibility.Visible;
                dtgridautoscandescriptiontext.Visibility = System.Windows.Visibility.Hidden;
            }

            cTokenSource = new CancellationTokenSource();
            var cToken = cTokenSource.Token;



            ParallelOptions prlop = new ParallelOptions();
            prlop.MaxDegreeOfParallelism = usingParallel ? Math.Max(Environment.ProcessorCount-2, 1) : 1;
            if (System.Diagnostics.Debugger.IsAttached) prlop.MaxDegreeOfParallelism = 1;
            prlop.CancellationToken = cToken;

            //StringBuilder AlltheSequencetagsfromallscans = new StringBuilder();

            // DateTime dtbeforetags = DateTime.Now;

            //mergeView = new ListCollectionView(mgrspectra);

            //List<List<SpectrumInfo>> relativespectralinfo = new List<List<SpectrumInfo>>();

            //if (!(Properties.Settings.Default.UseBlast && DechargerVM.UseFasta))
            //{
            //    relativespectralinfo.Add(mgrspectra.Where(a => a.RelativeIntensity >= 0.5).ToList());
            //    relativespectralinfo.Add(mgrspectra.Where(a => a.RelativeIntensity < 0.5 && a.RelativeIntensity >= 0.1).ToList());
            //    relativespectralinfo.Add(mgrspectra.Where(a => a.RelativeIntensity < 0.1).ToList());
            //}
            //else if (Properties.Settings.Default.UseBlast && DechargerVM.UseFasta)
            //{
            //    relativespectralinfo = GetindividualSpectrum(mgrspectra);
            //}

            //Dispatcher.BeginInvoke((Action)(() =>
            //{
            //    bsyforAutoScan.Maximum = 0;
            //    bsyforAutoScan.Minimum = start;
            //    //bsyforAutoScan.IsIndeterminate = true;
            //}));

            //execute while loop on a background thread by starting a new Task...:
            System.Threading.Tasks.Task.Factory.StartNew(
            () =>
            {
                try
                {
                    // Populate the Parent Mass of all MS2 scans
                    var scanInfoList = new List<SpectrumInfo>();
                    //= MainPointProvider.GetParentInfo(cToken, start, end).Where(a => a.ParentIon != null).OrderByDescending(s=>s.Intensity).ToList(); //.Where(a => a.ParentIon != null && a.Activation != null).GroupBy(a => (int)a.TimeSort).Where(a => a.Count() >= 2).ToList();
                    double progress = 0;
                    double newProgress = 0;

                    for (int aScanNum = start; aScanNum <= end; aScanNum++) 
                    {
                        if (cToken.IsCancellationRequested)
                            throw new OperationCanceledException();

                        scanInfoList.AddSkipNull(MainPointProvider.GetParentInfo(aScanNum));

                        newProgress = ((double)aScanNum / ((end + 1) - start)) * 100;

                        if ((int)progress < (int)newProgress)
                        {
                            progress = newProgress;
                            // Updating the UI is expensive, so only do it when the percentage has changed.  
                            Dispatcher.BeginInvoke((Action)(() =>
                            {
                                bsyforAutoScan.Value = (int)progress;
                                lblAutoScanNumberofScans.Content = "Detecting Parent Masses: " + bsyforAutoScan.Value + "%";
                            }));
                        }
                    }

                    Dispatcher.BeginInvoke((Action)(() =>
                    {
                        //bsyforAutoScan.Value = (int)(((float)aScanNum / ((end + 1) - start)) * 100);
                        lblAutoScanNumberofScans.Content = "Looking for spectra to merge";
                    }));

                    var mergeGroups = new List<List<SpectrumInfo>>();

                    double groupingMassDelta = 0.5;  //amu
                    float groupingTimeDelta = 5;  //minutes

                    // Go through parent list and identify merge groups
                    // Mark the group members, so that there are no repeats when parallel execution.  
                    foreach (var sil in scanInfoList.Where(a => a.ParentIon != null))
                    {
                        if (sil.IsMergeMember) continue;

                        if (Properties.Settings.Default.AutoMergingEnabled)
                        {
                            // find other scans close to si in RT and Parent Mass
                            var scanGroup = scanInfoList.Where(s => s.ParentIon != null && (s.IsMergeMember == false) && (Math.Abs(s.ParentMass.Value - sil.ParentMass.Value) < groupingMassDelta) && (Math.Abs(s.RetentionTime.Value - sil.RetentionTime.Value) < groupingTimeDelta) && MassSpectrometry.MassSpecExtensions.CanMergeActivations(sil.Activation, s.Activation));
                            mergeGroups.Add(scanGroup.ToList());

                            foreach (var aScan in scanGroup) aScan.IsMergeMember = true;
                        }
                        else
                        {
                            mergeGroups.Add(scanInfoList.Where(s => s.ParentIon != null && s.ScanNumber == sil.ScanNumber).ToList());
                        }
                    }

                    Dispatcher.BeginInvoke((Action)(() =>
                    {
                        bsyforAutoScan.Value = 0;
                        lblAutoScanNumberofScans.Content = "Searching for de novo tags and proteins. ";
                    }));

                    progress = 0;
                    newProgress = 0;

                    var totalIonCurrent = mergeGroups.Sum(mg => mg.Sum(si => si.Intensity));

                    // iterate through singles and groups in descending intensity order
                    Parallel.ForEach(mergeGroups.OrderByDescending(s => s.Sum(x => x.Intensity)), prlop, aScanInfoGroup =>
                    {
                        // Generate a single spectrum object with merged or single spectrum as needed
                        var spectrum = new SuperSpectrum(MainPointProvider, aScanInfoGroup.Select(sig => sig.ScanNumber).ToArray());

                        //IEnumerable<SearchResult> tagResults = new List<SearchResult>();
                        var modifications = new List<double>();
                        var mdf = new ModificationsList();

                        // Find tags in forward direction
                        var denovoTags = FindAllSequenceTagsWithoutModifications(spectrum.Ions, modifications, ref mdf, spectrum.ParentIon.MonoMass, true, cToken)
                                                     .Where(a => a.Sequence.Length >= Properties.Settings.Default.SequenceTagLength)
                                                     .OrderByDescending(a => a.Sequence.Length)
                                                     .ToList();



                        // Find tags in reverse direction -- really needed?
                        //denovoTags.AddRange(FindAllSequenceTagsWithoutModifications(spectrum.Ions, modifications, ref mdf, spectrum.ParentIon.MonoMass, false)
                        //                                                            .OrderByDescending(a => a.Sequence.Length)
                        //                                                            .Where(a => a.Sequence.Length >= Properties.Settings.Default.SequenceTagLength)
                        //                                                            .ToList());


                        //denovoTags = denovoTags.GroupBy(a => a.RawSequence).Select(a => a.First()).ToList();

                        var results = new List<SearchResult>();

                        var tagsToSearch = denovoTags.Where(t => t.Sequence.Length >= Properties.Settings.Default.SequenceTagLength);

                        if (tagsToSearch.Any())
                        {
                            Debug.Print("Tags found for Scan " + string.Join(",", aScanInfoGroup.Select(s => s.ScanNumber)));
                            Debug.Print(string.Join("\n", tagsToSearch.Select(t => t.Sequence)));
                        }

                        if (Properties.Settings.Default.UseThoroughSearch == false && tagsToSearch.Count() > 2)
                        {
                            var tempTags = new List<FindSequenceTags.SequenceTag>();
                            tempTags.Add(tagsToSearch.OrderByDescending(t => t.Sequence.Length).MinBy(t => t.Score));  // best score
                            tempTags.Add(tagsToSearch.Except(tempTags).OrderBy(t => t.Score).MaxBy(t => t.Sequence.Length));  // longest 
                            tagsToSearch = tempTags;
                        }

                        Debug.Print("Searching " + tagsToSearch.Count() + " tags");

                        results.AddRange(SearchForProteins(tagsToSearch.Select(t => t.Sequence), denovoTags.Where(tag => tag.Sequence.Length >= Properties.Settings.Default.SequenceTagLength), spectrum, Properties.Settings.Default.UseBlast, cToken, false));

                        //foreach (var aTag in tagsToSearch) /// Properties.Settings.Default.SequenceTagLength)
                        //{
                        //    try
                        //    {

                        //        results.AddRange(SearchforSequence(aTag.Sequence, denovoTags.Where(tag => tag.Sequence.Length >= Properties.Settings.Default.SequenceTagLength), spectrum));

                        //        if (cToken.IsCancellationRequested)
                        //            return;  // this should never happen

                        //        //TODO: get rid of this warningException.  Pass in a UI argument that tells the function to abort without exception when count is maxxed out.  
                        //    }
                        //    catch (WarningException)
                        //    {
                        //        Debug.Print("warningException caught");
                        //        continue;
                        //    }
                        //}

                        newProgress += aScanInfoGroup.Sum(sig => sig.Intensity);

                        if ((int)((newProgress / totalIonCurrent) * 100) > (int)((progress / totalIonCurrent) * 100))
                        {
                            progress = newProgress;

                            Dispatcher.BeginInvoke((Action)(() =>
                            {
                                bsyforAutoScan.Value = (int)((progress / totalIonCurrent) * 100);
                                lblAutoScanNumberofScans.Content = "Searching for de novo tags and proteins: " + bsyforAutoScan.Value + "%";
                            }));
                        }

                        //TODO: Add result anyway for de novo tab!  
                        if (results.Any() == false) return;  // no matches?  exit here...

                        // Pick the best alignment from the results by which one has the most string matches to tags ??  
                        var topHit = results.MaxBy(x => x.TagHits * (x.IsBlastResult ? x.BlastTag.Length : x.QueryTag.Length));  // use expect score to rank for blast hits?  

                        topHit.ApplySpectrumDetails(spectrum);
                        topHit.DontShowall = true;
                        topHit.IsAutoScanIdentified = true;
                        topHit.TagCount = denovoTags.Count();
                        topHit.allspectrums = aScanInfoGroup;  //specs;
                        topHit.TagForTopProtein = topHit.BlastedTagForTopProtein;  // denovoTags.MaxBy(t => t.Sequence.Length).Sequence;

                        // Add the search hit to our results collection VM bound to the UI
                        lock (mainWindow)
                        {
                            Dispatcher.BeginInvoke((Action)(() =>
                            {
                                //searchHit.IsConfirmed = UpdateCurrentConfirmSequence(searchHit);
                                DechargerVM.SearchResults.Add(topHit);

                            }), System.Windows.Threading.DispatcherPriority.Normal, null);
                        }
                    });

                    Dispatcher.BeginInvoke((Action)(() =>
                    {
                        lblAutoScanNumberofScans.Content = "Auto Scan Complete";
                        bsyforAutoScan.Value = 100;
                    }));

                }
                catch (OperationCanceledException)
                {
                    // This exception is normally thrown when cancellation is selected.  It does not indicate an error condition.
                    // https://msdn.microsoft.com/en-us/library/ee256691(v=vs.110).aspx
                    Debug.Print("Cancelling....");

                    Dispatcher.BeginInvoke((Action)(() =>
                    {
                        //bsyforAutoScan.Value = scanInfoList.Count;
                        lblAutoScanNumberofScans.Content = "Auto Scan was cancelled.  ";
                    }), System.Windows.Threading.DispatcherPriority.Normal, null);

                    cTokenSource.Dispose();
                }
                catch (Exception ex)
                {
                    Dispatcher.BeginInvoke((Action)(() => lblAutoScanNumberofScans.Content = ex.Message), null);

                    if (!(ex.Message.ToUpper().Contains("TIMEOUT")))
                    {
                        if (Debugger.IsAttached)
                        {
                            Dispatcher.BeginInvoke((Action)(() =>
                            {
                                bsyforAutoScan.IsIndeterminate = false;
                                System.Windows.MessageBox.Show(ex.Message + "\n" + ex.StackTrace, "Level 1");
                            }), System.Windows.Threading.DispatcherPriority.Normal, null);
                        }
                    }
                    Debug.WriteLine("Error during Search.  ");
                }
                finally
                {
                    Dispatcher.BeginInvoke((Action)(() =>
                    {

                        //bsyforAutoScan.IsIndeterminate = false;
                        btnGenerateSearchSummary.IsEnabled = true;
                        btnGenerateSearchSummary.Content = "Generate";
                        genTimer.Stop();
                        DechargerVM.SearchEndTime = DateTime.Now;
                        //XmlSerializer serializer = new XmlSerializer(typeof(SequenceSearchList));
                        //FileStream fs = new FileStream("SequenceSearchList.ssr.xml", FileMode.Create);
                        //serializer.Serialize(fs, sqssrchlst);
                        //fs.Close();

                        //SequenceSearchList sqsssrlst = new SequenceSearchList();

                        //fs = new FileStream("Seque  nceSearchList.ssr.xml", FileMode.Open);
                        //sqsssrlst = (SequenceSearchList)serializer.Deserialize(fs);

                        //int intsqsssrlst = sqsssrlst.UserName.Length;
                        //int rntsqsssrlst = intsqsssrlst + 100;


                        cTokenSource = null;
                        ////System.Windows.MessageBox.Show("Generation of sequence tags has taken " + DateTime.Now.Subtract(dtbeforetags).TotalMilliseconds + " Milliseconds. All the sequence tags are done!");
                        //System.Reflection.Assembly assemblyInfo = System.Reflection.Assembly.GetExecutingAssembly();
                        ////Location is where the assembly is run from
                        //string assemblyLocation = assemblyInfo.Location;
                        ////CodeBase is the location of the ClickOnce deployment files
                        //Uri uriCodeBase = new Uri(assemblyInfo.CodeBase);
                        //string ClickOnceLocation = System.IO.Path.GetDirectoryName(uriCodeBase.LocalPath.ToString()) + "\\Executables\\";
                        //using (StreamWriter outfile = new StreamWriter(ClickOnceLocation + @"\Queryfile.txt"))
                        //{
                        //    outfile.Write(AlltheSequencetagsfromallscans);
                        //}
                    }), System.Windows.Threading.DispatcherPriority.Normal, null);
                    //}

                    doneautoscan = true;
                }
            }
            , cToken);
        }



        /// <summary>
        /// Display the correct description. If a FASTA file display a text, if using a database display a hyperlink
        /// </summary>
        void DisplayDescription()
        {
            if (DechargerVM.UseFasta)
            {
                txtProteinGridDescriptionhyperlink.Visibility = System.Windows.Visibility.Hidden;
                txtProteinGridDescriptiontxt.Visibility = System.Windows.Visibility.Visible;
            }
            else
            {
                txtProteinGridDescriptionhyperlink.Visibility = System.Windows.Visibility.Visible;
                txtProteinGridDescriptiontxt.Visibility = System.Windows.Visibility.Hidden;
            }
        }

        /// <summary>
        /// Finds the median of a list of values
        /// </summary>
        /// <param name="numbers"></param>
        /// <returns></returns>
        public int Median(List<int> numbers)
        {
            int numberCount = numbers.Count();
            int halfIndex = numbers.Count() / 2;
            int halfindex1 = halfIndex - 1;
            var sortedNumbers = numbers.OrderBy(n => n).ToList();
            int median = 0;
            if ((numberCount % 2) == 0)
            {
                median = ((sortedNumbers[halfIndex] + sortedNumbers[halfindex1]) / 2); ////sortedNumbers[halfindex1];/// – 1];///
            }
            else
            {
                median = sortedNumbers[halfIndex];
            }
            return median;
        }


        void bgworkerforautoscan_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            Dispatcher.BeginInvoke((Action)(() =>
            {
                bsyAutoScanTopProteinResults.IsBusy = false;
                btnGenerateSearchSummary.IsEnabled = true;
                btnGenerateSearchSummary.Content = "Generate";
                genTimer.Stop();
                DechargerVM.SearchEndTime = DateTime.Now;
                cTokenSource = null;
                bsyforAutoScan.IsIndeterminate = false;
            }), System.Windows.Threading.DispatcherPriority.Normal, null);
        }


        public List<SearchResult> blastpresultsforfasta(int start, int end)
        {
            List<SearchResult> blastpresults = new List<SearchResult>();



            return blastpresults;
        }


        private IEnumerable<SearchResult> SortSequenceSearch(IEnumerable<SearchResult> searchresults, double ParentIon)
        {
            var srhrlts = searchresults.Where(a => a.DeltaMassVersusProtein != null && a.YellowandGreenTagHits != null && a.DeltaMassVersusProtein >= 0 && a.YellowandGreenTagHits >= 6.0).ToList();
            searchresults = srhrlts.OrderByDescending(w => w.YellowandGreenTagHits).ThenByDescending(a => a.IsConfirmed).ThenByDescending(a => a.Sequence.IsValidSequence()).ThenBy(a => a.ExpectValue).ThenBy(x => Math.Abs(x.DeltaMassVersusProtein)).ThenBy(y => Math.Abs(y.Mass - ParentIon)).ThenBy(b => b.Description.ToLower().Contains("unknown") || b.Description.ToLower().Contains("uncharacterized"));  ///.ToList()

            return searchresults;
            //return searchresults.Where(a => a.DeltaMassVersusProtein != null && a.YellowandGreenTagHits != null && a.DeltaMassVersusProtein >= 0 && a.YellowandGreenTagHits >= 6.0).OrderByDescending(w => w.YellowandGreenTagHits).ThenByDescending(a => a.IsConfirmed).ThenByDescending(a => a.Sequence.IsValidSequence()).ThenBy(a => a.ExpectValue).ThenBy(x => Math.Abs(x.DeltaMassVersusProtein)).ThenBy(y => Math.Abs(y.Mass - ParentIon)).ThenBy(b => b.Description.ToLower().Contains("unknown") || b.Description.ToLower().Contains("uncharacterized"));  ///.ToList()
            //return searchresults.Where(a => a.DeltaMassVersusProtein >= 0).OrderByDescending(w => w.TagHits).ThenByDescending(a => a.Sequence.IsValidSequence()).ThenBy(a => a.ExpectValue).ThenBy(x => Math.Abs(x.DeltaMassVersusProtein)).ThenBy(y => Math.Abs(y.Mass - ParentIon)).ThenBy(b => b.Description.ToLower().Contains("unknown") || b.Description.ToLower().Contains("uncharacterized"));  ///.ToList()
        }

        private IEnumerable<SearchResult> SortSequenceSearchforFilter(IEnumerable<SearchResult> searchresults, double ParentIon)
        {
            return searchresults.OrderByDescending(w => w.YellowandGreenTagHits).ThenByDescending(a => a.IsConfirmed).ThenByDescending(a => a.Sequence.IsValidSequence()).ThenBy(a => a.ExpectValue).ThenBy(x => Math.Abs(x.DeltaMassVersusProtein)).ThenBy(y => Math.Abs(y.Mass - ParentIon)).ThenBy(b => b.Description.ToLower().Contains("unknown") || b.Description.ToLower().Contains("uncharacterized"));  ///.ToList()
            //return searchresults.Where(a => a.DeltaMassVersusProtein >= 0).OrderByDescending(w => w.TagHits).ThenByDescending(a => a.Sequence.IsValidSequence()).ThenBy(a => a.ExpectValue).ThenBy(x => Math.Abs(x.DeltaMassVersusProtein)).ThenBy(y => Math.Abs(y.Mass - ParentIon)).ThenBy(b => b.Description.ToLower().Contains("unknown") || b.Description.ToLower().Contains("uncharacterized"));  ///.ToList()
        }

        private SearchResult SortSequenceSearchforList(List<SearchResult> searchresults, double ParentIon)
        {
            //if (searchresults.Where(a => a.DeltaMassVersusProtein >= 0 && a.YellowandGreenTagHits > 2.0).OrderByDescending(w => w.YellowandGreenTagHits).ThenByDescending(a => a.IsConfirmed).ThenByDescending(a => a.Sequence.IsValidSequence()).ThenBy(a => a.ExpectValue).ThenBy(x => Math.Abs(x.DeltaMassVersusProtein)).ThenBy(y => Math.Abs(y.Mass - ParentIon)).ThenBy(b => b.Description.ToLower().Contains("unknown") || b.Description.ToLower().Contains("uncharacterized")).Any())
            //{

            //searchresults = searchresults.Where(a => a.DeltaMassVersusProtein >= 0 && a.YellowandGreenTagHits > 2.0).ToList();

            //searchresults = searchresults.OrderByDescending(a => a.YellowandGreenTagHits).ToList();

            //searchresults = searchresults.OrderByDescending(a => a.IsConfirmed).ToList();

            //searchresults = searchresults.OrderByDescending(a => a.Sequence.IsValidSequence()).ToList();

            //searchresults = searchresults.OrderBy(a => a.ExpectValue).ToList();

            //searchresults = searchresults.OrderBy((x => Math.Abs(x.DeltaMassVersusProtein))).ToList();

            //searchresults = searchresults.OrderBy((y => Math.Abs(y.Mass - ParentIon))).ToList();

            //return searchresults.First();

            // Setting the default value to 1 by using DefaultIfEmpty() in the query.
            // int firstMonth2 = months.DefaultIfEmpty(1).First(); 

            return searchresults.Where(a => a.DeltaMassVersusProtein >= 0 && a.YellowandGreenTagHits > 2.0).OrderByDescending(w => w.YellowandGreenTagHits).ThenByDescending(a => a.IsConfirmed).ThenByDescending(a => a.Sequence.IsValidSequence()).ThenBy(a => a.ExpectValue).ThenBy(x => Math.Abs(x.DeltaMassVersusProtein)).ThenBy(y => Math.Abs(y.Mass - ParentIon)).DefaultIfEmpty(new SearchResult()).First();

            //if (searchresults.Where(a => a.DeltaMassVersusProtein >= 0 && a.YellowandGreenTagHits > 2.0).OrderByDescending(w => w.YellowandGreenTagHits).ThenByDescending(a => a.IsConfirmed).ThenByDescending(a => a.Sequence.IsValidSequence()).ThenBy(a => a.ExpectValue).ThenBy(x => Math.Abs(x.DeltaMassVersusProtein)).ThenBy(y => Math.Abs(y.Mass - ParentIon)).Any())
            //{

            //    //searchresults.Where(a => a.DeltaMassVersusProtein >= 0 && a.YellowandGreenTagHits > 2.0).OrderByDescending(w => w.YellowandGreenTagHits).ThenByDescending(a => a.IsConfirmed).ThenByDescending(a => a.Sequence.IsValidSequence()).ThenBy(a => a.ExpectValue).ThenBy(x => Math.Abs(x.DeltaMassVersusProtein)).ThenBy(y => Math.Abs(y.Mass - ParentIon)).First();  ///.ToList()
            //    return searchresults.Where(a => a.DeltaMassVersusProtein >= 0 && a.YellowandGreenTagHits > 2.0).OrderByDescending(w => w.YellowandGreenTagHits).ThenByDescending(a => a.IsConfirmed).ThenByDescending(a => a.Sequence.IsValidSequence()).ThenBy(a => a.ExpectValue).ThenBy(x => Math.Abs(x.DeltaMassVersusProtein)).ThenBy(y => Math.Abs(y.Mass - ParentIon)).First();  ///.ToList()
            //}
            //else
            //{
            //    return new SequenceSearch();
            //}
            //return searchresults.Where(a => a.DeltaMassVersusProtein >= 0 && a.YellowandGreenTagHits > 2.0).OrderByDescending(w => w.YellowandGreenTagHits).ThenByDescending(a => a.IsConfirmed).ThenByDescending(a => a.Sequence.IsValidSequence()).ThenBy(a => a.ExpectValue).ThenBy(x => Math.Abs(x.DeltaMassVersusProtein)).ThenBy(y => Math.Abs(y.Mass - ParentIon)).ThenBy(b => b.Description.ToLower().Contains("unknown") || b.Description.ToLower().Contains("uncharacterized")).First();  ///.ToList()
            //}
            //else
            //{
            //    return new SequenceSearch();
            //}
            //return searchresults.Where(a => a.DeltaMassVersusProtein >= 0).OrderByDescending(w => w.TagHits).ThenByDescending(a => a.Sequence.IsValidSequence()).ThenBy(a => a.ExpectValue).ThenBy(x => Math.Abs(x.DeltaMassVersusProtein)).ThenBy(y => Math.Abs(y.Mass - ParentIon)).ThenBy(b => b.Description.ToLower().Contains("unknown") || b.Description.ToLower().Contains("uncharacterized"));  ///.ToList()
        }


        private void OnTargetUpdated(object sender, DataTransferEventArgs e)
        {
            if (sender is TextBlock && (sender as TextBlock).Tag != null && (sender as TextBlock).Tag is List<MatchStartEnds>)
            {
                var tb = sender as TextBlock;
                if (string.IsNullOrWhiteSpace(tb.Text)) return;
                tb.Inlines.ApplyHighlight(tb.Text, tb.Tag as List<MatchStartEnds>);
            }
        }

        private void TextBlock_TargetUpdated(object sender, DataTransferEventArgs e)
        {
            // This event handler adds the colorful highlighting to the blast tag in the results table

            if (sender != null && sender is TextBlock && ((TextBlock)sender).DataContext is SearchResult)
            {
                var searchResult = ((TextBlock)sender).DataContext as SearchResult;

                if (searchResult.IsBlastResult == false) return;  // do nothing if it's not a blast search

                var tb = sender as TextBlock;

                tb.Inlines.ApplyBlastHighlight(searchResult);
            }
        }

        private void TextBlock_TargetUpdatedNew(object sender, DataTransferEventArgs e)
        {
            if (sender is TextBlock && (sender as TextBlock).Tag != null && (sender as TextBlock).Tag is List<MatchStartEnds>)
            {
                var tb = sender as TextBlock;
                if (string.IsNullOrWhiteSpace(tb.Text)) return;
                tb.Inlines.ApplyBlastHighlight(tb.Text, tb.Tag as List<MatchStartEnds>);
            }
        }

        private void mnuitemImprtclpbrd_Click(object sender, RoutedEventArgs e)
        {

        }

        OpenFileDialog openFasta = new OpenFileDialog();


        /// <summary>
        /// Importing the FASTA from a file selected
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void mnuitemImprtfrmfile_Click(object sender, RoutedEventArgs e)
        {
            List<FASTA> lstFasta = new List<FASTA>();
            openFasta.AddExtension = true;
            openFasta.Filter = "FASTA files (*.FASTA or *.FSA)|*.FASTA;*.FSA|All files (*.*)|*.*";
            openFasta.Title = "Choose your file";

            bool? userClickedOK = openFasta.ShowDialog();

            if (userClickedOK == true)
            {
                ImportFastaFileAsync(openFasta.FileName);
            }
        }

        private void ImportFastaFileAsync(string filepath)
        {
            // Create a background worker to show the busy indicator
            var bgimportfromfile = new BackgroundWorker() { WorkerReportsProgress = true, WorkerSupportsCancellation = true };
            bgimportfromfile.DoWork += bgimportfromfile_DoWork;
            bgimportfromfile.ProgressChanged += bgimportfromfile_ProgressChanged;
            bgimportfromfile.RunWorkerCompleted += bgimportfromfile_RunWorkerCompleted;

            fileLoadWorkers.Add(bgimportfromfile);

            bgimportfromfile.RunWorkerAsync(filepath);
        }

        void bgimportfromfile_ProgressChanged(object sender, ProgressChangedEventArgs e)
        {
            bsySearchDatabase.IsBusy = true;

            this.FileBusyProgressValue = e.ProgressPercentage;
            this.FileBusyProgressText = "Loading File into local Database";
            this.IsFileBusyProgressIndeterminate = false;
            this.ShowStopButton = System.Windows.Visibility.Visible;
        }

        class BlastpTags
        {
            public string ScanNumber { get; set; }

            public IEnumerable<FindSequenceTags.SequenceTag> Sequencetags { get; set; }

            public List<String> AlltheSequencetags { get; set; }

            public List<Cluster> CurrentIons { get; set; }

            public double ParentMass { get; set; }

            public List<string> PairMatch { get; set; }

            public double Mass { get; set; }

            public int ParentZ { get; set; }

            public List<SpectrumInfo> allspectrums { get; set; }

            public string Sequence { get; set; }

        }


        /// <summary>
        /// When the file is loaded the busy indicator is turned off
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void bgimportfromfile_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            Debug.Print("file import complete.  Cancelled? " + e.Cancelled);

            bsySearchDatabase.IsBusy = false;
            this.FileBusyProgressValue = 100;

            if (e.Result == null) return;

            if (e.Result is Exception) System.Windows.MessageBox.Show("Error parsing File: " + (e.Result as Exception).Message);

            //Dispatcher.Invoke(new Action(() =>
            //{
            //    btnGenerateSearchSummary.IsEnabled = true;
            //}));

            lock (this)  // this lock prevents possible contention when two imports end simultaneously.
            {
                if (e.Result is string)
                {
                    // processed file name should be in the Result Property
                    FASTAFileName += "\n" + (e.Result as String);  // this is used for the Tooltip on the database/file button                    
                    //btnSequenceSearchSource.ToolTip = FASTAFileName.Trim(); //.Trim(' ', '\t', '\n');
                }

                if (fileLoadWorkers.Any(w => w.IsBusy)) return; // to avoid a deadlock, only the last thread will get past this line

                var uniqspecies = BoundSequences.Where(s => s != null).Select(a => a.Species).Distinct().OrderBy(a => a).ToList();
                //fastasequences = BoundSequences.ToList();
                //List<string> allspecies = new List<string>();
                //allspecies = App.DistinctSpecies.Where(a => a.IsSelected == true).Select(a => a.species).ToList();
                SearchStoryBoard();
                btnGenerateSearchSummary.IsEnabled = true;
                //if (!returnfunction)
                {
                    ComboBox cmb = FindVisualChildByName<ComboBox>(dtgrdSearchSequence, "cmbSpecies");
                    if (cmb != null)
                    {
                        cmb.Items.Clear();
                        cmb.Items.Add("All Species");
                        foreach (var species in uniqspecies)
                        {
                            cmb.Items.Add(species);
                        }
                        cmb.SelectedIndex = 0;
                    }
                    txtSearchbox.Text = "";
                    if (CurrentSpectrum.ParentIon == null)
                    {
                        dtgrdSStxtDeltaMass.Visibility = System.Windows.Visibility.Collapsed;
                        dtgrdSStxtMass.Visibility = System.Windows.Visibility.Visible;
                    }
                    else
                    {
                        dtgrdSStxtDeltaMass.Visibility = System.Windows.Visibility.Visible;
                        dtgrdSStxtMass.Visibility = System.Windows.Visibility.Collapsed;
                    }
                }

                string Applicationname = Assembly.GetExecutingAssembly().GetName().Name;
                DechargerVM.UseFasta = true;
                imgSequenceSearchSource.Tag = "File";
                //imgSequenceSearchSource.Width = 80;
                BitmapImage logo = new BitmapImage();
                logo.BeginInit();
                logo.UriSource = new Uri("pack://application:,,,/" + Applicationname + ";component/Icons/document_32xMD.png");
                logo.EndInit();
                imgSequenceSearchSource.Source = logo;
                lblDataSource.Text = lblFASTAFileName;
                btnSequenceSearchSource.ToolTip = FASTAFileName.Trim();

                if (Properties.Settings.Default.SearchAllSpecies == false)
                {
                    // filter proteins by the selected species
                    //fastasequences = fastasequences.Where(s => allspecies.Contains(s.Species.ToLower())).Take(100).ToList();
                }

                dtgrdSearchSequence.ItemsSource = null;  // I am setting to null here to trigger the change in the UI because the Bound Sequences does not implement NotifyPropertyChanged
                DisplayDescription();
                if (BoundSequences.Any() == false)
                {
                    imgSearchInfo.Visibility = System.Windows.Visibility.Hidden;
                    imgSearchWarning.Visibility = System.Windows.Visibility.Hidden;
                }
                else if (BoundSequences.Count > 100)
                {
                    imgSearchInfo.Visibility = System.Windows.Visibility.Hidden;
                    imgSearchWarning.Visibility = System.Windows.Visibility.Visible;
                    imgSearchWarning.ToolTip = "Displaying the first 100 sequences out of " + BoundSequences.Count + " sequences" + ((Properties.Settings.Default.SearchAllSpecies || DechargerVM.UseFasta) ? string.Empty : "\n*Species Filter Applied");
                    dtgrdSearchSequence.ItemsSource = BoundSequences.Take(100);
                    //dtgrdSearchSequence.DataContext = BoundSequences.Take(100);
                }
                else
                {
                    imgSearchWarning.Visibility = System.Windows.Visibility.Hidden;
                    imgSearchInfo.Visibility = System.Windows.Visibility.Visible;
                    imgSearchInfo.ToolTip = "Displaying all " + BoundSequences.Count + " sequences" + ((Properties.Settings.Default.SearchAllSpecies || DechargerVM.UseFasta) ? string.Empty : "\n*Species Filter Applied");
                    dtgrdSearchSequence.ItemsSource = BoundSequences;
                    //dtgrdSearchSequence.DataContext = BoundSequences;
                }
            }
        }

        /// <summary>
        /// Reading the file when the user loads the file
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void bgimportfromfile_DoWork(object sender, DoWorkEventArgs e)
        {
            string filePath = null;
            var worker = sender as BackgroundWorker;

            if ((e.Argument is string) == false)
            {
                e.Result = new ArgumentException("Argument was of the wrong type.");
                return;
            }

            Dispatcher.Invoke(new Action(() =>
            {
                btnGenerateSearchSummary.IsEnabled = false;
            }));

            lock (fileLoadWorkers)  // this lock makes it so that only one file is processed at a time to allow the progress bar to show prpperly
            {

                filePath = e.Argument as string;
                worker.ReportProgress(0);

                Debug.WriteLine("Processing File: " + filePath);


                // Open the selected file to read.
                //FileInfo fi = new FileInfo(e.Argument as string);///.File.OpenRead();
                //                                                 ///
                //long fileSize = fi.Length;

                var size = new FileInfo(filePath).Length;

                var speciesList = (from speciesTable in App.DistinctSpecies
                                   select speciesTable).ToList();

                IEnumerable<SearchResult> tempdbsequences = new List<SearchResult>();

                int position = 0;


                List<string> emptystring = new List<string>();
                emptystring.Add(string.Empty);
                using (var fStream = File.OpenText(filePath))
                {
                    string header = null;
                    string sequence = string.Empty;
                    int fastacount = App.lstFasta != null ? App.lstFasta.Count : 0;

                    App.FirstTwentyFasta = new StringBuilder();
                    if (App.lstFasta == null)
                    {
                        App.lstFasta = new List<FASTA>();
                    }
                    //char[] c = new char[1];
                    while (!fStream.EndOfStream && worker.CancellationPending == false)
                    {
                        worker.ReportProgress((int)((100 / (double)size) * (double)position), null);

                        //fStream.Read(c, 0, c.Length);
                        header = fStream.ReadLine();

                        if (fastacount < 20)
                        {
                            App.FirstTwentyFasta.AppendLine(header + "<br/>");
                        }
                        position += header.Length;

                        sequence = string.Empty;
                        //buffer.Append(c[0]);

                        //                charcterCount++;
                        //                if (charcterCount % 100000 == 0) System.Diagnostics.Debug.WriteLine("Char Count: " + charcterCount);

                        if (header[0] == '>' || sequence == string.Empty)  // using sequence == empty to bypass the > check for the first record
                        {

                            // Because some sequences have CrLf in them, we have to keep reading until we get to a read that starts with '>'
                            while (!fStream.EndOfStream && char.ConvertFromUtf32(fStream.Peek()) != ">") sequence += fStream.ReadLine();

                            sequence = sequence.Trim('*');

                            if (fastacount < 20)
                            {
                                App.FirstTwentyFasta.AppendLine(sequence + "<br/>");
                            }

                            position += sequence.Length;

                            string[] newlinestring = { "\n" }; ///Newline break to separate the sequence from the 

                            string[] stringpipe = { "|", ">", "\t", "\n" }; ///To get values for accessions, description, mass

                            //string[] sequences = Convert.ToString(header).Split(newlinestring, StringSplitOptions.None);

                            //string sequence = sequences[1]; /// Sequence


                            string accessions = header;
                            double mass = 0;
                            string annotation = header;
                            string species = string.Empty;

                            MatchCollection endTokens = Regex.Matches(header, @"\s{1}[A-Z]{2}[=]{1}[\w+\s?]+", RegexOptions.RightToLeft | RegexOptions.Compiled);

                            int annotationEnd = header.Length;

                            // Parse ending parameters
                            foreach (Match match in endTokens)
                            {
                                foreach (Capture capture in match.Captures)
                                {
                                    if (capture.Value.TrimStart().StartsWith("OS="))
                                    {
                                        // found the species!  
                                        species = capture.Value.TrimStart().Substring(3);
                                    }

                                    annotationEnd = Math.Min(capture.Index, annotationEnd);

                                    //Debug.Print("Index={0}, Value={1}", capture.Index, capture.Value);
                                }
                            }

                            if (string.IsNullOrWhiteSpace(species))
                            {

                                // Here we call Regex.Match.
                                Match match = Regex.Match(header, @"\((?<species>\w+)\)\.?$", RegexOptions.RightToLeft | RegexOptions.Compiled);

                                // Here we check the Match instance.
                                if (match.Success)
                                {
                                    // Finally, we get the Group value and display it.
                                    species = match.Groups[1].Value;
                                    annotationEnd = Math.Min(match.Groups[1].Index - 1, annotationEnd);
                                }
                                else
                                {
                                    // Find "Bos" in ">gi|uniP62990|rs|NP_001069831.1|sp|P62990|ubiquitin and ribosomal protein|mass|8559|gs||Bos"

                                    // Here we call Regex.Match.
                                    Match match2 = Regex.Match(header, @"gs\|{1}.*\|?(?<species>\w+)$", RegexOptions.RightToLeft | RegexOptions.Compiled);

                                    // Here we check the Match instance.
                                    if (match2.Success)
                                    {
                                        // Finally, we get the Group value and display it.
                                        species = match2.Groups[1].Value;
                                        annotationEnd = Math.Min(match2.Groups[0].Index, annotationEnd);
                                    }
                                    else
                                    {
                                        // failed
                                        species = "Unspecified";
                                    }
                                }

                                // try to parse species from the end of the string...   
                                //species = stsequence.Last().Trim();
                            }

                            //string[] stsequence = accessions.Split(stringpipe, StringSplitOptions.RemoveEmptyEntries);


                            MatchCollection accessionMatches = Regex.Matches(accessions.Substring(0, annotationEnd), @"[>\|][a-z]{2}\|[^\|\s]{0,19}", RegexOptions.Compiled);

                            int annotationStart = 0;

                            if (accessionMatches.Count > 0)
                            {
                                accessions = string.Empty;
                            }
                            else
                            {
                                annotationStart = header.Substring(0, Math.Max(0, header.IndexOf(' '))).LastIndexOf('|') + 1;
                                accessions = header.Substring(0, annotationStart).Trim('>', '|');
                            }

                            // find accessions
                            foreach (Match match in accessionMatches)
                            {
                                foreach (Capture capture in match.Captures)
                                {

                                    //{
                                    // found an accession!  
                                    if (capture.Length > 4) accessions += capture.Value.Trim('>', '|') + " ";
                                    //}
                                    annotationStart = Math.Max(capture.Index + capture.Length + 1, annotationStart);
                                    //annotationEnd = Math.Min(capture.Index, annotationEnd);

                                    //Debug.Print("Index={0}, Value={1}", capture.Index, capture.Value);
                                }
                            }

                            // standardize source names on IPI notation because it is more readable and easily parsed
                            accessions = accessions.Replace("ref", "REFSEQ");
                            accessions = accessions.Replace("gi", "GI");
                            accessions = accessions.Replace("sp", "SWISS-PROT");
                            accessions = accessions.Replace("rs", "RS");
                            accessions = accessions.Replace("uni", ""); // Not displaying the uni part

                            accessions = accessions.Replace("|", ":");  // Replace | with :

                            int accessionEnd = header.Length;

                            var annotationCandidate = header.Substring(annotationStart, annotationEnd - annotationStart);

                            if (annotationCandidate.Contains('|'))
                                annotationEnd = Math.Min(annotationEnd, header.IndexOf('|', annotationStart + 1));

                            if (annotationEnd - annotationStart > 2)
                            {
                                annotation = header.Substring(annotationStart, annotationEnd - annotationStart).Trim(' ', '>');
                                accessionEnd = annotationStart;
                                //accessions = header.Substring(0, accessionEnd).Trim(' ', '>', '|');
                            }
                            else
                            {
                                annotation = annotation.Trim(' ', '>');
                            }

                            if (mass == 0) mass = sequencelength(sequence);  // calculate mass
                            if (string.IsNullOrWhiteSpace(accessions) || accessions == header) accessions = "LOCAL:" + LocalAccessionIndex++;

                            // Assigning new FASTA value
                            string guid = Convert.ToString(Guid.NewGuid());

                            App.lstFasta.Add(new FASTA
                            {
                                Species = species,
                                Accession = accessions,
                                Sequence = sequence,
                                Mass = mass,
                                Description = annotation,
                                SequenceID = guid
                            });


                            BoundSequences.Add(new SearchResult
                            {
                                Accession = accessions,
                                Description = annotation,
                                Sequence = sequence, //.Replace("I", "L"),
                                //Mass = mass,
                                Species = species,
                                PairMatch = emptystring,
                                //Allthesequencetags = emptystring,
                                AllsqsTags = new List<FindSequenceTags.SequenceTag>(),
                                CurntIons = new List<Cluster>(),
                                //DeltaMass = 0,
                                Notagsforhighlight = true,
                                SequenceID = guid
                            });

                            stringbuilderforBlastp.Append(">" + guid + "\n" + sequence + "\n");

                            ///Clearing the buffer which is later assigned a new string for fasta sequence
                            //buffer = new StringBuilder();
                        }
                        fastacount++;
                    }

                    BackgroundWorker bgworkerforcreatingindexeddatabase = new BackgroundWorker();
                    bgworkerforcreatingindexeddatabase.DoWork += bgworkerforcreatingindexeddatabase_DoWork;
                    bgworkerforcreatingindexeddatabase.RunWorkerCompleted += bgworkerforcreatingindexeddatabase_RunWorkerCompleted;
                    bgworkerforcreatingindexeddatabase.RunWorkerAsync(stringbuilderforBlastp);

                    DechargerVM.UseFasta = true;

                    if (worker.CancellationPending)
                    {
                        //e.Cancel = true;
                        Debug.Print("Cancelled worker for file: " + filePath);
                    }

                    e.Result = System.IO.Path.GetFileName(filePath);  // this is used for the Tooltip on the database/file button

                }
            }
        }

        bool isnotconfirmedornot = false;  // TODO: This variable name is confusing to me...

        private void dtgridSearchResults_MouseDoubleClick(object sender, MouseButtonEventArgs e)
        {
            //try
            //{
            string filename = App.FileName;
            fromautoscan = true;

            // validate that there is a search result that was double clicked...
            if (sender == null || sender is DataGrid == false || (((DataGrid)sender).CurrentItem) == null || (((DataGrid)sender).CurrentItem) is SearchResult == false) return;

            var sr = (sender as DataGrid).CurrentItem as SearchResult;

            parentmassmerge = true;

            if ((sr.Description == string.Empty) || (sr.Accession == string.Empty)) return;


            using (new WaitCursor())
            {
                if ((sr.IsAutoScanIdentified == false))
                {
                    isnotconfirmedornot = true;
                }
                //if ((item as SequenceSearch).PairMatch != null)
                if (sr.AnchorTag != null)
                {
                    SequenceforAutoScan = sr.AnchorTag.Sequence;
                    //SequenceforAutoScan = (item as SequenceSearch).PairMatch[0];
                }
                else if (sr.Allthesequencetags.Where(a => (a == (sr.TagForTopProtein))).Any())
                {
                    //if ((item as SequenceSearch).PairMatch != null)
                    //    SequenceforAutoScan = (item as SequenceSearch).PairMatch[0];
                    if (sr.AnchorTag != null)
                    {
                        SequenceforAutoScan = sr.AnchorTag.Sequence;
                    }
                    else
                        SequenceforAutoScan = sr.TagForTopProtein;
                }
                else if (sr.Allthesequencetags.Where(a => (a == ReverseString.Reverse(sr.TagForTopProtein))).Any())
                {
                    SequenceforAutoScan = ReverseString.Reverse(sr.TagForTopProtein);
                }

                if (MainPointProvider == null)  //(filename == null)
                {
                    SetActivationTypes(sr);
                    DisplayNewSpectrumNoFile(sr);
                }
                else if (sr.ScanNumbers.Contains(","))
                {
                    DisplayNewSpectrum(sr.allspectrums); //.Where(s => sr.S s.ScanNumber );
                    fromautoscan = true;
                }
                else
                {
                    var rt = MainPointProvider.RetentionTime(Convert.ToInt32(sr.ScanNumbers));
                    fromautoscan = true;
                    DisplayNewSpectrum(rt);
                }
            }


        }

        private void mnuAutoMerge_Click(object sender, RoutedEventArgs e)
        {
            List<SpectrumInfo> allspectra = new List<SpectrumInfo>();
            fromautoscan = true;
            foreach (SearchResult selecteditem in (dtgridSearchResults.SelectedItems))
            {
                allspectra.AddRange(selecteditem.allspectrums);
            }

            DisplayNewSpectrum(allspectra);

        }

        //private void dtgridDeNovoSearchResults_MouseDoubleClick(object sender, MouseButtonEventArgs e)
        //{

        //    var cells = dtgridSearchResultsDeNovo.SelectedItems;
        //    parentmassmerge = true;

        //    var mergeList = new List<SearchResult>();

        //    if (dtgridSearchResultsDeNovo.SelectedItem != null && dtgridSearchResultsDeNovo.SelectedItem is SearchResult)
        //    {
        //        var rt = MainPointProvider.RetentionTime((dtgridSearchResultsDeNovo.SelectedItem as SearchResult).Scan);

        //        using (new WaitCursor())
        //        {
        //            DisplayNewSpectrum(rt);
        //        }
        //    }
        //}

        private void btnSequenceSearchSource_Click(object sender, RoutedEventArgs e)
        {
            string Applicationname = Assembly.GetExecutingAssembly().GetName().Name;

            if (App.lstFasta == null || App.lstFasta.Any() == false) return;

            if (Convert.ToString(imgSequenceSearchSource.Tag) == "Database")
            {
                DechargerVM.UseFasta = true;
                imgSequenceSearchSource.Tag = "File";
                //imgSequenceSearchSource.Width = 80;
                BitmapImage logo = new BitmapImage();
                logo.BeginInit();
                logo.UriSource = new Uri("pack://application:,,,/" + Applicationname + ";component/Icons/document_32xMD.png");
                logo.EndInit();
                imgSequenceSearchSource.Source = logo;
                //btnSequenceSearchSource.ToolTip = FASTAFileName.Trim();
                lblDataSource.Text = lblFASTAFileName;
                btnSequenceSearchSource.ToolTip = FASTAFileName.Trim();

            }
            else
            {
                if (!NetworkInterface.GetIsNetworkAvailable())
                {
                    return;
                }
                DechargerVM.UseFasta = false;
                imgSequenceSearchSource.Tag = "Database";
                //imgSequenceSearchSource.Width = 80;
                BitmapImage logo = new BitmapImage();
                logo.BeginInit();
                logo.UriSource = new Uri("pack://application:,,,/" + Applicationname + ";component/Icons/database_32xMD.png");
                logo.EndInit();
                imgSequenceSearchSource.Source = logo;
                //btnSequenceSearchSource.ToolTip = "Database";
                lblDataSource.Text = "Database";
                btnSequenceSearchSource.ToolTip = db.Database;
            }

            lblDataSource.Visibility = System.Windows.Visibility.Visible;
        }

        private void bsyIndicatorStop_Click(object sender, RoutedEventArgs e)
        {
            foreach (var aWorker in fileLoadWorkers)
            {
                aWorker.CancelAsync();
            }
        }



        private void CopySequence_Click(object sender, RoutedEventArgs e)
        {
            // Based on http://stackoverflow.com/questions/16822956/getting-wpf-data-grid-context-menu-click-row

            try
            {
                //Get the clicked MenuItem
                var menuItem = (MenuItem)sender;

                //Get the ContextMenu to which the menuItem belongs
                var contextMenu = (ContextMenu)menuItem.Parent;

                //Find the placementTarget
                var item = (DataGrid)contextMenu.PlacementTarget;

                //Get the underlying item, that you cast to your object that is bound
                //to the DataGrid (and has subject and state as property)
                //var toDeleteFromBindedList = item.SelectedCells[0].Item;

                Clipboard.SetText((item.SelectedCells.First().Item as SearchResult).Sequence);
            }
            catch { }
        }

        private void CopyRow_Click(object sender, RoutedEventArgs e)
        {
            // Based on http://stackoverflow.com/questions/16822956/getting-wpf-data-grid-context-menu-click-row


            //Get the clicked MenuItem
            var menuItem = (MenuItem)sender;

            //Get the ContextMenu to which the menuItem belongs
            var contextMenu = (ContextMenu)menuItem.Parent;

            //Find the placementTarget
            var item = (DataGrid)contextMenu.PlacementTarget;

            //Get the underlying item, that you cast to your object that is bound
            //to the DataGrid (and has subject and state as property)
            var toDeleteFromBindedList = item.SelectedCells[0].Item;
        }

        private void imgSearchInfo_MouseEnter(object sender, MouseEventArgs e)
        {
            imgSearchInfo.Opacity = 0.9;
            imgSearchWarning.Opacity = 0.9;
        }

        private void imgSearchInfo_MouseLeave(object sender, MouseEventArgs e)
        {
            imgSearchInfo.Opacity = 0.5;
            imgSearchWarning.Opacity = 0.65;
        }

        bool doneautoscan = false;


        void EmailErrorMessage()
        {
            System.Windows.MessageBox.Show("Can't email.", "No network access.", MessageBoxButton.OK, MessageBoxImage.Warning);
        }

        /// <summary>
        /// Copying all the results with formatting
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void mnuRichTextCopy_Click(object sender, RoutedEventArgs e)
        {
            GenerateHTML.copyreport(GenerateSearchResults());
            //if (publicresults.Count > 0)
            //{
            //    GenerateHTML.copyreport(GenerateSequenceSearchList());
            //    //GenerateHTML.copyreport(publicresults.ToList());
            //}
        }


        //List<SequenceSearch> GetAutoScanResults()
        //{
        //    if 
        //}

        /// <summary>
        /// Copy the sequence with formatting
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void mnuCopySequence_Click(object sender, RoutedEventArgs e)
        {
            if (dtgridSearchResults.SelectedItem is SearchResult && (SearchResult)dtgridSearchResults.SelectedItem != null)
            {
                GenerateHTML.copyasequence((SearchResult)dtgridSearchResults.SelectedItem);
            }
        }

        private void mnuCopySequence1_Click(object sender, RoutedEventArgs e)
        {
            if (dtgrdSearchSequence.SelectedItem is SearchResult && (SearchResult)dtgrdSearchSequence.SelectedItem != null)
            {
                GenerateHTML.copyasequence((SearchResult)dtgrdSearchSequence.SelectedItem);
            }
        }

        /// <summary>
        /// Copy the entire protein results with formatting
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void mnuCopyProtein_Click(object sender, RoutedEventArgs e)
        {
            if (dtgridSearchResults.SelectedItem is SearchResult && (SearchResult)dtgridSearchResults.SelectedItem != null)
            {
                GenerateHTML.copyaprotein((SearchResult)dtgridSearchResults.SelectedItem);
            }
        }



        /// <summary>
        /// Copy the accession to clipboard
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void mnuCopyAccession_Click(object sender, RoutedEventArgs e)
        {
            if (dtgridSearchResults.SelectedItem is SearchResult && (SearchResult)dtgridSearchResults.SelectedItem != null)
            {
                string accession = ((SearchResult)dtgridSearchResults.SelectedItem).Accession.ToUpper();
                FindAccessions.CopyAccessionToClipBoard(accession);
            }
        }

        /// <summary>
        /// Open a link for the searched Accession in the UniProt database
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void mnuFindinUniprot_Click(object sender, RoutedEventArgs e)
        {
            if (dtgridSearchResults.SelectedItem is SearchResult && (SearchResult)dtgridSearchResults.SelectedItem != null)
            {
                string accession = ((SearchResult)dtgridSearchResults.SelectedItem).Accession.ToUpper();
                FindAccessions.FindAccessioninUniProt(accession);
            }
        }

        private void mnuCopyHeader_Click(object sender, RoutedEventArgs e)
        {
            if (dtgridSearchResults.SelectedItem is SearchResult && (SearchResult)dtgridSearchResults.SelectedItem != null)
            {
                GenerateHTML.copyHeader();
            }
        }

        bool openlinkonce = false;

        /// <summary>
        /// Open an accession when the user clicks the description of the datagrid.
        /// Using the information from the webpage below for a click event
        /// http://stackoverflow.com/questions/5764951/using-wpf-datagridhyperlinkcolumn-items-to-open-windows-explorer-and-open-files
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void DG_Hyperlink_Click(object sender, RoutedEventArgs e)
        {
            if (dtgridSearchResults.SelectedItem is SearchResult && (SearchResult)dtgridSearchResults.SelectedItem != null && !openlinkonce)
            {
                string accession = ((SearchResult)dtgridSearchResults.SelectedItem).Accession.ToUpper();
                FindAccessions.FindAccessioninUniProt(accession);
            }
            openlinkonce = !openlinkonce;
        }

        private void DG_Hyperlink_Click1(object sender, RoutedEventArgs e)
        {
            if (dtgrdSearchSequence.SelectedItem is SearchResult && (SearchResult)dtgrdSearchSequence.SelectedItem != null && !openlinkonce)
            {
                string accession = ((SearchResult)dtgrdSearchSequence.SelectedItem).Accession.ToUpper();
                FindAccessions.FindAccessioninUniProt(accession);
            }
            openlinkonce = !openlinkonce;
        }

        private void Button_Click(object sender, RoutedEventArgs e)
        {
            GenerateMSAlignData.GenerateFileforMSAlignData(MainPointProvider, MainPointProvider.Filename);
            //Debug.Print(MainPointProvider.ToMSAlignString());.ToMSAlignString()
        }

        private void mnuRichTextCopy1_Click(object sender, RoutedEventArgs e)
        {
            if (dtgrdSearchSequence.ItemsSource is List<SearchResult>)
            {
                var allthevalues = dtgrdSearchSequence.ItemsSource as List<SearchResult>;
                if (allthevalues.Count > 0)
                {
                    GenerateHTML.copyreport(allthevalues);
                }
            }
        }

        private void mnuCopyProtein1_Click(object sender, RoutedEventArgs e)
        {
            if (dtgrdSearchSequence.SelectedItem is SearchResult && (SearchResult)dtgrdSearchSequence.SelectedItem != null)
            {
                GenerateHTML.copyaprotein((SearchResult)dtgrdSearchSequence.SelectedItem);
            }
        }

        private void mnuCopyAccession1_Click(object sender, RoutedEventArgs e)
        {
            if (dtgrdSearchSequence.SelectedItem is SearchResult && (SearchResult)dtgrdSearchSequence.SelectedItem != null)
            {
                string accession = ((SearchResult)dtgrdSearchSequence.SelectedItem).Accession.ToUpper();
                FindAccessions.CopyAccessionToClipBoard(accession);
            }
        }

        private void mnuFindinUniprot1_Click(object sender, RoutedEventArgs e)
        {
            if (dtgrdSearchSequence.SelectedItem is SearchResult && (SearchResult)dtgrdSearchSequence.SelectedItem != null)
            {
                string accession = ((SearchResult)dtgrdSearchSequence.SelectedItem).Accession.ToUpper();
                FindAccessions.FindAccessioninUniProt(accession);
            }
        }

        private void btnSaveasPDF_Click(object sender, RoutedEventArgs e)
        {
            Window notesforpdf = new Window();
            notesforpdf.Height = 340;
            notesforpdf.Width = 580;
            notesforpdf.Owner = this;
            notesforpdf.ResizeMode = ResizeMode.NoResize;
            notesforpdf.Content = new NotesForPDF(publicresults, "Minutes: " + lblRunTime.Content);
            notesforpdf.Title = "Notes";
            notesforpdf.WindowStartupLocation = System.Windows.WindowStartupLocation.CenterOwner;
            notesforpdf.Activate();
            notesforpdf.ShowDialog();

            //NotesForPDF(publicresults, filename, "Minutes: " + lblRunTime.Content);
            //SaveFileDialog Savelocation = new SaveFileDialog();
            //Savelocation.DefaultExt = ".pdf";A
            //Savelocation.Filter = "PDF (.pdf)|*.pdf";
            //bool? result = Savelocation.ShowDialog();
            //if (result == true)
            //{
            //    //System.IO.File.WriteAllText(Savelocation.FileName);
            //    //string filename = Savelocation.FileName;
            //    string filename = "\"" + Savelocation.FileName;    ///string.Join("_", Savelocation.FileName.Split(' '));
            //    GenerateHTML.SaveaPDF(publicresults, filename, "Minutes: " + lblRunTime.Content); // Savelocation.FileName); Convert.ToString(DateTime.Now.Subtract(genTime).TotalMinutes) + " Seconds: " + Convert.ToString(DateTime.Now.Subtract(genTime).Seconds)
            //}

            //GenerateHTML.SaveaPDF(publicresults,)
        }

        //private void dtgridsequences_MouseLeftButtonUp(object sender, MouseButtonEventArgs e)
        //{

        //}

        private void ClearAminoAcids_Click(object sender, RoutedEventArgs e)
        {
            ClearAminoAcids_Click();
        }



        private void mnuitemSetParentMass_Click(object sender, RoutedEventArgs e)
        {
            if (App.ScanNumber == null)
            {
                btnFindSequenceinSpectrum.IsOpen = false;
                return;
            }

            SetManualParentMass();
        }

        public void SetAxis(int axismax, int axismin)
        {
            Dispatcher.Invoke((Action)(() =>
                {
                    xaxisErrorPlot.AxisMinimum = axismin;
                    xaxisErrorPlot.AxisMaximum = axismax;
                }));
        }

        private void mnuProteinValidateSequence_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                if (dtgrdSearchSequence.SelectedItem is SearchResult && (SearchResult)dtgrdSearchSequence.SelectedItem != null && ((SearchResult)dtgrdSearchSequence.SelectedItem).CoveredSequence != null && ((SearchResult)dtgrdSearchSequence.SelectedItem).CoveredSequence != "")
                {
                    fromautoscantab = false;
                    Dictionary<double, double> crntmnmonomasses = new Dictionary<double, double>();
                    for (int i = 0; i < CurrentMonoMasses.Count; i++)
                    {
                        crntmnmonomasses.Add(Convert.ToDouble(CurrentMonoMasses[i].XValue), CurrentMonoMasses[i].YValue);
                    }
                    List<PossibleModSequences.PossibleMods> psdms = new List<PossibleModSequences.PossibleMods>();
                    btnshowmorevalidations.Visibility = System.Windows.Visibility.Hidden;
                    if (ParentMass == 0)
                    {
                        return;
                    }

                    if (crntmnmonomasses != null && crntmnmonomasses.Count == 0)
                    {
                        return;
                    }
                    string SequenceText = PossibleModSequences.ValidateProteinSequence(dtgrdSearchSequence.SelectedItem as SearchResult, AminoAcidHelpers.AminoAcids, ParentMass, crntmnmonomasses, Properties.Settings.Default.HaveKnownMods, ref psdms);
                    btnshowmorevalidations.Visibility = System.Windows.Visibility.Hidden;
                    lblExperimentalMass.Text = ParentMass.ToString(MassValueFormat); // Convert.ToString(Math.Round(ParentMass, 4));
                    tbValidate.Focus();
                    BindtoValidatedSequences(psdms);
                    BindProteintSequence(SequenceText);
                    CalculateTheoreticalMass(SequenceText);
                    double bandyionpercent = 0;
                    BindBandYIons(SequenceText, ref bandyionpercent);

                    CurrentValidatedSequence = dtgrdSearchSequence.SelectedItem as SearchResult;

                    txtbxSequenceScanNumbers.Text = (dtgrdSearchSequence.SelectedItem as SearchResult).ScanNumbers;
                    txtbxSequenceParentZs.Text = (dtgrdSearchSequence.SelectedItem as SearchResult).Parentz_s;
                    txtbxSequenceSet.Text = (dtgrdSearchSequence.SelectedItem as SearchResult).Sequence;

                    CurrentValidatedSequence.ValidatedSequence = SequenceText;
                    CurrentValidatedSequence.BandYIonPercent = bandyionpercent;
                }
            }
            catch (Exception ex)
            {
                string stacktrace = ex.StackTrace;
                stacktrace += (dtgrdSearchSequence.SelectedItem is SearchResult && (SearchResult)dtgrdSearchSequence.SelectedItem != null) ?
                              ("\nSequence Tag: " + (dtgrdSearchSequence.SelectedItem as SearchResult).Sequence + "\t Scan Number: " + scannumbers + "\t Description: " + (dtgrdSearchSequence.SelectedItem as SearchResult).Description) :
                              "";

                App.Laststacktrace = stacktrace;
                Action throwException = () => { throw ex; };
                Dispatcher.CurrentDispatcher.BeginInvoke(throwException);
            }
        }

        void BindtoValidatedSequences(List<PossibleModSequences.PossibleMods> lstpdms)
        {
            dtgrdValidateSequences.ItemsSource = null;
            List<PossibleModSequences.PossibleMods> pdms = new List<PossibleModSequences.PossibleMods>();

            if (lstpdms.Count != 0)
            {
                for (int i = 0; i < lstpdms.Count; i++)
                {
                    pdms.Add(lstpdms[i]);
                }
                Dispatcher.Invoke((Action)(() =>
                {
                    btnshowmorevalidations.Visibility = System.Windows.Visibility.Visible;
                    dtgrdValidateSequences.ItemsSource = pdms.ToList();
                    dtgrdValidateSequences.SelectedIndex = 0;
                }));
            }
            else
            {
                btnshowmorevalidations.Visibility = System.Windows.Visibility.Hidden;
            }
        }

        public void BindProteintSequence(string SequenceText)
        {
            txtValidateSequenceWithSpectrum.Text = SequenceText;
        }

        public void CalculateTheoreticalMass(string Sequencetext, double parentmass = 0)
        {
            lblTheoreticalMass.Content = Math.Round(CalculateBYCZIons.sequencelengthwithmodifications(Sequencetext) + Molecules.Water, 5);



            CalculateDeltaMass();

            double mass = 0;

            if (parentmass == 0)
            {
                mass = ParentMass;
            }
            else
            {
                mass = parentmass;
            }

            if (Math.Abs((Math.Round(CalculateBYCZIons.sequencelengthwithmodifications(Sequencetext) + Molecules.Water, 5) - Math.Round(mass, 4))) <= Molecules.Validationtolerance)
            {
                lblTheoreticalMass.Foreground = new SolidColorBrush(Colors.Green);
            }
            else
            {
                lblTheoreticalMass.Foreground = new SolidColorBrush(Colors.Red);
            }
        }

        /// <summary>
        /// Subtracting the ExperimentalMass from the TheoreticalMass
        /// </summary>
        public void CalculateDeltaMass()
        {
            if (lblTheoreticalMass.Content != null && lblTheoreticalMass.Content != "" && lblExperimentalMass.Text != null && lblExperimentalMass.Text != "")
            {
                lblValidationDeltaMass.Content = (Convert.ToDouble(lblTheoreticalMass.Content) - Convert.ToDouble(lblExperimentalMass.Text)).ToString(MassValueFormat);
            }
        }

        public void BindBandYIons(string SequenceText, ref double bandyionpercent, double parentmass = 0, List<double> CurrentMonoMass = null)
        {
            List<double> monomasses = new List<double>();

            double mass = 0;
            if (parentmass == 0)
            {
                mass = ParentMass;
            }
            else
            {
                mass = parentmass;
            }

            if (CurrentMonoMass == null)
            {
                monomasses = CurrentMonoMasses.Select(a => Convert.ToDouble(a.XValue)).ToList();
            }
            else
            {
                monomasses = CurrentMonoMass;
            }
            monomasses = monomasses.OrderBy(a => a).ToList();

            //var allbandyions = CalculateCandZIons.CalculateCandZIon(SequenceText, monomasses, mass, App.AllValidationModifications, Properties.Settings.Default.MatchTolerancePPM, AminoAcidHelpers.AminoAcidMass3);
            var allbandyions = CalculateBYCZIons.CalculateBYCZIon(SequenceText, monomasses, mass, CurrentSpectrum.Activation, App.AllValidationModifications, Properties.Settings.Default.MatchTolerancePPM, AminoAcidHelpers.AminoAcids);

            double bandhionscount = allbandyions.Where(a => a.yioncolor || a.bioncolor).Count();
            //double bandhionscount = allbandyions.Where(a => a.yioncolor || a.bioncolor).Count();

            double bandyions_percent = Math.Round((bandhionscount / allbandyions.Count) * 100, 2);

            totalbandyionpercent = bandyions_percent;
            bandyionpercent = bandyions_percent;
            double bions_percent = Math.Round(((double)allbandyions.Where(a => a.bioncolor).Count() / allbandyions.Count) * 100, 2);
            //double bions_percent = Math.Round(((double)allbandyions.Where(a => a.bioncolor).Count() / allbandyions.Count) * 100, 2);
            double yions_percent = Math.Round(((double)allbandyions.Where(a => a.yioncolor).Count() / allbandyions.Count) * 100, 2);
            //double yions_percent = Math.Round(((double)allbandyions.Where(a => a.yioncolor).Count() / allbandyions.Count) * 100, 2);


            Dispatcher.Invoke((Action)(() =>
            {
                if (Math.Abs((Math.Round(CalculateBYCZIons.sequencelengthwithmodifications(SequenceText) + Molecules.Water, 5) - Math.Round(mass, 4))) <= Molecules.Validationtolerance)
                //if (Math.Abs((Math.Round(CalculateBandYIons.sequencelengthwithmodifications(SequenceText) + Molecules.Water, 5) - Math.Round(mass, 4))) <= Molecules.Validationtolerance)
                {
                    lblTheoreticalMass.Foreground = new SolidColorBrush(Colors.Green);
                }
                else
                {
                    lblTheoreticalMass.Foreground = new SolidColorBrush(Colors.Red);
                }
                dtgridBandYIons.ItemsSource = null;
                dtgridBandYIons.ItemsSource = allbandyions;
                CIonsPPM.Visibility = Visibility.Collapsed;
                CIonsAMU.Visibility = Visibility.Collapsed;
                DisplayandHideBYCZIonTable(dtgridBandYIons, DechargerVM.ActivationType);  ///Hides the individual Columns based on activation type. Find a better way of doing it using XAML.(Tried but couldn't).
                //dtgridBandYIons.Columns.Where(a => a.Header.ToString() == "b-H2O").First().Visibility = Visibility.Collapsed;

                BIonsAMU.DataPoints.Clear();
                YIonsAMU.DataPoints.Clear();
                BIonsPPM.DataPoints.Clear();
                YIonsPPM.DataPoints.Clear();
                ZeroDelta.DataPoints.Clear();
                //dtgridBandYIons.ItemsSource = allbandyions;

                //MaxBandYIonErrorPPM(allbandyions);

                YIonsAMU.DataSource = allbandyions;
                BIonsAMU.DataSource = allbandyions;
                BIonsPPM.DataSource = allbandyions;
                YIonsPPM.DataSource = allbandyions;
                CIonsPPM.DataSource = allbandyions;
                //MaxBandYIonErrorPPM(allbandyions);

                ZeroDelta.DataPoints.Clear();
                ZeroDelta.DataPoints.Add(new DataPoint
                {
                    XValue = 0,
                    YValue = allbandyions.Count + 1
                });
                lblTheoreticalMass.Content = Math.Round(CalculateBYCZIons.sequencelengthwithmodifications(txtValidateSequenceWithSpectrum.Text) + Molecules.Water, 5);
                CalculateDeltaMass();
                lblbandyionspercent.Content = "Coverage Percent = " + bandyions_percent + "  Bions Percent = " + bions_percent + "   Yions Percent = " + yions_percent;
                lblbandyionpercentagehidden.Content = bandyions_percent;
            }));
        }

        /// <summary>
        /// Display or hide the columns in the datagrid based 
        /// </summary>
        void DisplayandHideBYCZIonTable(DataGrid dtgrid, string activationtype)
        {
            Dispatcher.Invoke((Action)(() =>
            {
                DisplayAllColumns(dtgrid); ///Initially display and columns, only hide what is not necessary
                HideBYCZErrors();
                if (DechargerVM.ActivationType != null)
                {
                    if (activationtype.Contains("HCD"))
                    {
                        if (activationtype.Contains(","))
                        {
                            ///If it multiple activation types then show everything
                            DisplayBYCZErrors();
                        }
                        else
                        {
                            DisplayCZErrors();
                            HideBYIonColumns(dtgrid); ///If it only has HCD activation type then Hide BYColumns, only display CZColumns
                        }
                    }
                    else
                    {
                        DisplayBYErrors();
                        HideCZIonColumns(dtgrid); ///If it doesn't have HCD activation type then Hide CZColumns, only display BYColumns
                    }
                }
            }));
        }

        /// <summary>
        /// Hides the columns on a datagrid based on the headers
        /// </summary>
        /// <param name="dtgrid"></param>
        /// <param name="columnstohide"></param>
        void HideDataGridColumns(DataGrid dtgrid, string[] columnstohide)
        {
            Dispatcher.Invoke((Action)(() =>
            {
                int columncount = columnstohide.Count();
                for (int i = 0; i < columncount; i++)
                {
                    if (dtgrid.Columns.Any(a => Convert.ToString(a.Header) == columnstohide[i])) ///Check if there is a column with the current header name
                    {
                        dtgrid.Columns.First(a => Convert.ToString(a.Header) == columnstohide[i]).Visibility = Visibility.Collapsed; ///If there is a column with the current header name then collapse the column
                    }
                }
            }));
        }


        void HideBYCZErrors()
        {
            Dispatcher.Invoke((Action)(() =>
            {
                Properties.Settings.Default.EnabledBYErrors = false;
                Properties.Settings.Default.EnabledBYErrorsAMU = false;
                Properties.Settings.Default.EnabledCZErrors = false;
                Properties.Settings.Default.EnabledCZErrorsAMU = false;
            }));
        }

        /// <summary>
        /// Hide BYIonerrors
        /// </summary>
        void DisplayBYErrors()
        {
            Dispatcher.Invoke((Action)(() =>
            {
                if (Properties.Settings.Default.PPMErrorPlot)
                {
                    Properties.Settings.Default.EnabledBYErrors = true;
                }
                if (Properties.Settings.Default.DaltonErrorPlot)
                {
                    Properties.Settings.Default.EnabledBYErrorsAMU = true;
                }
            }));
        }

        void DisplayBYCZErrors()
        {
            Dispatcher.Invoke((Action)(() =>
            {
                if (Properties.Settings.Default.PPMErrorPlot)
                {
                    Properties.Settings.Default.EnabledCZErrors = true;
                    Properties.Settings.Default.EnabledBYErrors = true;
                }
                if (Properties.Settings.Default.DaltonErrorPlot)
                {
                    Properties.Settings.Default.EnabledCZErrorsAMU = true;
                    Properties.Settings.Default.EnabledBYErrorsAMU = true;
                }
            }));
        }

        /// <summary>
        /// Hide CZIonerrors
        /// </summary>
        void DisplayCZErrors()
        {
            Dispatcher.Invoke((Action)(() =>
            {
                if (Properties.Settings.Default.PPMErrorPlot)
                {
                    Properties.Settings.Default.EnabledCZErrors = true;
                }
                else if (Properties.Settings.Default.DaltonErrorPlot)
                {
                    Properties.Settings.Default.EnabledCZErrorsAMU = true;
                }
            }));
        }

        /// <summary>
        /// Hides BandYions columns
        /// </summary>
        void HideBYIonColumns(DataGrid dtgrid)
        {
            Dispatcher.Invoke((Action)(() =>
            {
                string[] bandyioncolumnHeaders = { "b-H2O", "b Ions", "bIon #", "yIon #", "y Ions", "y-H2O", "y-NH3" };
                HideDataGridColumns(dtgrid, bandyioncolumnHeaders);
            }));
        }

        /// <summary>
        /// Hides CandZions columns
        /// </summary>
        void HideCZIonColumns(DataGrid dtgrid)
        {
            Dispatcher.Invoke((Action)(() =>
            {
                string[] candzioncolumnHeaders = { "c Ions", "z Ions" };
                HideDataGridColumns(dtgrid, candzioncolumnHeaders);
            }));
        }

        /// <summary>
        /// Display all the columns in the grid
        /// </summary>
        /// <param name="dtgrd"></param>
        void DisplayAllColumns(DataGrid dtgrd)
        {
            Dispatcher.Invoke((Action)(() =>
            {
                foreach (var column in dtgrd.Columns)
                {
                    column.Visibility = Visibility.Visible;
                }
            }));
        }

        /// <summary>
        /// Calculate the Highest PPM and adjust the scale based on that.
        /// </summary>
        /// <param name="allbandyions"></param>
        void MaxBandYIonErrorPPM(List<CalculateBYCZIons.BYCZIons> allbandyions)
        {
            try
            {
                if (Properties.Settings.Default.PPMErrorPlot)
                {
                    //&& allbandyions.Any(a => a.bionerror < 100) && allbandyions.Any(a => a.yionerror < 100)

                    double maxbionppm = allbandyions.Any(a => a.bionerror < 100) ? allbandyions.Where(a => a.bionerror != 100).Max(a => a.bionPPM) : Properties.Settings.Default.PPMErrorAxisMax;
                    double maxyionppm = allbandyions.Any(a => a.yionerror < 100) ? allbandyions.Where(a => a.yionerror != 100).Max(a => a.bionPPM) : Properties.Settings.Default.PPMErrorAxisMax;

                    maxbionppm = Math.Max(maxbionppm, maxyionppm) * 1.15;

                    maxppmerrorofbandyions = maxbionppm;
                    shouldshowmaxppmerrorofbandyions = true;
                    //Properties.Settings.Default.PPMErrorAxisMax = maxbionppm;
                    //Properties.Settings.Default.PPMErrorAxisMin = -maxbionppm;
                }
                else
                {
                    Properties.Settings.Default.PPMErrorAxisMax = 0.1;
                    Properties.Settings.Default.PPMErrorAxisMin = -0.1;
                }
            }
            catch (Exception)
            {

            }
        }


        void CalculateandDisplayBandYIons(string sequence = null, List<double> Monomasses = null, double parentmass = 0.0, bool displaybandyions = false, bool displaybions = false, bool displayyions = false)
        {
            if (sequence != null)
            {
                List<double> monomasses = new List<double>();

                if (Monomasses != null)
                {
                    monomasses = Monomasses;
                }
                else
                {
                    if (CurrentMonoMasses.Count == 0)
                    {
                        FindMonos();
                    }
                    monomasses = CurrentMonoMasses.Select(a => Convert.ToDouble(a.XValue)).ToList();
                }

                double prntms = 0;

                if (parentmass != 0.0)
                {
                    prntms = parentmass;
                }
                else
                {
                    prntms = ParentMass;
                }

                var allbandyions = sequence == null ? CalculateBYCZIons.CalculateBYCZIon(txtValidateSequenceWithSpectrum.Text + "[-" + Molecules.Water + "]", monomasses, prntms, CurrentSpectrum.Activation, App.AllValidationModifications, Properties.Settings.Default.MatchTolerancePPM, AminoAcidHelpers.AminoAcids) : CalculateBYCZIons.CalculateBYCZIon(sequence, monomasses, prntms, DechargerVM.ActivationType, App.AllValidationModifications, Properties.Settings.Default.MatchTolerancePPM, AminoAcidHelpers.AminoAcids);/// CalculateBandYIons.CalculateBandYIon(sequence, monomasses, ParentMass, App.AllValidationModifications, Properties.Settings.Default.MatchTolerancePPM, AminoAcidHelpers.AminoAcidMass3);

                double bandhionscount = allbandyions.Where(a => a.yioncolor || a.bioncolor).Count();

                if (displaybions)
                {
                    var bioncolorbright = allbandyions.Where(a => a.bioncolor).ToList();
                    var bioncolorlite = allbandyions.Where(a => !a.bioncolor).ToList();
                    List<DataPoint> bioncolorslite = new List<DataPoint>();
                    List<DataPoint> bioncolorsbright = new List<DataPoint>();
                    for (int i = 0; i < bioncolorbright.Count; i++)
                    {
                        bioncolorsbright.Add(new DataPoint()
                        {
                            XValue = bioncolorbright[i].Bion,
                            YValue = 0,
                            ToolTipText = "Marker = B" + Math.Abs(bioncolorbright[i].BionNumber)
                        });
                    }

                    ShowBIonsBright(bioncolorsbright);
                    for (int i = 0; i < bioncolorlite.Count; i++)
                    {
                        bioncolorslite.Add(new DataPoint()
                        {
                            XValue = bioncolorlite[i].Bion,
                            YValue = 0,
                            ToolTipText = "Marker = B" + Math.Abs(bioncolorlite[i].BionNumber)
                        });
                    }

                    ShowBIonsFaint(bioncolorslite);
                }

                if (displayyions)
                {
                    var yioncolorbright = allbandyions.Where(a => a.yioncolor).ToList();
                    var yioncolorlite = allbandyions.Where(a => !a.yioncolor).ToList();
                    List<DataPoint> yioncolorslite = new List<DataPoint>();
                    List<DataPoint> yioncolorsbright = new List<DataPoint>();
                    for (int i = 0; i < yioncolorbright.Count; i++)
                    {
                        yioncolorsbright.Add(new DataPoint()
                        {
                            XValue = yioncolorbright[i].Yion,
                            YValue = 0,
                            ToolTipText = "Marker = Y" + Math.Abs(yioncolorbright[i].YionNumber)
                        });
                    }

                    ShowYIonsBright(yioncolorsbright);
                    for (int i = 0; i < yioncolorlite.Count; i++)
                    {
                        yioncolorslite.Add(new DataPoint()
                        {
                            XValue = yioncolorlite[i].Yion,
                            YValue = 0,
                            ToolTipText = "Marker = Y" + Math.Abs(yioncolorlite[i].YionNumber)
                        });
                    }
                    ShowYIonsFaint(yioncolorslite);
                }

                if (displaybandyions)
                {
                    var bioncolorbright = allbandyions.Where(a => a.bioncolor).ToList();

                    var yioncolorbright = allbandyions.Where(a => a.yioncolor).ToList();

                    var bioncolorlite = allbandyions.Where(a => !a.bioncolor).ToList();

                    var yioncolorlite = allbandyions.Where(a => !a.yioncolor).ToList();

                    List<DataPoint> bioncolorslite = new List<DataPoint>();
                    List<DataPoint> yioncolorslite = new List<DataPoint>();
                    List<DataPoint> bioncolorsbright = new List<DataPoint>();
                    List<DataPoint> yioncolorsbright = new List<DataPoint>();

                    for (int i = 0; i < bioncolorbright.Count; i++)
                    {
                        bioncolorsbright.Add(new DataPoint()
                        {
                            XValue = bioncolorbright[i].Bion,
                            YValue = 0,
                            ToolTipText = "Marker = B" + Math.Abs(bioncolorbright[i].BionNumber)
                        });
                    }

                    ShowBIonsBright(bioncolorsbright);


                    for (int i = 0; i < yioncolorbright.Count; i++)
                    {
                        yioncolorsbright.Add(new DataPoint()
                        {
                            XValue = yioncolorbright[i].Yion,
                            YValue = 0,
                            ToolTipText = "Marker = Y" + Math.Abs(yioncolorbright[i].YionNumber)
                        });
                    }

                    ShowYIonsBright(yioncolorsbright);

                    for (int i = 0; i < bioncolorlite.Count; i++)
                    {
                        bioncolorslite.Add(new DataPoint()
                        {
                            XValue = bioncolorlite[i].Bion,
                            YValue = 0,
                            ToolTipText = "Marker = B" + Math.Abs(bioncolorlite[i].BionNumber)
                        });
                    }

                    ShowBIonsFaint(bioncolorslite);

                    for (int i = 0; i < yioncolorlite.Count; i++)
                    {
                        yioncolorslite.Add(new DataPoint()
                        {
                            XValue = yioncolorlite[i].Yion,
                            YValue = 0,
                            ToolTipText = "Marker = Y" + Math.Abs(yioncolorlite[i].YionNumber)
                        });
                    }

                    ShowYIonsFaint(yioncolorslite);
                }
                double bandyions_percent = Math.Round((bandhionscount / allbandyions.Count) * 100, 2);

                totalbandyionpercent = bandyions_percent;

                double bions_percent = Math.Round(((double)allbandyions.Where(a => a.bioncolor).Count() / allbandyions.Count) * 100, 2);
                double yions_percent = Math.Round(((double)allbandyions.Where(a => a.yioncolor).Count() / allbandyions.Count) * 100, 2);

                Dispatcher.Invoke((Action)(() =>
                {
                    dtgridBandYIons.ItemsSource = null;
                    dtgridBandYIons.ItemsSource = allbandyions;
                    BIonsAMU.DataPoints.Clear();
                    YIonsAMU.DataPoints.Clear();
                    BIonsPPM.DataPoints.Clear();
                    YIonsPPM.DataPoints.Clear();
                    ZeroDelta.DataPoints.Clear();
                    ZeroDelta.DataPoints.Add(new DataPoint
                    {
                        XValue = 0,
                        YValue = allbandyions.Count + 1
                    });

                    lblbandyionspercent.Content = "Coverage Percent = " + bandyions_percent + "  Bions Percent = " + bions_percent + "   Yions Percent = " + yions_percent;
                    lblbandyionpercentagehidden.Content = bandyions_percent;

                    YIonsAMU.DataSource = allbandyions;
                    BIonsAMU.DataSource = allbandyions;
                    BIonsPPM.DataSource = allbandyions;
                    YIonsPPM.DataSource = allbandyions;
                    CIonsPPM.DataSource = allbandyions;
                    ///ZIonsPPM.DataSource = allbandyions;
                    //MaxBandYIonErrorPPM(allbandyions);
                }));
            }
            else
            {
                Dispatcher.Invoke((Action)(() =>
                {
                    YIonsAMU.DataSource = null;
                    BIonsAMU.DataSource = null;
                    BIonsPPM.DataSource = null;
                    YIonsPPM.DataSource = null;
                    dtgridBandYIons.ItemsSource = null;
                }));
            }
        }

        private void btnApplyandShowBandYIons_Click(object sender, RoutedEventArgs e)
        {
            ClearRedGreenMarkers();

            if (ValidateForNumbersandAlphabets(txtValidateSequenceWithSpectrum.Text))
            {
                //if (lblTheoreticalMass.Content is double && lblTheoreticalMass.Content != double.NaN) //  txtValidateSequenceWithSpectrum.Text != "")
                {
                    CalculateandDisplayBandYIons(txtValidateSequenceWithSpectrum.Text, null, 0, true);
                    lblTheoreticalMass.Content = Math.Round(CalculateBYCZIons.sequencelengthwithmodifications(txtValidateSequenceWithSpectrum.Text) + Molecules.Water, 5);

                    CalculateDeltaMass();

                    if (Math.Abs(Math.Round(CalculateBYCZIons.sequencelengthwithmodifications(txtValidateSequenceWithSpectrum.Text) + Molecules.Water, 5) - Math.Round(ParentMass, 4)) <= Molecules.Validationtolerance)/// PPM.CurrentPPM(Math.Round(ParentMass, 4)))
                    {
                        lblTheoreticalMass.Foreground = new SolidColorBrush(Colors.Green);
                    }
                    else
                    {
                        lblTheoreticalMass.Foreground = new SolidColorBrush(Colors.Red);
                    }


                    //PopulateRedandGreenMarkers(null, true, true);
                    //btnApply_Click(null, null);
                    //btnApply2_Click(null, null);
                }
            }
            else
            {
                System.Windows.MessageBox.Show("Valid Sequence required");
            }
        }

        private bool ValidateForNumbersandAlphabets(string sequence)
        {
            sequence = sequence.Replace("(", "").Replace(")", "").Trim();
            Regex rgx = new Regex(@"^[a-zA-Z0-9\[\]\+\-\.]+$");

            bool mod = false;

            foreach (var item in string.Join(",", sequence.ToArray()).Split(new char[] { ',' }))
            {
                if (item == "[")
                {
                    mod = true;
                }
                else if (item == "]")
                {
                    mod = false;
                }

                if (mod)
                {
                    continue;
                }
                else
                {
                    if (rgx.IsMatch(item))
                    {

                    }
                    else
                    {
                        return false;
                    }
                }

            }

            //if (!rgx.IsMatch(sequence))
            //{
            //    return false;
            //}

            if (mod) return false;

            return true;
        }

        /// <summary>
        /// Clear all the datapoints and graph for empty string
        /// </summary>
        private void ClearBYIons()
        {
            txtValidateSequenceWithSpectrum.Text = "";
            CalculateandDisplayBandYIons();
            PopulateRedandGreenMarkers(null, false, false, true);
            BIonsAMU.DataPoints.Clear();
            YIonsAMU.DataPoints.Clear();
            BIonsPPM.DataPoints.Clear();
            YIonsPPM.DataPoints.Clear();

            lblTheoreticalMass.Content = "";
            //lblExperimentalMass.Text = "";
            lblValidationDeltaMass.Content = "";

            ClearRedGreenMarkers();
        }

        private void ClearRedGreenMarkers()
        {
            RedMarkersSeries.DataPoints.Clear();
            RedMarkersSeriesBright.DataPoints.Clear();
            RedMarkersSeriesLite.DataPoints.Clear();
            GreenMarkersSeries.DataPoints.Clear();
            GreenMarkersSeriesBright.DataPoints.Clear();
            GreenMarkersSeriesLite.DataPoints.Clear();
        }

        /// <summary>
        /// Populate the RedMarkers Tab and GreenMarkers Tab
        /// </summary>
        /// <param name="BYIons"></param>
        void PopulateRedandGreenMarkers(List<CalculateBYCZIons.BYCZIons> BYIons = null, bool redMarkers = false, bool greenMarkers = false, bool clearspectrum = false)
        {
            //var byions = BYIons == null ? (dtgridBandYIons.ItemsSource is List<CalculateBandYIons.BYIons> ? dtgridBandYIons.ItemsSource as List<CalculateBandYIons.BYIons> : new List<CalculateBandYIons.BYIons>) : BYIons;
            if (clearspectrum)
            {
                txtMarkers.Text = "";
                txtMarkers2.Text = "";
            }
            else if (BYIons == null)
            {
                if (dtgridBandYIons.ItemsSource is List<CalculateBYCZIons.BYCZIons>)
                {
                    var byions = dtgridBandYIons.ItemsSource as List<CalculateBYCZIons.BYCZIons>;

                    StringBuilder RedMarkers = new StringBuilder();
                    StringBuilder GreenMarkers = new StringBuilder();

                    int count = byions.Count;
                    int c = 1;
                    if (redMarkers && greenMarkers)
                    {
                        btnClearMarkers1_Click(null, null);
                        btnClearMarkers2_Click(null, null);
                        GreenMarkersSeriesLite.DataPoints.Clear();
                        RedMarkersSeriesLite.DataPoints.Clear();
                        {
                            var bioncolorbright = byions.Where(a => a.bioncolor).ToList();

                            var yioncolorbright = byions.Where(a => a.yioncolor).ToList();

                            var bioncolorlite = byions.Where(a => !a.bioncolor).ToList();

                            var yioncolorlite = byions.Where(a => !a.yioncolor).ToList();

                            List<DataPoint> bioncolorslite = new List<DataPoint>();
                            List<DataPoint> yioncolorslite = new List<DataPoint>();
                            List<DataPoint> bioncolorsbright = new List<DataPoint>();
                            List<DataPoint> yioncolorsbright = new List<DataPoint>();

                            for (int i = 0; i < bioncolorbright.Count; i++)
                            {
                                bioncolorsbright.Add(new DataPoint()
                                {
                                    XValue = bioncolorbright[i].Bion,
                                    YValue = 0,
                                    ToolTipText = "Marker = B" + Math.Abs(bioncolorbright[i].BionNumber)
                                });
                            }

                            ShowBIonsBright(bioncolorsbright);


                            for (int i = 0; i < yioncolorbright.Count; i++)
                            {
                                yioncolorsbright.Add(new DataPoint()
                                {
                                    XValue = yioncolorbright[i].Yion,
                                    YValue = 0,
                                    ToolTipText = "Marker = Y" + Math.Abs(yioncolorbright[i].YionNumber)
                                });
                            }

                            ShowYIonsBright(yioncolorsbright);

                            for (int i = 0; i < bioncolorlite.Count; i++)
                            {
                                bioncolorslite.Add(new DataPoint()
                                {
                                    XValue = bioncolorlite[i].Bion,
                                    YValue = 0,
                                    ToolTipText = "Marker = B" + Math.Abs(bioncolorlite[i].BionNumber)
                                });
                            }

                            ShowBIonsFaint(bioncolorslite);

                            for (int i = 0; i < yioncolorlite.Count; i++)
                            {
                                yioncolorslite.Add(new DataPoint()
                                {
                                    XValue = yioncolorlite[i].Yion,
                                    YValue = 0,
                                    ToolTipText = "Marker = Y" + Math.Abs(yioncolorlite[i].YionNumber)
                                });
                            }

                            ShowYIonsFaint(yioncolorslite);
                        }
                        foreach (var byion in byions)
                        {
                            RedMarkers.Append(byion.Bion + " " + "b" + c + "\n");
                            GreenMarkers.Append(byion.Yion + " " + "y" + count + "\n");
                            c = c + 1;
                            count = count - 1;
                        }
                        txtMarkers.Text = Convert.ToString(RedMarkers);
                        txtMarkers2.Text = Convert.ToString(GreenMarkers);
                    }

                    else
                    {
                        if (redMarkers)
                        {
                            foreach (var byion in byions)
                            {
                                RedMarkers.Append(byion.Bion + " " + "b" + c + "\n");
                                c = c + 1;
                            }
                            txtMarkers.Text = Convert.ToString(RedMarkers);
                        }
                        else if (greenMarkers)
                        {
                            foreach (var byion in byions)
                            {
                                GreenMarkers.Append(byion.Yion + " " + "y" + count + "\n");
                                count = count - 1;
                            }
                            txtMarkers2.Text = Convert.ToString(GreenMarkers);
                        }
                    }
                }
            }
            else
            {
                StringBuilder RedMarkers = new StringBuilder();
                StringBuilder GreenMarkers = new StringBuilder();

                int count = BYIons.Count;
                int c = 1;
                if (redMarkers && greenMarkers)
                {
                    foreach (var byion in BYIons)
                    {
                        RedMarkers.Append(byion.Bion + " " + "b" + c + "\n");
                        GreenMarkers.Append(byion.Yion + " " + "y" + count + "\n");
                        c = c + 1;
                        count = count - 1;
                    }
                    txtMarkers.Text = Convert.ToString(RedMarkers);
                    txtMarkers2.Text = Convert.ToString(GreenMarkers);
                }

                else
                {
                    if (redMarkers)
                    {
                        foreach (var byion in BYIons)
                        {
                            RedMarkers.Append(byion.Bion + " " + "b" + c + "\n");
                            c = c + 1;
                        }
                        txtMarkers.Text = Convert.ToString(RedMarkers);
                    }
                    else if (greenMarkers)
                    {
                        foreach (var byion in BYIons)
                        {
                            GreenMarkers.Append(byion.Yion + " " + "y" + count + "\n");
                            count = count - 1;
                        }
                        txtMarkers2.Text = Convert.ToString(GreenMarkers);
                    }
                }


            }
        }

        private void btnShowBions_Click(object sender, RoutedEventArgs e)
        {
            RedMarkersSeriesLite.DataPoints.Clear();
            btnClearMarkers1_Click(null, null);
            CalculateandDisplayBandYIons(txtValidateSequenceWithSpectrum.Text, null, 0, false, true, false);
            //PopulateRedandGreenMarkers(null, true, false);
            //ShowBions();
            //btnApply_Click(null, null);
        }

        /// <summary>
        /// Show Bions using the current monomasses. 
        /// Show the matched Bions brighter compared to unmatched ones.
        /// </summary>
        void ShowBions()
        {
            if (CurrentMonoMasses.Count == 0)
            {
                FindMonos();
            }
            if (CurrentMonoMasses.Count != 0)
            {
                var monomasses = CurrentMonoMasses.Select(a => Convert.ToDouble(a.XValue)).ToList();

                var allbandyions = CalculateBYCZIons.CalculateBYCZIon(txtValidateSequenceWithSpectrum.Text + "[-" + Molecules.Water + "]", monomasses, ParentMass, CurrentSpectrum.Activation, App.AllValidationModifications, Properties.Settings.Default.MatchTolerancePPM, AminoAcidHelpers.AminoAcids);

                double bandhionscount = allbandyions.Where(a => a.yioncolor || a.bioncolor).Count();

                var bioncolorbright = allbandyions.Where(a => a.bioncolor).ToList();
                var bioncolorlite = allbandyions.Where(a => !a.bioncolor).ToList();

                List<DataPoint> bioncolorslite = new List<DataPoint>();
                List<DataPoint> bioncolorsbright = new List<DataPoint>();
                for (int i = 0; i < bioncolorbright.Count; i++)
                {
                    bioncolorsbright.Add(new DataPoint()
                    {
                        XValue = bioncolorbright[i].Bion,
                        YValue = 0,
                        ToolTipText = "Marker = B" + Math.Abs(bioncolorbright[i].BionNumber)
                    });
                }

                ShowBIonsBright(bioncolorsbright);

                for (int i = 0; i < bioncolorlite.Count; i++)
                {
                    bioncolorslite.Add(new DataPoint()
                    {
                        XValue = bioncolorlite[i].Bion,
                        YValue = 0,
                        ToolTipText = "Marker = B" + Math.Abs(bioncolorlite[i].BionNumber)
                    });
                }

                ShowBIonsFaint(bioncolorslite);
            }
        }

        /// <summary>
        /// Show Yions using the current monomasses.
        /// Show the matched Yions brighter than the unmatched ones.
        /// </summary>
        void ShowYIons()
        {
            //TODO: This is not OK.  This needs to take a few parameters including a Spectrum or SuperSpectrum object for points, parent, and activation...

            if (CurrentMonoMasses.Count == 0)
            {
                FindMonos();
            }
            if (CurrentMonoMasses.Count != 0)
            {
                var monomasses = CurrentMonoMasses.Select(a => Convert.ToDouble(a.XValue)).ToList();

                Spectrum.ActivationOverride = Properties.Settings.Default.ActivationOverride;
                //DechargerVM.
                
                var allbandyions = CalculateBYCZIons.CalculateBYCZIon(txtValidateSequenceWithSpectrum.Text + "[-" + Molecules.Water + "]", monomasses, ParentMass, CurrentSpectrum.Activation, App.AllValidationModifications, Properties.Settings.Default.MatchTolerancePPM, AminoAcidHelpers.AminoAcids);

                double bandhionscount = allbandyions.Where(a => a.yioncolor || a.bioncolor).Count();

                var yioncolorbright = allbandyions.Where(a => a.yioncolor).ToList();
                var yioncolorlite = allbandyions.Where(a => !a.yioncolor).ToList();

                List<DataPoint> yioncolorslite = new List<DataPoint>();
                List<DataPoint> yioncolorsbright = new List<DataPoint>();

                for (int i = 0; i < yioncolorbright.Count; i++)
                {
                    yioncolorsbright.Add(new DataPoint()
                    {
                        XValue = yioncolorbright[i].Yion,
                        YValue = 0,
                        ToolTipText = "Marker = Y" + Math.Abs(yioncolorbright[i].YionNumber)
                    });
                }

                ShowYIonsBright(yioncolorsbright);

                for (int i = 0; i < yioncolorlite.Count; i++)
                {
                    yioncolorslite.Add(new DataPoint()
                    {
                        XValue = yioncolorlite[i].Yion,
                        YValue = 0,
                        ToolTipText = "Marker = Y" + Math.Abs(yioncolorlite[i].YionNumber)
                    });
                }

                ShowYIonsFaint(yioncolorslite);
            }
        }

        private void btnShowYions_Click(object sender, RoutedEventArgs e)
        {
            btnClearMarkers2_Click(null, null);
            GreenMarkersSeriesLite.DataPoints.Clear();
            CalculateandDisplayBandYIons(txtValidateSequenceWithSpectrum.Text, null, 0, false, false, true);
            //PopulateRedandGreenMarkers(null, false, true);
            //ShowYIons();
            //btnApply2_Click(null, null);
        }

        private void btnClearBandYIons_Click(object sender, RoutedEventArgs e)
        {
            btnClearMarkers1_Click(null, null);
            btnClearMarkers2_Click(null, null);
            GreenMarkersSeriesLite.DataPoints.Clear();
            RedMarkersSeriesLite.DataPoints.Clear();
        }

        private void xaxisErrorPlot_OnZoom(object sender, AxisZoomEventArgs e)
        {
            var axis = sender as Visifire.Charts.Axis;
            double zoomMin = (double)e.MinValue;
            double zoomMax = (double)e.MaxValue;
            axis.Zoom(zoomMin, zoomMax);
        }

        private void mnudeletemodification_Click(object sender, RoutedEventArgs e)
        {
            if (dtgridModificationsList.SelectedItem != null && dtgridModificationsList.SelectedItem is ModificationList)
            {
                var modification = dtgridModificationsList.SelectedItem as ModificationList;

                App.AllValidationModifications.Remove(modification);

                //App.AllValidationModificationAminoAcids.Remove(modification);

                UpdateModificationsList();
            }
        }

        private void btnvalidateaddmod_Click(object sender, RoutedEventArgs e)
        {
            // Validate user input
            if (txtvalidateModification.Text.Trim() == string.Empty)
            {
                System.Windows.MessageBox.Show("Modification name is a required field.", "A Name is required", MessageBoxButton.OK, MessageBoxImage.Exclamation);
            }
            else if (txtvalidateMass.Text.Trim() == string.Empty)
            {
                System.Windows.MessageBox.Show("Modification mass is a required field.", "Mass value required", MessageBoxButton.OK, MessageBoxImage.Exclamation);
            }
            else if (txtvalidateAbbreviation.Text.Trim() == string.Empty)
            {
                System.Windows.MessageBox.Show("Modification abbreviation is a required field.", "Abbreviation is required", MessageBoxButton.OK, MessageBoxImage.Exclamation);
            }
            else
            {
                // User input seems ok, try to add

                // Check for duplicate mods
                if (App.AllValidationModifications.Any(a => a.Name.ToLower() == txtvalidateModification.Text.ToLower()))
                {
                    System.Windows.MessageBox.Show("Modification name already exists. Can't add modification.", "Duplicate name", MessageBoxButton.OK, MessageBoxImage.Exclamation);
                    return;
                }
                else
                {
                    Properties.Settings.Default.ValidationModificationsList += txtvalidateModification.Text + "\t" + txtvalidateMass.Text + "\t" + (txtvalidateAbbreviation.Text).ToLower() + "\n";

                    Properties.Settings.Default.ValidationModificationsListAminoAcids += "\n";

                    Properties.Settings.Default.Save();

                    PopulateValidateModificationList();
                    ClearModificationsList();
                    txtvalidateModification.Focus();
                }
            }
        }


        void ClearModificationsList()
        {
            txtvalidateModification.Text = "";
            txtvalidateMass.Text = "";
            txtvalidateAbbreviation.Text = "";
        }


        /// <summary>
        /// Update the modifications list once a modification is deleted.
        /// </summary>
        void UpdateModificationsList()
        {
            if (App.AllValidationModifications != null)
            {
                Properties.Settings.Default.ValidationModificationsList = "";
                Properties.Settings.Default.ValidationModificationsListAminoAcids = "";
                int i = 0;
                foreach (var modification in App.AllValidationModifications)
                {
                    Properties.Settings.Default.ValidationModificationsList += modification.Name + "\t" + modification.Mass + "\t" + modification.Abbreviation.Trim() + "\t" + string.Join(",", App.AllValidationModifications[i].AminoAcids) + "\n";
                    i = i + 1;
                }

                Dispatcher.Invoke((Action)(() =>
                    {
                        Properties.Settings.Default.Save();
                        PopulateValidateModificationList();
                    }));
            }
        }


        void PopulateValidateModificationList()
        {
            string allmodifications = Properties.Settings.Default.ValidationModificationsList;

            string[] splitnewline = { "\n" };

            string[] splittab = { "\t" };

            string[] individualmodifications = allmodifications.Split(splitnewline, StringSplitOptions.RemoveEmptyEntries);

            App.AllValidationModifications = new List<ModificationList>();
            for (int i = 0; i < individualmodifications.Length; i++)
            {
                string[] mds = individualmodifications[i].Split(splittab, StringSplitOptions.RemoveEmptyEntries);

                App.AllValidationModifications.Add(new ModificationList
                {
                    Name = mds[0],
                    Mass = mds[1],
                    Abbreviation = mds[2].Trim().ToLower(),
                    AminoAcids = (App.uniMods.Any(a => (a.Description.ToLower() == mds[0].ToLower()) || (a.InterimName.ToLower() == mds[0].ToLower())) ? (App.uniMods.Where(a => (a.Description.ToLower() == mds[0].ToLower()) || (a.InterimName.ToLower() == mds[0].ToLower())).Select(a => a.Sites).First()) : (new List<string>()))
                });
            }

            int ii = 0;
            Properties.Settings.Default.ValidationModificationsList = "";
            foreach (var modification in App.AllValidationModifications)
            {
                Properties.Settings.Default.ValidationModificationsList += modification.Name + "\t" + modification.Mass + "\t" + modification.Abbreviation.Trim() + "\t" + string.Join(",", App.AllValidationModifications[ii].AminoAcids) + "\n";
                ii = ii + 1;
            }

            dtgridModificationsList.ItemsSource = App.AllValidationModifications;
            dtgridModificationsList1.ItemsSource = App.AllValidationModifications;
        }


        bool ismoddragging = false;
        int ValidationModificationsrowIndex = -1;

        private void dtgridModificationsList_PreviewMouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            ValidationModificationsrowIndex = GetCurrentRowIndex(e.GetPosition);

            if (ValidationModificationsrowIndex < 0)
                return;
            dtgridModificationsList.SelectedIndex = ValidationModificationsrowIndex;
            ismoddragging = true;

            ModificationList selectedmod = dtgridModificationsList.Items[ValidationModificationsrowIndex] as ModificationList;
            if (selectedmod == null) return;

            try
            {
                DragDropEffects dragdropeffects = DragDropEffects.Copy;
                if (DragDrop.DoDragDrop(dtgridModificationsList, selectedmod, dragdropeffects) != DragDropEffects.None)
                {
                    dtgridModificationsList.SelectedItem = selectedmod;
                }
            }
            catch (COMException ex)
            {
                Debug.Print("COMException Thrown during a drag/drop!  \n" + ex.Message);
            }
        }

        /// <summary>
        /// Gets the row on which the current mouse pointer is
        /// </summary>
        /// <param name="theTarget"></param>
        /// <param name="position"></param>
        /// <returns></returns>
        private bool GetMouseTargetRow(Visual theTarget, GetPosition position)
        {
            try
            {
                Rect rect = VisualTreeHelper.GetDescendantBounds(theTarget);
                System.Windows.Point point = position((IInputElement)theTarget);
                return rect.Contains(point);
            }
            catch (Exception)
            {
                return false;
            }

        }

        /// <summary>
        /// Gets the row based on the index
        /// </summary>
        /// <param name="index"></param>
        /// <returns></returns>
        private DataGridRow GetRowItem(int index)
        {
            if (dtgridModificationsList.ItemContainerGenerator.Status
                    != GeneratorStatus.ContainersGenerated)
                return null;
            return dtgridModificationsList.ItemContainerGenerator.ContainerFromIndex(index)
                                                            as DataGridRow;
        }


        private DataGridRow GetRowItem1(int index)
        {
            if (dtgridModificationsList1.ItemContainerGenerator.Status
                    != GeneratorStatus.ContainersGenerated)
                return null;
            return dtgridModificationsList1.ItemContainerGenerator.ContainerFromIndex(index)
                                                            as DataGridRow;
        }

        public delegate System.Windows.Point GetPosition(IInputElement element);

        /// <summary>
        /// Gets the current idex of the selected item
        /// </summary>
        /// <param name="pos"></param>
        /// <returns></returns>
        private int GetCurrentRowIndex(GetPosition pos)
        {
            int curIndex = -1;
            for (int i = 0; i < dtgridModificationsList.Items.Count; i++)
            {
                DataGridRow itm = GetRowItem(i);
                if (GetMouseTargetRow(itm, pos))
                {
                    curIndex = i;
                    break;
                }
            }
            return curIndex;
        }


        private int GetCurrentRowIndex1(GetPosition pos)
        {
            int curIndex = -1;
            for (int i = 0; i < dtgridModificationsList1.Items.Count; i++)
            {
                DataGridRow itm = GetRowItem1(i);
                if (GetMouseTargetRow(itm, pos))
                {
                    curIndex = i;
                    break;
                }
            }
            return curIndex;
        }



        private void txtValidateSequenceWithSpectrum_PreviewDragOver(object sender, DragEventArgs e)
        {
            e.Handled = true;
        }

        /// <summary>
        /// When a row from the datagrid is dropped it needs to add the modification at the correct position depending on mouse.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void txtValidateSequenceWithSpectrum_Drop(object sender, DragEventArgs e)
        {
            if (ismoddragging && txtValidateSequenceWithSpectrum.Text != "")
            {
                txtValidateSequenceWithSpectrum.CaptureMouse();
                txtValidateSequenceWithSpectrum.CaretIndex = txtValidateSequenceWithSpectrum.GetCharacterIndexFromPoint(Mouse.GetPosition(txtValidateSequenceWithSpectrum), true); //Gets the current position of the mouse from which we set the caretindex of the textbox

                string mass = string.Empty;
                if (dtgridModificationsList.SelectedItem != null && dtgridModificationsList.SelectedItem is ModificationList)
                {
                    mass = (dtgridModificationsList.SelectedItem as ModificationList).Mass.StartsWith("-") ?
                            ("-" + (dtgridModificationsList.SelectedItem as ModificationList).Abbreviation) :
                            ((dtgridModificationsList.SelectedItem as ModificationList).Abbreviation); //"+" + 
                }
                int caretindex = txtValidateSequenceWithSpectrum.CaretIndex;

                string currenttext = txtValidateSequenceWithSpectrum.Text;

                txtValidateSequenceWithSpectrum.Text = removemod(txtValidateSequenceWithSpectrum.Text, txtValidateSequenceWithSpectrum.CaretIndex, mass);
                txtValidateSequenceWithSpectrum.CaretIndex = caretindex;

                dtgridModificationsList.Focus();

                ismoddragging = false;
            }
        }

        bool ismoddropped = false;

        /// <summary>
        /// Remove any mods which have ] or [ as delimiters
        /// </summary>
        /// <param name="sequence"></param>
        /// <param name="currentposition"></param>
        /// <param name="Mass"></param>
        /// <returns></returns>
        string removemod(string sequence, int currentposition, string Mass, bool lastchar = false)
        {
            string currenttext = sequence;
            string mass = Mass;

            int caretindex = currentposition;
            string newtext = string.Empty;
            string sequencetoconsider = currenttext.Substring(0, currentposition + 1);

            Regex rgx = new Regex(@"[\d\.\-\+\[\]]");

            Regex rgx1 = new Regex(@"^[\d\.\-\+\[\]]+$");

            if (rgx.IsMatch(sequencetoconsider)) /// || App.AllValidationModifications.Any(a => a.Abbreviation ==))
            {
                int start = 0;
                int end = 0;

                bool currentindex = false;

                start = currentposition; // Start searching for '[' from the current position
                end = currentposition;   // Start searching for ']' from the current position
                foreach (char item in currenttext.Substring(currentposition - 1, currenttext.Length - (currentposition - 1)))
                {
                    newtext += item;
                    if (item == ']') /// if the end is found break.
                    {
                        break;
                    }
                    else if (item == '[' && (end != currentposition) && (end != currentposition + 1))  /// if the start of another mod is found break. 
                    {
                        end = currentposition;
                        start = currentposition;
                        currentindex = true;
                        break;
                    }
                    else // increase the value of index by 1.
                    {
                        end = end + 1;
                    }
                }

                if (end == currenttext.Length && !rgx1.IsMatch(newtext)) /// If it looks for all the sequence and doesn't find any reset the position to the current cursor
                {
                    end = currentposition;
                }
                newtext = string.Empty;
                foreach (var item in Enumerable.Reverse(currenttext.Substring(0, currentposition + 1)))
                {
                    newtext += item;
                    if (item == '[') // if the start is found break.
                    {
                        break;
                    }
                    else if (item == ']' && (start != currentposition - 1 && start != currentposition)) // if the end of another mod is found break.
                    {
                        end = currentposition;
                        start = currentposition;
                        currentindex = true;
                        break;
                    }
                    else // decrease the value of index by 1
                    {
                        start = start - 1;
                    }
                }

                if (start == 0 && !rgx1.IsMatch(newtext))
                {
                    start = currentposition;
                }

                if (lastchar)
                {
                    newtext = currenttext.Substring(0, currentposition + 1) + "[" + (mass.Contains("-") ? mass : "+" + mass) + "]" + currenttext.Substring(currentposition + 1, currenttext.Length - (currentposition + 1));
                }
                else if (currentindex)
                {
                    newtext = currenttext.Substring(0, currentposition + 1) + "[" + (mass.Contains("-") ? mass : "+" + mass) + "]" + currenttext.Substring(currentposition + 1, currenttext.Length - (currentposition + 1));
                }
                else
                {
                    newtext = currenttext.Substring(0, start) + "[" + (mass.Contains("-") ? mass : "+" + mass) + "]" + currenttext.Substring(end, currenttext.Length - (end));
                }
            }
            else
            {
                newtext = currenttext.Substring(0, currentposition + 1) + "[" + (mass.Contains("-") ? mass : "+" + mass) + "]" + currenttext.Substring(currentposition + 1, currenttext.Length - (currentposition + 1));
            }
            return newtext;
        }


        /// <summary>
        /// When a modification is dropped on to the grid of bandyions 
        /// it should add the modification to the respective column
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void dtgridBandYIons_Drop(object sender, DragEventArgs e)
        {
            ///Only when a modification is dropped from the datagrid it needs to add the modification
            if (ismoddragging)
            {
                ismoddropped = true;

                ismoddragging = false;

                if (!(dtgridBandYIons.ItemsSource is List<CalculateBYCZIons.BYCZIons>))
                {
                    return;
                }

                var element = (UIElement)e.Source;

                int bionnumber = 0;

                ///Getting the bionnumber from which we will set the modification on the correct bion
                if (((((System.Windows.FrameworkElement)(VisualTreeHelper.HitTest(dtgridBandYIons, e.GetPosition(dtgridBandYIons)).VisualHit)).DataContext) as CalculateBYCZIons.BYCZIons) != null)
                {
                    bionnumber = ((((System.Windows.FrameworkElement)(VisualTreeHelper.HitTest(dtgridBandYIons, e.GetPosition(dtgridBandYIons)).VisualHit)).DataContext) as CalculateBYCZIons.BYCZIons).BionNumber;
                }
                else
                {
                    return;
                }
                string sequence = txtValidateSequenceWithSpectrum.Text;

                string mass = String.Empty;

                var allbandyions = dtgridModificationsList.ItemsSource;

                if (dtgridModificationsList.SelectedItem != null && dtgridModificationsList.SelectedItem is ModificationList)
                {
                    mass = ((dtgridModificationsList.SelectedItem as ModificationList).Mass.Contains("-") ? "-" : "") + (dtgridModificationsList.SelectedItem as ModificationList).Abbreviation;
                }

                Regex rgx = new Regex(@"[0-9\.\-\+]+$");

                Regex rgxalpha = new Regex(@"[a-z]");

                string updatedseqs = string.Empty;

                string newsequence = sequence;

                newsequence = newsequence.Replace("(", "");
                newsequence = newsequence.Replace(")", "");

                string[] nwseqs = newsequence.Split(new string[] { "[", "]" }, StringSplitOptions.RemoveEmptyEntries);

                int j = 0;

                string aa = string.Empty;
                string tempst = string.Empty;

                for (int i = 0; i < nwseqs.Length; i++)
                {
                    if (rgx.IsMatch(nwseqs[i]))
                    {
                        if (j == bionnumber + 1)
                        {
                            continue;
                        }
                        updatedseqs = updatedseqs + "[" + nwseqs[i] + "]";
                    }
                    else
                    {
                        if (App.AllValidationModifications.Any(a => nwseqs[i].Contains(a.Abbreviation)))
                        {
                            if (j == bionnumber + 1)
                            {
                                continue;
                            }
                            updatedseqs = updatedseqs + "[" + nwseqs[i] + "]";
                        }
                        else
                        {
                            for (int ii = 0; ii < nwseqs[i].Length; ii++)
                            {
                                j = j + 1;
                                tempst = Convert.ToString(nwseqs[i][ii]);
                                if (j == bionnumber + 1)
                                {
                                    if (rgxalpha.IsMatch(Convert.ToString(nwseqs[i][ii + 1]))) //Not adding the next item if it is already a mod, preventing to add two modifications to the same amino acid.
                                    {
                                        continue;
                                    }
                                    else
                                    {
                                        tempst = Convert.ToString(nwseqs[i][ii]) + Convert.ToString(nwseqs[i][ii + 1]);
                                    }
                                }
                                if (ii != nwseqs[i].Length - 1)
                                {
                                    if (rgxalpha.IsMatch(Convert.ToString(nwseqs[i][ii + 1])))
                                    {
                                        tempst = Convert.ToString(nwseqs[i][ii]) + Convert.ToString(nwseqs[i][ii + 1]);
                                        ii = ii + 1;
                                    }
                                }
                                if (j == bionnumber)
                                {
                                    updatedseqs = updatedseqs + tempst + "[" + (mass.Contains("-") ? mass : ("+" + mass)) + "]";
                                    j = j + 1;
                                }
                                else
                                {
                                    updatedseqs = updatedseqs + tempst;
                                }
                            }
                        }
                    }
                }
                txtValidateSequenceWithSpectrum.Text = updatedseqs;

            }
        }

        private void dtgridBandYIons_LoadingRow(object sender, DataGridRowEventArgs e)
        {
            e.Row.AllowDrop = true;
        }

        /// <summary>
        /// When the menu item for delete is clicked the modification needs to be deleted
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void mnuitmdtgridBandYIonsDeleteMod_Click(object sender, RoutedEventArgs e)
        {
            if (dtgridBandYIons.SelectedItems.Count > 0)
            {
                if (dtgridBandYIons.SelectedItem != null && dtgridBandYIons.SelectedItem is CalculateBYCZIons.BYCZIons)
                {
                    Regex rgxalpha = new Regex(@"[A-Z]");

                    var bandyions = (dtgridBandYIons.SelectedItem as CalculateBYCZIons.BYCZIons);

                    var allbandyions = (dtgridBandYIons.ItemsSource as List<CalculateBYCZIons.BYCZIons>);

                    allbandyions[bandyions.BionNumber - 1].AminoAcid = rgxalpha.Match(allbandyions[bandyions.BionNumber - 1].AminoAcid).Groups[0].Value;

                    string newsequence = string.Empty;

                    Regex rgx = new Regex(@"[0-9\.\+\-]");

                    Regex rgxnum = new Regex(@"[0-9]");

                    foreach (var item in allbandyions)
                    {
                        if (rgxnum.IsMatch(item.AminoAcid))
                        {
                            newsequence = newsequence + rgxalpha.Match(item.AminoAcid).Groups[0].Value + "[" + (item.AminoAcid.Contains("-") ? ("-" + Regex.Match(item.AminoAcid, @"[\d\.]+$")) : ("+" + Regex.Match(item.AminoAcid, @"[\d\.]+$").Value)) + "]";
                            //newsequence = newsequence + "[" + (item.AminoAcid.Contains("-") ? ("-" + rgx.Match(item.AminoAcid.Replace("-", "")).Groups[0].Value) : ("+" + rgx.Match(item.AminoAcid.Replace("+", "")).Groups[0].Value)) + "]" + rgxalpha.Match(item.AminoAcid).Groups[0].Value;
                        }
                        else if (rgx.IsMatch(item.AminoAcid))
                        {
                            var itms = item.AminoAcid.Split(new char[] { ' ' });
                            newsequence = newsequence + itms[0] + "[" + itms[1] + "]";
                        }
                        else
                        {
                            newsequence = newsequence + item.AminoAcid;
                        }
                    }
                    txtValidateSequenceWithSpectrum.Text = newsequence;
                }
            }
        }

        private void mnuitmPaste_Click(object sender, RoutedEventArgs e)
        {
            txtValidateSequenceWithSpectrum.Text = Clipboard.GetText();

            //if (dtgridBandYIons.ItemsSource == null)
            {
                btnApplyandShowBandYIons_Click(null, null);
            }
        }

        private void mnuitmCut_Click(object sender, RoutedEventArgs e)
        {
            Clipboard.SetText(txtValidateSequenceWithSpectrum.Text);
            txtValidateSequenceWithSpectrum.Text = "";
        }

        private void mnuitmCopy_Click(object sender, RoutedEventArgs e)
        {
            Clipboard.SetText(txtValidateSequenceWithSpectrum.Text);
        }

        /// <summary>
        /// Deleting all the modifications from the textbox
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void mnuitmDeltxtValidateSequenceWithSpectrum_Click(object sender, RoutedEventArgs e)
        {
            //string sequence = txtValidateSequenceWithSpectrum.Text.Replace("(", "").Replace(")", "");

            //string tempseq = string.Empty;

            //foreach (var item in sequence.Split(new char[] { '[', ']' }))
            //{
            //    if (App.AllValidationModifications.Any(a => (a.Abbreviation == item) || ("+" + a.Abbreviation == item) || ("-" + a.Abbreviation == item)))
            //    {

            //    }
            //    else if (Regex.IsMatch(item, @"[0-9\[\]\+\-\.]"))
            //    {

            //    }
            //    else
            //    {
            //        tempseq = tempseq + item;
            //    }
            //}

            //sequence = Regex.Replace(sequence, @"[0-9\[\]\+\-\.]", "");///Removes all the matches which are ., +, -, 0-9 numbers

            txtValidateSequenceWithSpectrum.Text = RemoveAllMods(txtValidateSequenceWithSpectrum.Text); // tempseq;
        }

        string RemoveAllMods(string sequencewithmods)
        {
            string sequence = sequencewithmods.Replace("(", "").Replace(")", "");

            string tempseq = string.Empty;

            if (!sequence.Contains("["))
            {
                return sequence;
            }

            foreach (var item in sequence.Split(new char[] { '[', ']' }))
            {
                if (App.AllValidationModifications.Any(a => (a.Abbreviation == item) || ("+" + a.Abbreviation == item) || ("-" + a.Abbreviation == item)))
                {

                }
                else if (Regex.IsMatch(item, @"[0-9\[\]\+\-\.]"))
                {

                }
                else
                {
                    tempseq = tempseq + item;
                }
            }

            return tempseq;
        }


        private void txtvalidateMass_PreviewTextInput(object sender, TextCompositionEventArgs e)
        {
            if (!char.IsDigit(e.Text, e.Text.Length - 1) && e.Text != "+" && e.Text != "-" && e.Text != ".")
            {
                e.Handled = true;
            }
        }

        private void mnuitmAddnewmod_Click(object sender, RoutedEventArgs e)
        {
            string value = ReturnValue.returnvalue;
            Window newaminoacid = new Window();
            newaminoacid.Height = 140;
            newaminoacid.Width = 440;
            newaminoacid.Owner = this;
            newaminoacid.ResizeMode = ResizeMode.NoResize;
            newaminoacid.Content = new TextBoxSubmit("Enter an Amino Acid");
            newaminoacid.Title = "Amino Acid";
            newaminoacid.WindowStartupLocation = System.Windows.WindowStartupLocation.CenterOwner;
            newaminoacid.Closing += newaminoacid_Closing;
            newaminoacid.Activate();
            newaminoacid.ShowDialog();
        }

        void newaminoacid_Closing(object sender, CancelEventArgs e)
        {
            if (ReturnValue.returnvalue == null || ReturnValue.returnvalue == returnvalue)
                return;

            if (dtgridModificationsList.SelectedItem != null && dtgridModificationsList.SelectedItem is ModificationList)
            {
                var modification = dtgridModificationsList.SelectedItem as ModificationList;
                List<string> values = ReturnValue.returnvalue.Split(new char[] { ',' }).ToList();
                foreach (var item in ReturnValue.returnvalue.Split(new char[] { ',' }))
                {
                    if (App.AllValidationModifications.Where(a => a == modification).Any())
                    {
                        App.AllValidationModifications.Where(a => a == modification).First().AminoAcids.Add(item);
                    }
                }
                UpdateValidationAminoAcidsList(ReturnValue.returnvalue.Split(new char[] { ',' }));
            }
        }

        void UpdateValidationAminoAcidsList(string[] mdlst)
        {
            Properties.Settings.Default.ValidationModificationsListAminoAcids = "";
            foreach (var item in App.AllValidationModifications)
            {
                Properties.Settings.Default.ValidationModificationsList += item.Name + "\t" + item.Mass + "\t" + item.Abbreviation.Trim() + "\t" + string.Join(",", item.AminoAcids) + "\n";
            }
            Properties.Settings.Default.Save();
            addedmnuitem = false;
            mdcurrent = new ModificationList();
            foreach (var item in mdlst)
            {
                MenuItem mnuitm = new MenuItem();
                mnuitm.Header = item;
                mnuitm_Click(mnuitm, null);
            }
        }

        bool addedmnuitem = false;

        ModificationList mdcurrent = new ModificationList();

        private void MenuItem_PreviewMouseMove(object sender, MouseEventArgs e)
        {
            if (dtgridModificationsList.SelectedItem != null && dtgridModificationsList.SelectedItem is ModificationList)
            {
                if (dtgridModificationsList.SelectedItem as ModificationList == mdcurrent)
                {
                    return;
                }
                else
                {
                    addedmnuitem = false;
                }
                if (addedmnuitem) return;
                var modification = dtgridModificationsList.SelectedItem as ModificationList;
                mdcurrent = dtgridModificationsList.SelectedItem as ModificationList;

                mnuitemnewmodification.Items.Clear();
                MenuItem mnnew = new MenuItem();
                mnnew.Header = "New";
                mnnew.Name = "mnuitemnewmodification";
                mnnew.Click += mnuitmAddnewmod_Click;
                mnuitemnewmodification.Items.Add(mnnew);

                if (App.AllValidationModifications.Any(a => a.Name.Trim() == modification.Name.Trim()))
                {
                    for (int i = 0; i < App.AllValidationModifications.Where(a => a.Name.Trim() == modification.Name.Trim()).First().AminoAcids.Count; i++)
                    {
                        MenuItem mnuitm = new MenuItem();
                        mnuitm.Click += mnuitm_Click;
                        mnuitm.Header = App.AllValidationModifications.Where(a => a.Name.Trim() == modification.Name.Trim()).First().AminoAcids[i];
                        mnuitemnewmodification.Items.Add(mnuitm);
                    }
                }
                addedmnuitem = true;
            }
        }

        void mnuitm_Click(object sender, RoutedEventArgs e)
        {
            string AminoAcid = Convert.ToString(((System.Windows.Controls.HeaderedItemsControl)(sender)).Header);
            string sequence = txtValidateSequenceWithSpectrum.Text;
            string mass = string.Empty;
            string abbrv = string.Empty;
            string ab = string.Empty;



            if (dtgridModificationsList.SelectedItem != null && dtgridModificationsList.SelectedItem is ModificationList)
            {
                mass = (dtgridModificationsList.SelectedItem as ModificationList).Mass;
                abbrv = (dtgridModificationsList.SelectedItem as ModificationList).Abbreviation;
                ab = (mass.Contains("-") ? ("-" + abbrv) : ("+" + abbrv));
            }

            if (AminoAcid.ToLower().Contains("n-term"))
            {
                sequence = removemod(sequence, 0, abbrv);
                txtValidateSequenceWithSpectrum.Text = sequence;
                return;
            }

            else if (AminoAcid.ToLower().Contains("c-term"))
            {
                sequence = removemod(sequence, sequence.Length, abbrv);
                txtValidateSequenceWithSpectrum.Text = sequence;
                return;
            }

            int i = 0;
            if (sequence.Contains("]" + AminoAcid))
            {
                foreach (var item in sequence)
                {
                    if (Convert.ToString(item) == AminoAcid)
                    {
                        if (sequence.Substring(i + 1, 1).Contains("["))
                        {
                            sequence = sequence.Substring(0, i + 1) + "[" + ab + "]" + sequence.Substring(i + 1 + ("[" + ab + "]").Length, sequence.Length - (i + 1 + ("[" + ab + "]").Length));
                        }
                        else
                        {
                            if (sequence.Substring(i - 1, 1).Contains("]"))
                            {
                                sequence = removemod(sequence, i, abbrv, true);
                            }
                            else
                            {
                                sequence = removemod(sequence, i, abbrv);
                            }
                            i = i + abbrv.Length + 3;
                        }
                    }
                    i = i + 1;
                }
                txtValidateSequenceWithSpectrum.Text = sequence;
            }
            else
            {
                txtValidateSequenceWithSpectrum.Text = sequence.Replace(AminoAcid, AminoAcid + "[" + ab + "]");
            }
            addedmnuitem = false;
        }

        bool fromautoscantab = false;

        BackgroundWorker bgvalidateseq = new BackgroundWorker();
        bool donewithworker = false;

        private void btnValidateSequenceWithSpectrum_Click(object sender, TextChangedEventArgs e)
        {
            try
            {
                Dispatcher.Invoke((Action)(() =>
                {
                    //DechargerVM.ActivationType = CurrentSpectrum.Activation; 

                    if (txtValidateSequenceWithSpectrum.Text == "")
                    {
                        ClearBYIons();
                        return;
                    }
                    if (ValidateForNumbersandAlphabets(txtValidateSequenceWithSpectrum.Text))
                    {
                        if (txtValidateSequenceWithSpectrum.Text != "")
                        {
                            double parentms = 0;
                            //if (fromautoscantab)
                            {
                                if (dtgridSearchResults.SelectedItem is SearchResult && (SearchResult)dtgridSearchResults.SelectedItem != null)
                                {
                                    var currentmnms = (dtgridSearchResults.SelectedItem as SearchResult).CurntIons.Select(a => a.MonoMass).ToList();
                                    parentms = (dtgridSearchResults.SelectedItem as SearchResult).ParentMass;
                                    CalculateBYCZIons.LocalParentMass = (dtgridSearchResults.SelectedItem as SearchResult).ParentMass;
                                    CalculateandDisplayBandYIons(txtValidateSequenceWithSpectrum.Text, currentmnms, (dtgridSearchResults.SelectedItem as SearchResult).ParentMass);
                                }
                                else
                                {
                                    if (CurrentSpectrum.ParentMass != null)
                                    {
                                        parentms = CurrentSpectrum.ParentMass.Value;
                                        var currentmnms = CurrentIons.Select(a => a.MonoMass).ToList();
                                        CalculateandDisplayBandYIons(txtValidateSequenceWithSpectrum.Text, currentmnms, parentms);
                                    }
                                    else
                                    {
                                        parentms = sequencelength(txtValidateSequenceWithSpectrum.Text);
                                        var currentmnms = CurrentIons.Select(a => a.MonoMass).ToList();
                                        CalculateandDisplayBandYIons(txtValidateSequenceWithSpectrum.Text, currentmnms, parentms);
                                    }
                                }
                            }
                            //else
                            //{
                            //    CalculateandDisplayBandYIons(txtValidateSequenceWithSpectrum.Text);
                            //    parentms = ParentMass;
                            //}
                            lblTheoreticalMass.Content = Math.Round(CalculateBYCZIons.sequencelengthwithmodifications(txtValidateSequenceWithSpectrum.Text) + Molecules.Water, 5);
                            CalculateDeltaMass();
                            if (Math.Abs(Math.Round(CalculateBYCZIons.sequencelengthwithmodifications(txtValidateSequenceWithSpectrum.Text) + Molecules.Water, 5) - Math.Round(parentms, 4)) <= Molecules.Validationtolerance)
                            {
                                lblTheoreticalMass.Foreground = new SolidColorBrush(Colors.Green);
                            }
                            else
                            {
                                lblTheoreticalMass.Foreground = new SolidColorBrush(Colors.Red);
                            }
                            PopulateRedandGreenMarkers(null, true, true);
                        }
                        else if (txtValidateSequenceWithSpectrum.Text == "")
                        {
                            ClearBYIons();
                        }
                    }
                    else
                    {
                    }
                }));
            }
            catch (Exception ex)
            {
                App.Laststacktrace = ex.StackTrace;
                Action throwException = () => { throw ex; };
                Dispatcher.CurrentDispatcher.BeginInvoke(throwException);
            }
        }

        private void btnshowUnimod_Click(object sender, RoutedEventArgs e)
        {
            AllUnimodModifications mods = new AllUnimodModifications(App.uniMods, selectedmod);
            mods.Owner = this;  // mainWindow;
            //mods.Show();
            mods.WindowStartupLocation = System.Windows.WindowStartupLocation.CenterOwner;
            mods.ResizeMode = System.Windows.ResizeMode.NoResize;
            mods.ShowDialog();

        }

        /// <summary>
        /// Add the name, description and monomass to the Properties
        /// </summary>
        /// <param name="interimname"></param>
        /// <param name="description"></param>
        /// <param name="monomass"></param>
        void selectedmod(Modifications selectedmods)
        {
            string validmodificationslist = Properties.Settings.Default.ValidationModificationsList;

            string newvalidationmodificationlist = string.Empty;

            if (!App.AllValidationModifications.Any(a => a.Name.ToLower() == selectedmods.InterimName.ToLower()))
            {
                newvalidationmodificationlist += selectedmods.InterimName + "\t" + selectedmods.Monomass + "\t" + (selectedmods.InterimName.Substring(0, 2) + selectedmods.InterimName.Substring(selectedmods.InterimName.Length - 2, 2)).ToLower() + "\t" + string.Join(",", selectedmods.Sites) + "\n";
                Properties.Settings.Default.ValidationModificationsListAminoAcids += "\n";
            }

            Properties.Settings.Default.ValidationModificationsList = validmodificationslist + newvalidationmodificationlist;

            Properties.Settings.Default.Save();

            PopulateValidateModificationList();
            ClearModificationsList();
            txtvalidateModification.Focus();
        }

        private void mnuitmEditmod_Click(object sender, RoutedEventArgs e)
        {
            if (dtgridModificationsList.SelectedItem != null && dtgridModificationsList.SelectedItem is ModificationList)
            {
                ModificationList md = dtgridModificationsList.SelectedItem as ModificationList;

                Window EditMod = new Window();
                EditMod.Height = 120;
                EditMod.Width = 300;
                EditMod.ResizeMode = ResizeMode.NoResize;
                EditMod.WindowStartupLocation = System.Windows.WindowStartupLocation.CenterOwner;
                EditMod.Title = "Edit Mod";
                EditMod.Activate();
                EditMod.Closed += EditMod_Closed;
                EditMod.Owner = mainWindow;
                EditMod.Content = new EditMod(md.Name, md.Abbreviation, md.Mass);
                EditMod.ShowDialog();
                //e.Handled = true;
            }
        }

        void EditMod_Closed(object sender, EventArgs e)
        {
            if (dtgridModificationsList.SelectedItem != null && dtgridModificationsList.SelectedItem is ModificationList)
            {
                ModificationList md = dtgridModificationsList.SelectedItem as ModificationList;

                List<ModificationList> allmd = App.AllValidationModifications.ToList();

                int i = 0;

                while (i < allmd.Count)
                {
                    if (allmd[i].Name == md.Name)
                    {
                        allmd[i].Name = App.EditMod.Name;
                        allmd[i].Mass = App.EditMod.Mass;
                        allmd[i].Abbreviation = App.EditMod.Abbreviation;
                        break;
                    }
                    i = i + 1;
                }

                App.AllValidationModifications = allmd.ToList();

                UpdateModificationsList();

                //App.AllValidationModifications.r
            }
        }

        private void txtMolecules_PreviewDragOver(object sender, DragEventArgs e)
        {
            e.Handled = true;
        }

        private void dtgridModificationsList1_PreviewMouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            ValidationModificationsrowIndex = GetCurrentRowIndex1(e.GetPosition);

            if (ValidationModificationsrowIndex < 0)
                return;
            dtgridModificationsList1.SelectedIndex = ValidationModificationsrowIndex;
            ismoddragging = true;

            ModificationList selectedmod = dtgridModificationsList1.Items[ValidationModificationsrowIndex] as ModificationList;
            if (selectedmod == null)
                return;

            DragDropEffects dragdropeffects = DragDropEffects.Copy;
            if (DragDrop.DoDragDrop(dtgridModificationsList1, selectedmod, dragdropeffects)
                                != DragDropEffects.None)
            {
                dtgridModificationsList1.SelectedItem = selectedmod;
            }
        }

        int modmatchaacaretIndex = 0;

        private void txtMolecules_Drop(object sender, DragEventArgs e)
        {
            txtMolecules.CaptureMouse();

            txtMolecules.CaretIndex = txtMolecules.GetCharacterIndexFromPoint(Mouse.GetPosition(txtMolecules), true); //Gets the current position of the mouse from which we set the caretindex of the textbox

            modmatchaacaretIndex = txtMolecules.CaretIndex;

            if (((cmbMatchList.SelectedItem) as System.Windows.Controls.ComboBoxItem).Content.ToString() == "DEFAULT")
            {
                BackgroundWorker bgmodmatchlst = new BackgroundWorker();
                bgmodmatchlst.DoWork += bgmodmatchlst_DoWork;
                bgmodmatchlst.RunWorkerAsync();
            }
            else
            {
                AddModtoAminoAcid(modmatchaacaretIndex);
                btnSaveMatchList.IsEnabled = true;
            }
        }

        //void bgmodmatchlst_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        //{

        //}

        void bgmodmatchlst_DoWork(object sender, DoWorkEventArgs e)
        {
            Dispatcher.Invoke((Action)(() =>
                {

                    if (((cmbMatchList.SelectedItem) as System.Windows.Controls.ComboBoxItem).Content.ToString() == "DEFAULT")
                    {
                        string value = ReturnValue.returnvalue;
                        Window newmatchlistvalue1 = new Window();
                        newmatchlistvalue1.Height = 140;
                        newmatchlistvalue1.Width = 440;
                        newmatchlistvalue1.Owner = this;
                        newmatchlistvalue1.ResizeMode = ResizeMode.NoResize;
                        newmatchlistvalue1.Content = new TextBoxSubmit("Enter a new Profile Name");
                        newmatchlistvalue1.Title = "Profile Name";
                        newmatchlistvalue1.WindowStartupLocation = System.Windows.WindowStartupLocation.CenterOwner;
                        newmatchlistvalue1.Closing += newmatchlistvalue1_Closing;
                        newmatchlistvalue1.Activate();
                        newmatchlistvalue1.ShowDialog();
                    }
                }));
        }

        void newmatchlistvalue1_Closing(object sender, CancelEventArgs e)
        {
            if (ReturnValue.returnvalue == null || ReturnValue.returnvalue == returnvalue)
                return;

            if (App.strDictionary.ContainsKey(ReturnValue.returnvalue))
            {
                System.Windows.MessageBox.Show("Entered profile name already exists");
                return;
            }

            App.strDictionary.Add(ReturnValue.returnvalue.Trim(), Properties.Settings.Default.MatchList);

            Properties.Settings.Default.MatchListProfile = clsStringDictionary.Serialize(App.strDictionary);
            Properties.Settings.Default.Save();
            App.SaveorNot = true;

            returnvalue = ReturnValue.returnvalue;
            txtMolecules.Text = Properties.Settings.Default.MatchList;
            LoadAllCurrentMatchList();
            SelectMatchList();
            //modtomatchlist = true;
            if (txtMolecules.Text != "") ///modtomatchlist && 
            {
                AddModtoAminoAcid(modmatchaacaretIndex);
                btnSaveMatchList.IsEnabled = true;
            }
        }

        void AddModtoAminoAcid(int caretindex)
        {
            string mass = string.Empty;

            if (dtgridModificationsList1.SelectedItem != null && dtgridModificationsList1.SelectedItem is ModificationList)
            {
                mass = (dtgridModificationsList1.SelectedItem as ModificationList).Mass.StartsWith("-") ?
                        ("-" + (dtgridModificationsList1.SelectedItem as ModificationList).Abbreviation) :
                        ((dtgridModificationsList1.SelectedItem as ModificationList).Abbreviation); //"+" + 
            }

            string currenttext = txtMolecules.Text;

            int currentaminoacidps = currenttext.Substring(0, caretindex).Split(new char[] { '\n' }).Count() - 1;

            string[] aminoacids = currenttext.Split(new char[] { '\n' });

            string newaminoacidlist = string.Empty;

            for (int i = 0; i <= currentaminoacidps; i++)
            {
                newaminoacidlist = newaminoacidlist + aminoacids[i] + "\n";
            }

            newaminoacidlist = newaminoacidlist + currenttext.Split(new char[] { '\n' })[currenttext.Substring(0, caretindex).Split(new char[] { '\n' }).Count() - 1].Split(new char[] { '\t' }).ElementAt(0)
                + (dtgridModificationsList1.SelectedItem as ModificationList).Abbreviation;

            newaminoacidlist = newaminoacidlist + "\t" + Convert.ToString(Convert.ToDouble(currenttext.Split(new char[] { '\n' })[currenttext.Substring(0, caretindex).Split(new char[] { '\n' }).Count() - 1].Split(new char[] { '\t' }).ElementAt(1)) +
                    Convert.ToDouble((dtgridModificationsList1.SelectedItem as ModificationList).Mass));

            for (int i = currentaminoacidps + 1; i < aminoacids.Length; i++)
            {
                newaminoacidlist = newaminoacidlist + "\n" + aminoacids[i];
            }

            txtMolecules.Text = newaminoacidlist;

            btnSaveMatchList_Click(null, null);
        }

        bool fromautoscanvalidate = false;
        bool fromautovalidate = false; ///Checks if the Validate button is clicked in the auto scan

        private void btnColorValidate_Click(object sender, RoutedEventArgs e)
        {
            SearchResult currentResult = null;

            try
            {
                // Grab the datacontext for the bound parent row
                currentResult = (((FrameworkElement)e.Source).BindingGroup.Owner as FrameworkElement).DataContext as SearchResult;

                tbValidate.DataContext = ((System.Windows.FrameworkElement)e.Source).DataContext as SearchResult;  // set the context of the tab to the selected SearchResult

                SetActivationTypes(currentResult);

                fromautoscanvalidate = true;
                fromautovalidate = true;
                var bgworkercolorvalidate = new BackgroundWorker();
                bgworkercolorvalidate.DoWork += bgworkercolorvalidate_DoWork;
                bgworkercolorvalidate.RunWorkerCompleted += bgworkercolorvalidate_RunWorkerCompleted;

                bgworkercolorvalidate.RunWorkerAsync(currentResult);
            }
            catch (Exception ex)
            {
                string stacktrace = ex.StackTrace;
                if (currentResult != null) stacktrace += "\nSequence Tag: " + currentResult.Sequence + "\t Scan Number: " + scannumbers + "\t Description: " + currentResult.Description;

                App.Laststacktrace = stacktrace;
                Action throwException = () => { throw ex; };
                Dispatcher.CurrentDispatcher.BeginInvoke(throwException);
            }
        }

        /// <summary>
        /// Set Activation Type of the current scan 
        /// </summary>
        void SetActivationTypes(SearchResult currentResult)
        {
            DechargerVM.ActivationType = string.Empty;
            App.ActivationType = string.Empty;
            for (int i = 0; i < currentResult.allspectrums.Count; i++)
            {
                DechargerVM.ActivationType += "," + currentResult.allspectrums[i].Activation;
                App.ActivationType += "," + currentResult.allspectrums[i].Activation;
            }
        }

        void bgworkercolorvalidate_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {

            Dispatcher.Invoke((Action)(() =>
            {
                if (dtgridSearchResults.SelectedItem is SearchResult && (SearchResult)dtgridSearchResults.SelectedItem != null)
                {
                    bsyAutoScanTopProteinResults.IsBusy = false;
                    var item = dtgridSearchResults.SelectedItem as SearchResult;

                    var filename = App.FileName;

                    if (item.ScanNumbers == App.ScanNumber) return;

                    if ((item as SearchResult).ScanNumbers.Contains(","))
                    {
                        fromvalidateautoscan = true;
                        if (filename != null)
                        {
                            DisplayNewSpectrum((item as SearchResult).allspectrums);
                        }
                        else if (DechargerVM.WorkspaceFilename != null)
                        {
                            DisplayNewSpectrumNoFile(dtgridSearchResults.SelectedItem as SearchResult);
                        }
                    }
                    else
                    {
                        fromvalidateautoscan = true;

                        //if (MainWindow.MainViewModel.CurrentFilesLoaded.Contains(MainWindow.MainViewModel.SpectralDataFilename) && MainPointProvider != null)
                        if (filename != null)
                        {
                            var rt = MainPointProvider.RetentionTime(Convert.ToInt32((item as SearchResult).ScanNumbers));
                            DisplayNewSpectrum(rt);
                        }
                        else if (DechargerVM.WorkspaceFilename != null)
                        {
                            DisplayNewSpectrumNoFile(dtgridSearchResults.SelectedItem as SearchResult);
                        }
                    }
                }
            }));
        }

        void bgworkercolorvalidate_DoWork(object sender, DoWorkEventArgs e)
        {
            // exit if the argument is invalid or missing
            if (e == null || e.Argument == null || (e.Argument is SearchResult) == false) return;

            Dispatcher.Invoke((Action)(() =>
            {
                // Dispatcher.Invoke((Action)(() =>
                // {
                bsyAutoScanTopProteinResults.IsBusy = true;
                // }));

                var searchResult = dtgridSearchResults.SelectedItem as SearchResult;
                Dictionary<double, double> crntmnmonomasses = new Dictionary<double, double>();
                //bsyAutoScanTopProteinResults.IsBusy = true;
                //bsyAutoScanTopProteinResults.Content = "Validating";
                //List<Cluster> crntmns = new List<Cluster>();
                //var sqssearch = dtgridSearchResults.SelectedItem as SearchResult;

                //var scannumbers = sqssearch.ScanNumbers.Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);

                ///crntmnmonomasses = FindCrntMonos(scannumbers, sqssearch.ParentZ, dtgridSearchResults.SelectedItem as SequenceSearch); //Get all the current monomasses

                //var protein = dtgridSearchResults.SelectedItem as SearchResult;

                foreach (var crnt in searchResult.CurntIons)
                {
                    crntmnmonomasses.Add(crnt.MonoMass, crnt.Intensity);
                }

                List<PossibleModSequences.PossibleMods> psdms = new List<PossibleModSequences.PossibleMods>();
                string SequenceText = PossibleModSequences.ValidateProteinSequence(searchResult, AminoAcidHelpers.AminoAcids, searchResult.ParentMass, crntmnmonomasses, Properties.Settings.Default.HaveKnownMods, ref psdms);
                txtbxValidateTabAccession.Text = searchResult.Accession;

                lblExperimentalMass.Text = Convert.ToString(Math.Round(searchResult.ParentMass, 4));

                txtbxSequenceScanNumbers.Text = (dtgridSearchResults.SelectedItem as SearchResult).ScanNumbers;
                txtbxSequenceParentZs.Text = (dtgridSearchResults.SelectedItem as SearchResult).Parentz_s;

                CurrentValidatedSequence = searchResult;
                txtbxSequenceSet.Text = searchResult.Sequence;
                BindProteintSequence(SequenceText);
                BindtoValidatedSequences(psdms);
                CalculateTheoreticalMass(SequenceText);
                double bandyionpercent = 0;

                BindBandYIons(SequenceText, ref bandyionpercent, searchResult.ParentMass, crntmnmonomasses.Select(a => a.Key).ToList()); ///protein.CurntIons.Select(a => a.MonoMass).ToList());

                //BindBandYIons(SequenceText, ref bandyionpercent, searchResult.ParentMass, searchResult.CurntIons.Select(a => a.MonoMass).ToList());  // Possible conflict to review
                ((SearchResult)dtgridSearchResults.SelectedItem).BandYIonPercent = bandyionpercent;
                //Dispatcher.Invoke((Action)(() =>
                //{
                tbValidate.Focus();
                //}));

            }));


        }

        /// <summary>
        /// Find Monos based on scannumbers and parent ion
        /// </summary>
        /// <param name="ScanNumbers"></param>
        /// <param name="ParentZ"></param>
        /// <returns></returns>
        Dictionary<double, double> FindCrntMonos(SearchResult sqssearch)
        {
            string[] ScanNumbers = sqssearch.ScanNumbers.Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
            int ParentZ = sqssearch.ParentZ;

            //if (MainWindow.MainViewModel.SpectralDataFilename != null)
            if (MainWindow.MainViewModel.CurrentFilesLoaded.Contains(MainWindow.MainViewModel.SpectralDataFilename) && MainPointProvider != null)
            {
                List<Cluster> crntmns = new List<Cluster>();

                List<DataPoint> CurrentMonoMasses = new List<DataPoint>();
                Dictionary<double, double> crntmnmonomasses = new Dictionary<double, double>();

                foreach (var scan in ScanNumbers)
                {
                    crntmns.AddRange(MainPointProvider.DetectIons(Convert.ToInt32(scan), 1, ParentZ).Where(ion => ion.Score > 100));
                }

                var consolidatedions = SignalProcessor.ConsolidateIons(crntmns);

                crntmns = consolidatedions.ToList();

                foreach (var anIon in crntmns.OrderByDescending(i => i.Score))
                {
                    CurrentMonoMasses.Add(new DataPoint() { XValue = anIon.MonoMass, YValue = anIon.Intensity, ZValue = anIon.Z, Score = anIon.Score });
                }

                for (int i = 0; i < CurrentMonoMasses.Count; i++)
                {
                    if (!crntmnmonomasses.ContainsKey(Convert.ToDouble(CurrentMonoMasses[i].XValue)))
                    {
                        crntmnmonomasses.Add(Convert.ToDouble(CurrentMonoMasses[i].XValue), CurrentMonoMasses[i].YValue);
                    }
                }

                return crntmnmonomasses;
            }
            else if (MainWindow.MainViewModel.WorkspaceFilename != null) ///If there is a XMLFile loaded
            {
                if (sqssearch != null) ///
                {
                    Dictionary<double, double> crntmonomasses = new Dictionary<double, double>();
                    foreach (var crntions in sqssearch.CurntIons)
                    {
                        crntmonomasses.Add(crntions.MonoMass, crntions.Intensity);
                    }
                    return crntmonomasses;
                }
            }
            return new Dictionary<double, double>();
        }



        //private void btnConfirmSequence_Click(object sender, RoutedEventArgs e)
        //{

        //    string filename = DeChargerModel.SpectralDataFilename != null ? DeChargerModel.SpectralDataFilename : DeChargerModel.WorkspaceFilename;

        //    if (filename == null)
        //    {
        //        return;
        //    }

        //    List<SearchResult> sqss = new List<SearchResult>();

        //    try
        //    {
        //        Dispatcher.Invoke((Action)(() =>
        //        {

        //            if (dtgridSearchResults.SelectedItem is SearchResult && (SearchResult)dtgridSearchResults.SelectedItem != null)
        //            {
        //                var curation = new Curation();

        //                //fromautoscantab = true;
        //                var protein = dtgridSearchResults.SelectedItem as SearchResult;
        //                //string SequenceText = txtValidateSequenceWithSpectrum.Text;
        //                //protein.ValidatedSequence = SequenceText;

        //                sqssconfirmed.Add(protein.ScanNumbers);

        //                lblExperimentalMass.Text = Convert.ToString(Math.Round(ParentMass, 4));


        //                //protein.IsConfirmed = true;

        //                Dictionary<double, double> crntmnmonomasses = new Dictionary<double, double>();

        //                string[] scnnmbs = protein.ScanNumbers.Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);

        //                crntmnmonomasses = FindCrntMonos(scnnmbs, protein.ParentZ, dtgridSearchResults.SelectedItem as SearchResult);

        //                List<PossibleModSequences.PossibleMods> psdms = new List<PossibleModSequences.PossibleMods>();
        //                string SequenceText = PossibleModSequences.ValidateProteinSequence(protein, AminoAcidHelpers.AminoAcidMass3, protein.ParentMass, crntmnmonomasses, Properties.Settings.Default.HaveKnownMods, ref psdms);

        //                protein.DeltaMass = protein.ParentMass - Math.Round(CalculateBandYIons.sequencelengthwithmodifications(SequenceText) + Molecules.Water, 5);

        //                protein.ValidatedSequence = SequenceText;

        //                currentparent.ScanNumber = protein.ScanNumbers;



        //                //if (protein.ScanNumbers == currentparent.ScanNumber)
        //                //{
        //                User usr = new User();
        //                protein.User_ID = usr.UserID;
        //                protein.User_Name = usr.DisplayName;
        //                //protein.Date_Time_Curation = DateTime.Now;
        //                curation.CreatedDate = DateTime.Now;
        //                curation.UserName = App.User_Name;
        //                curation.UserID = App.User_Id;
        //                //}

        //                //fromautoscantab = true;

        //                List<SearchResult> VerifiedSequences = new List<SearchResult>();

        //                if (dtgridConfirmedSequences.ItemsSource != null)
        //                {
        //                    foreach (var item in dtgridConfirmedSequences.ItemsSource)
        //                    {
        //                        if ((item as SearchResult).ScanNumbers == currentparent.ScanNumber)
        //                        {
        //                            (item as SearchResult).User_Name = App.User_Name;
        //                            (item as SearchResult).Date_Time_Curation = DateTime.Now;
        //                        }
        //                        VerifiedSequences.Add(item as SearchResult);
        //                    }
        //                }


        //                VerifiedSequences.Add(new SearchResult()
        //                {
        //                    Accession = protein.Accession,
        //                    AllMonomass = protein.AllMonomass,
        //                    allspectrums = protein.allspectrums,
        //                    YellowandGreenTagHits = protein.YellowandGreenTagHits,
        //                    TagFound = protein.TagFound,
        //                    TagForTopProtein = protein.TagForTopProtein,
        //                    TagCount = protein.TagCount,
        //                    AllsqsTags = protein.AllsqsTags,
        //                    Allthesequencetags = protein.Allthesequencetags,
        //                    BlastedTagForTopProtein = protein.BlastedTagForTopProtein,
        //                    BlastpAlignmentLength = protein.BlastpAlignmentLength,
        //                    BlastpPartialMatch = protein.BlastpPartialMatch,
        //                    BlastQueryEnd = protein.BlastQueryEnd,
        //                    BlastQueryStart = protein.BlastQueryStart,
        //                    BlastTag = protein.BlastTag,
        //                    BlastTagEnd = protein.BlastTagEnd,
        //                    BlastTagforTopProtein = protein.BlastTagforTopProtein,
        //                    BlastTagStart = protein.BlastTagStart,
        //                    Checked = protein.Checked,
        //                    Coverage = protein.Coverage,
        //                    CurntIons = protein.CurntIons,
        //                    DeltaMass = protein.DeltaMass,
        //                    Description = protein.Description,
        //                    DirectionofTagforTopProtein = protein.DirectionofTagforTopProtein,
        //                    DontchangePairMatch = protein.DontchangePairMatch,
        //                    DontShowall = protein.DontShowall,
        //                    ExpectValue = protein.ExpectValue,
        //                    InternalMT = protein.InternalMT,
        //                    IsIdentifiedYesNo = protein.IsIdentifiedYesNo,
        //                    Mass = protein.Mass,
        //                    MonomasseswithIntensities = protein.MonomasseswithIntensities,
        //                    MyNumber = protein.MyNumber,
        //                    Notagsforhighlight = protein.Notagsforhighlight,
        //                    PairMatch = protein.PairMatch,
        //                    ParentMass = protein.ParentMass,
        //                    ParentZ = protein.ParentZ,
        //                    Parentz_s = protein.Parentz_s,
        //                    RvrseCurntIons = protein.RvrseCurntIons,
        //                    ScanNumbers = protein.ScanNumbers,
        //                    Sequence = protein.Sequence,
        //                    SequenceID = protein.SequenceID,
        //                    sequencesfordbmatching = protein.sequencesfordbmatching,
        //                    Species = protein.Species,
        //                    ValidatedSequence = protein.ValidatedSequence,
        //                    User_Name = protein.User_Name,
        //                    User_ID = protein.User_ID,
        //                    //Date_Time_Curation = protein.Date_Time_Curation
        //                });

        //                var proteinmonomasses = protein.CurntIons.Select(a => a.MonoMass).ToList();

        //                var bandyions = CalculateBandYIons.CalculateBandYIon(protein.ValidatedSequence, proteinmonomasses, protein.ParentMass, App.AllValidationModifications, Properties.Settings.Default.MatchTolerancePPM, AminoAcidHelpers.AminoAcidMass3);

        //                double bandyionpercent = Math.Round(((double)bandyions.Count(a => a.yioncolor || a.bioncolor) / (double)bandyions.Count) * 100, 2);

        //                ((SearchResult)dtgridSearchResults.SelectedItem).BandYIonPercent = bandyionpercent;

        //                protein.Curations.Add(curation);

        //                List<SearchResult> localsequencesearches = new List<SearchResult>();
        //                localsequencesearches = VerifiedSequences;
        //                //dtgridConfirmedSequences.ItemsSource = null;
        //                //dtgridConfirmedSequences.ItemsSource = localsequencesearches;


        //                //List<SearchResult> sqssearch = new List<SearchResult>();

        //                //foreach (var item in dtgridSearchResults.ItemsSource)
        //                //{
        //                //    sqssearch.Add(item as SearchResult);
        //                //}

        //                //DechargerVM.ProteinView.SortDescriptions.Clear();
        //                //DechargerVM.ProteinView.SortDescriptions.Add(new SortDescription("IsNotConfirmed", ListSortDirection.Ascending));
        //                //DechargerVM.ProteinView.SortDescriptions.Add(new SortDescription("YellowandGreenTagHits", ListSortDirection.Descending));


        //                //DechargerVM.SearchResults = DechargerVM.SearchResults.OrderBy(a => a.IsNotConfirmed).ThenByDescending(a => a.YellowandGreenTagHits);

        //                //dtgridSearchResults.ItemsSource = sqssearch.OrderBy(a => a.IsNotConfirmed).ThenByDescending(a => a.YellowandGreenTagHits).ToList();
        //            }
        //        }));
        //    }
        //    catch (Exception ex)
        //    {
        //        string stacktrace = ex.StackTrace;
        //        stacktrace += (dtgridSearchResults.SelectedItem is SearchResult && (SearchResult)dtgridSearchResults.SelectedItem != null) ?
        //                      ("\nSequence Tag: " + (dtgridSearchResults.SelectedItem as SearchResult).Sequence + "\t Scan Number: " + scannumbers + "\t Description: " + (dtgridSearchResults.SelectedItem as SearchResult).Description) :
        //                      "";

        //        App.Laststacktrace = stacktrace;
        //        Action throwException = () => { throw ex; };
        //        Dispatcher.CurrentDispatcher.BeginInvoke(throwException);
        //    }
        //}


        /// <summary>
        /// Finds all the Monomasses and their respective intensities for a particular scan based on the parent scan.
        /// </summary>
        /// <param name="ScanNumbers"></param>
        /// <param name="ParentZ"></param>
        /// <returns></returns>
        public Dictionary<double, double> FindAlltheMonosWithIntensities(string ScanNumbers, int ParentZ)
        {
            string[] scannumbers = ScanNumbers.Split(new string[] { "," }, StringSplitOptions.RemoveEmptyEntries);

            List<Cluster> lstclusters = new List<Cluster>();

            for (int i = 0; i < scannumbers.Length; i++)
            {
                lstclusters.AddRange(MainPointProvider.DetectIons(Convert.ToInt32(scannumbers[i]), 1, ParentZ).Where(ion => ion.Score > 100));
            }

            List<Cluster> consolidatedions = SignalProcessor.ConsolidateIons(lstclusters, true);

            Dictionary<double, double> crntmnmonomasses = new Dictionary<double, double>();
            for (int i = 0; i < consolidatedions.Count; i++)
            {
                crntmnmonomasses.Add(Convert.ToDouble(consolidatedions[i].MonoMass), consolidatedions[i].Intensity);
            }

            return crntmnmonomasses;
        }



        //private void btnValidateConfirm_Click(object sender = null, RoutedEventArgs e = null)
        //{
        //    //// Basic validation of curation
        //    //if (txtValidateSequenceWithSpectrum.Text == string.Empty)
        //    //{
        //    //    System.Windows.MessageBox.Show("Valid Sequence required.");
        //    //    return;
        //    //}

        //    // Add a new Curation object to the current search result
        //    if (e != null && e.Source is SearchResult)
        //    {
        //        AddConfirmation(e.Source as SearchResult);
        //    }
        //}

        //private void AddConfirmation(SearchResult resultToConfirm)
        //{
        //    string filename = DechargerVM.SpectralDataFilename != null ? DechargerVM.SpectralDataFilename : DechargerVM.WorkspaceFilename;

        //    if (filename == null)
        //    {
        //        return;
        //    }

        //    //List<SearchResult> sqss = new List<SearchResult>();


        //    Dispatcher.Invoke((Action)(() =>
        //    {
        //        lblExperimentalMass.Text = Convert.ToString(Math.Round(ParentMass, 4));
        //        Dictionary<double, double> crntmnmonomasses = new Dictionary<double, double>();

        //        string[] scnnmbs = resultToConfirm.ScanNumbers.Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);

        //        crntmnmonomasses = FindCrntMonos(resultToConfirm);

        //        List<PossibleModSequences.PossibleMods> psdms = new List<PossibleModSequences.PossibleMods>();
        //        string SequenceText = PossibleModSequences.ValidateProteinSequence(resultToConfirm, AminoAcidHelpers.AminoAcidMass3, resultToConfirm.ParentMass, crntmnmonomasses, Properties.Settings.Default.HaveKnownMods, ref psdms);

        //        resultToConfirm.DeltaMass = resultToConfirm.ParentMass - Math.Round(CalculateBYCZIons.sequencelengthwithmodifications(SequenceText) + Molecules.Water, 5);

        //        resultToConfirm.ValidatedSequence = SequenceText;

        //        currentparent.ScanNumber = resultToConfirm.ScanNumbers;

        //        User usr = new User();
        //        //resultToConfirm.User_ID = usr.UserID;
        //        //resultToConfirm.User_Name = usr.DisplayName;

        //        List<SearchResult> VerifiedSequences = new List<SearchResult>();

        //        var proteinmonomasses = resultToConfirm.CurntIons.Select(a => a.MonoMass).ToList();

        //        var bandyions = CalculateBYCZIons.CalculateBYCZIon(resultToConfirm.ValidatedSequence, proteinmonomasses, resultToConfirm.ParentMass, DechargerVM.ActivationType, App.AllValidationModifications, Properties.Settings.Default.MatchTolerancePPM, AminoAcidHelpers.AminoAcidMass3);

        //        double bandyionpercent = Math.Round(((double)bandyions.Count(a => a.yioncolor || a.bioncolor) / (double)bandyions.Count) * 100, 2);

        //        List<SearchResult> localsequencesearches = new List<SearchResult>();

        //        var localsearchresult = DechargerVM.SearchResults.First(a => a.ScanNumbers == currentparent.ScanNumber);

        //        localsearchresult.BandYIonPercent = bandyionpercent;
        //        localsearchresult.DeltaMass = localsearchresult.ParentMass - Math.Round(CalculateBYCZIons.sequencelengthwithmodifications(SequenceText) + Molecules.Water, 5);
        //        localsearchresult.ValidatedSequence = SequenceText;


        //        localsearchresult.User_ID = usr.UserID;
        //        localsearchresult.User_Name = usr.DisplayName;

        //    }));



        //    resultToConfirm.Curations.Add(new Curation()
        //    {
        //        UserID = DechargerVM.CurrentUser.UserID,
        //        UserName = DechargerVM.CurrentUser.DisplayName,
        //        UserEmail = DechargerVM.CurrentUser.EMailAddress.Address,
        //        CreatedDate = DateTime.Now,
        //        IsValid = true,
        //        ValidatedSequence = resultToConfirm.Sequence, // txtValidateSequenceWithSpectrum.Text,
        //        Accession = resultToConfirm.Accession,  // start with the AutoScan values, but keep separate to allow editing
        //        Description = resultToConfirm.Description,
        //        //BandYIonPercent = 0,
        //        //ParentMass = 0
        //    });

        //resultToConfirm.OnPropertyChanged("IsValid");


        //private void CanOverrideCurrentModification()
        //{
        //    Window OverrideCurrentModification = new Window();
        //    OverrideCurrentModification.Height = 120;
        //    OverrideCurrentModification.Width = 440;
        //    OverrideCurrentModification.Owner = this;
        //    OverrideCurrentModification.ResizeMode = System.Windows.ResizeMode.NoResize;
        //    OverrideCurrentModification.Content = new Prompt(BooleanValues.YesorNo, "Warning: A Curated identification for that scan already exists.  Do you want to overwrite? ");
        //    OverrideCurrentModification.Title = "Duplicate identification";
        //    OverrideCurrentModification.WindowStartupLocation = System.Windows.WindowStartupLocation.CenterOwner;
        //    OverrideCurrentModification.Closing += OverrideCurrentModification_Closing;
        //    OverrideCurrentModification.Activate();
        //    OverrideCurrentModification.ShowDialog();
        //}

        //void OverrideCurrentModification_Closing(object sender, CancelEventArgs e)
        //{
        //    if (TrueorFalse.trueorfalse)
        //    {
        //        if (txtbxSequenceScanNumbers.Text != "")
        //        {
        //            CurrentValidatedSequence.ScanNumbers = txtbxSequenceScanNumbers.Text;
        //        }

        //        List<SearchResult> VerifiedSequences = new List<SearchResult>();

        //        if (dtgridConfirmedSequences.ItemsSource != null)
        //        {
        //            foreach (var item in dtgridConfirmedSequences.ItemsSource)
        //            {
        //                if ((item as SearchResult).ScanNumbers == currentparent.ScanNumber)
        //                {
        //                    (item as SearchResult).User_Name = App.User_Name;
        //                    (item as SearchResult).Date_Time_Curation = DateTime.Now;
        //                }
        //                VerifiedSequences.Add(item as SearchResult);
        //            }
        //        }

        //        VerifiedSequences.Remove(VerifiedSequences.First(a => a.ScanNumbers == CurrentValidatedSequence.ScanNumbers));

        //        AddaModifiedSequence();
        //    }
        //}

        //void AddaModifiedSequence(SearchResult CrntSqs = null)
        //{
        //    if (txtbxSequenceSet.Text == null || txtbxSequenceSet.Text == "")
        //    {
        //        return;
        //    }

        //    string currentsqs = PossibleModSequences.RemoveAllMods(txtValidateSequenceWithSpectrum.Text);

        //    bool currentsqsbool = false;

        //    if (currentsqs == initialconfirmedsequence)
        //    {
        //        currentsqsbool = true;
        //    }

        //    User usr = new User();

        //    CurrentValidatedSequence.Sequence = txtbxSequenceSet.Text;
        //    CurrentValidatedSequence.ValidatedSequence = txtValidateSequenceWithSpectrum.Text;
        //    CurrentValidatedSequence.DeltaMass = string.IsNullOrEmpty(Convert.ToString(lblValidationDeltaMass.Content)) ? 0 : Convert.ToDouble(lblValidationDeltaMass.Content);
        //    CurrentValidatedSequence.User_ID = usr.UserID;
        //    CurrentValidatedSequence.User_Name = usr.DisplayName;


        //    if (txtbxSequenceScanNumbers.Text != "")
        //    {
        //        CurrentValidatedSequence.ScanNumbers = txtbxSequenceScanNumbers.Text;
        //    }
        //    CurrentValidatedSequence.Parentz_s = txtbxSequenceParentZs.Text;

        //    if (CurrentValidatedSequence.DeltaMass <= 1.0)
        //    {
        //        CurrentValidatedSequence.Coverage = "Green";
        //    }
        //    else if (CurrentValidatedSequence.DeltaMass > 1.0 && CurrentValidatedSequence.DeltaMass <= 80.00)
        //    {
        //        CurrentValidatedSequence.Coverage = "Orange";
        //    }
        //    else if (CurrentValidatedSequence.DeltaMass > 80.00)
        //    {
        //        CurrentValidatedSequence.Coverage = "Red";
        //    }

        //    List<SearchResult> VerifiedSequences = new List<SearchResult>();
        //    //List<string> scans = new List<string>();

        //    bool verifiedsequence = false;

        //    if (dtgridConfirmedSequences.ItemsSource != null)
        //    {
        //        if (CrntSqs != null)
        //        {
        //            foreach (var item in dtgridConfirmedSequences.ItemsSource)
        //            {
        //                //if ((item as SequenceSearch).ScanNumbers == CrntSqs.ScanNumbers)
        //                //{
        //                //    continue;
        //                //}
        //                if ((item as SearchResult).ScanNumbers == currentparent.ScanNumber)
        //                {
        //                    (item as SearchResult).User_Name = App.User_Name;
        //                    (item as SearchResult).Date_Time_Curation = DateTime.Now;
        //                    (item as SearchResult).User_ID = App.User_Id;
        //                    (item as SearchResult).DuplicateConfirmedSequence = verifiedsequence;
        //                    //verifiedsequence = true;
        //                }

        //                VerifiedSequences.Add(item as SearchResult);
        //            }
        //        }
        //        else
        //        {
        //            foreach (var item in dtgridConfirmedSequences.ItemsSource)
        //            {
        //                if ((item as SearchResult).ScanNumbers == currentparent.ScanNumber)
        //                {
        //                    (item as SearchResult).User_Name = App.User_Name;
        //                    (item as SearchResult).Date_Time_Curation = DateTime.Now;
        //                    (item as SearchResult).User_ID = App.User_Id;
        //                    (item as SearchResult).DuplicateConfirmedSequence = verifiedsequence;
        //                    //verifiedsequence = true;
        //                }
        //                VerifiedSequences.Add(item as SearchResult);
        //            }
        //        }
        //    }

        //    VerifiedSequences.Add(new SearchResult()
        //    {
        //        Accession = currentsqsbool ? CurrentValidatedSequence.Accession : string.Empty,
        //        AllMonomass = CurrentValidatedSequence.AllMonomass,
        //        allspectrums = CurrentValidatedSequence.allspectrums,
        //        YellowandGreenTagHits = CurrentValidatedSequence.YellowandGreenTagHits,
        //        TagFound = CurrentValidatedSequence.TagFound,
        //        TagForTopProtein = CurrentValidatedSequence.TagForTopProtein,
        //        TagCount = CurrentValidatedSequence.TagCount,
        //        AllsqsTags = CurrentValidatedSequence.AllsqsTags,
        //        Allthesequencetags = CurrentValidatedSequence.Allthesequencetags,
        //        BlastedTagForTopProtein = CurrentValidatedSequence.BlastedTagForTopProtein,
        //        BlastpAlignmentLength = CurrentValidatedSequence.BlastpAlignmentLength,
        //        BlastpPartialMatch = CurrentValidatedSequence.BlastpPartialMatch,
        //        BlastQueryEnd = CurrentValidatedSequence.BlastQueryEnd,
        //        BlastQueryStart = CurrentValidatedSequence.BlastQueryStart,
        //        BlastTag = CurrentValidatedSequence.BlastTag,
        //        BlastTagEnd = CurrentValidatedSequence.BlastTagEnd,
        //        BlastTagforTopProtein = CurrentValidatedSequence.BlastTagforTopProtein,
        //        BlastTagStart = CurrentValidatedSequence.BlastTagStart,
        //        Checked = CurrentValidatedSequence.Checked,
        //        Coverage = CurrentValidatedSequence.Coverage,
        //        CurntIons = CurrentValidatedSequence.CurntIons,
        //        DeltaMass = CurrentValidatedSequence.DeltaMass,
        //        Description = currentsqsbool ? CurrentValidatedSequence.Description : string.Empty,
        //        DirectionofTagforTopProtein = CurrentValidatedSequence.DirectionofTagforTopProtein,
        //        DontchangePairMatch = CurrentValidatedSequence.DontchangePairMatch,
        //        DontShowall = CurrentValidatedSequence.DontShowall,
        //        ExpectValue = CurrentValidatedSequence.ExpectValue,
        //        InternalMT = CurrentValidatedSequence.InternalMT,
        //        IsIdentifiedYesNo = CurrentValidatedSequence.IsIdentifiedYesNo,
        //        Mass = CurrentValidatedSequence.Mass,
        //        MonomasseswithIntensities = CurrentValidatedSequence.MonomasseswithIntensities,
        //        MyNumber = CurrentValidatedSequence.MyNumber,
        //        Notagsforhighlight = CurrentValidatedSequence.Notagsforhighlight,
        //        PairMatch = CurrentValidatedSequence.PairMatch,
        //        ParentMass = CurrentValidatedSequence.ParentMass,
        //        ParentZ = CurrentValidatedSequence.ParentZ,
        //        Parentz_s = CurrentValidatedSequence.Parentz_s,
        //        RvrseCurntIons = CurrentValidatedSequence.RvrseCurntIons,
        //        ScanNumbers = CurrentValidatedSequence.ScanNumbers,
        //        Sequence = CurrentValidatedSequence.Sequence,
        //        SequenceID = CurrentValidatedSequence.SequenceID,
        //        sequencesfordbmatching = CurrentValidatedSequence.sequencesfordbmatching,
        //        Species = CurrentValidatedSequence.Species,
        //        ValidatedSequence = CurrentValidatedSequence.ValidatedSequence,
        //        User_Name = CurrentValidatedSequence.User_Name, //App.User_Name,
        //        User_ID = CurrentValidatedSequence.User_ID,
        //        Date_Time_Curation = DateTime.Now //CurrentValidatedSequence.Date_Time_Curation, //DateTime.Now
        //    });


        //    VerifiedSequences = VerifiedSequences.OrderByDescending(a => a.Date_Time_Curation).ToList();

        //    foreach (var sqs in VerifiedSequences)
        //    {
        //        if (sqs.ScanNumbers == currentparent.ScanNumber)
        //        {
        //            sqs.DuplicateConfirmedSequence = verifiedsequence;
        //            verifiedsequence = true;
        //        }
        //    }


        //    List<SearchResult> localsequencesearches = new List<SearchResult>();
        //    localsequencesearches = (VerifiedSequences);
        //    //localsequencesearches = (VerifiedSequences).GroupBy(a => a.ScanNumbers).Select(a => a.First()).ToList();
        //    Dispatcher.Invoke((Action)(() =>
        //    {
        //        tbConfirmedSequenceTab.Focus();
        //        dtgridConfirmedSequences.ItemsSource = null;
        //        dtgridConfirmedSequences.ItemsSource = localsequencesearches;
        //    }));

        //    //CurrentValidatedSequence = new SequenceSearch();

        //}

        private void btnConfirmSequence_Click(object sender, RoutedEventArgs e)
        {
            if (App.Log != null && Properties.Settings.Default.DebugLoggingEnabled) App.Log.WriteEntry("Executing Method " + System.Reflection.MethodBase.GetCurrentMethod().Name, EventLogEntryType.Information);

            // Add a new Curation object to the current search result
            if (e != null && ((System.Windows.FrameworkElement)e.Source).DataContext is SearchResult)
            {
                AddConfirmation(((System.Windows.FrameworkElement)e.Source).DataContext as SearchResult, null, true);
            }
        }

        private void AddConfirmation(SearchResult resultToConfirm, string sequenceWithMods = null, bool fromautoscan = false)
        {
            //if (App.Log != null && Properties.Settings.Default.DebugLoggingEnabled) App.Log.WriteEntry("Executing Method " + System.Reflection.MethodBase.GetCurrentMethod().Name, EventLogEntryType.Information);

            if (App.Log != null && Properties.Settings.Default.DebugLoggingEnabled) App.Log.WriteEntry("Adding Confirmation: \n" + (resultToConfirm == null ? "null" : resultToConfirm.ToString()), EventLogEntryType.Information);

            string filename = DechargerVM.SpectralDataFilename != null ? DechargerVM.SpectralDataFilename : DechargerVM.WorkspaceFilename;

            if (filename == null)
            {
                // Will this ever happen????
                System.Windows.MessageBox.Show("Warning: Confirmation not saved.  Invalid data file?  ", "Invalid file", MessageBoxButton.OK, MessageBoxImage.Warning);

                return;
            }

            List<SearchResult> sqss = new List<SearchResult>();

            Dispatcher.Invoke((Action)(() =>
            {
                try
                {
                    //if (App.Log != null && Properties.Settings.Default.DebugLoggingEnabled) App.Log.WriteEntry("resultToConfirm.ScanNumbers is" + (resultToConfirm.ScanNumbers == null ? "" : " not") + " null", EventLogEntryType.Information);

                    lblExperimentalMass.Text = Convert.ToString(Math.Round(ParentMass, 4));
                    Dictionary<double, double> crntmnmonomasses = new Dictionary<double, double>();

                    string[] scnnmbs = resultToConfirm.ScanNumbers.Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);

                    crntmnmonomasses = FindCrntMonos(resultToConfirm);

                    List<PossibleModSequences.PossibleMods> psdms = new List<PossibleModSequences.PossibleMods>();
                    string SequenceText = PossibleModSequences.ValidateProteinSequence(resultToConfirm, AminoAcidHelpers.AminoAcids, resultToConfirm.ParentMass, crntmnmonomasses, Properties.Settings.Default.HaveKnownMods, ref psdms, fromautoscan);

                    //resultToConfirm.DeltaMass = resultToConfirm.ParentMass - Math.Round(CalculateBYCZIons.sequencelengthwithmodifications(SequenceText) + Molecules.Water, 5);

                    resultToConfirm.ValidatedSequence = SequenceText;

                    currentparent.ScanNumber = resultToConfirm.ScanNumbers;

                    //User usr = new User();
                    //resultToConfirm.User_ID = usr.UserID;
                    //resultToConfirm.User_Name = usr.DisplayName;

                    List<SearchResult> VerifiedSequences = new List<SearchResult>();

                    var proteinmonomasses = resultToConfirm.CurntIons.Select(a => a.MonoMass).ToList();

                    var bandyions = CalculateBYCZIons.CalculateBYCZIon(resultToConfirm.ValidatedSequence, proteinmonomasses, resultToConfirm.ParentMass, CurrentSpectrum.Activation, App.AllValidationModifications, Properties.Settings.Default.MatchTolerancePPM, AminoAcidHelpers.AminoAcids);

                    double bandyionpercent = Math.Round(((double)bandyions.Count(a => a.yioncolor || a.bioncolor) / (double)bandyions.Count) * 100, 2);

                    List<SearchResult> localsequencesearches = new List<SearchResult>();

                    var localsearchresult = DechargerVM.SearchResults.First(a => a.ScanNumbers == currentparent.ScanNumber);

                    localsearchresult.BandYIonPercent = bandyionpercent;
                    //localsearchresult.DeltaMass = 
                    localsearchresult.ValidatedSequence = SequenceText;


                    //localsearchresult. = usr.UserID;
                    //localsearchresult.User_Name = usr.DisplayName;
                }
                catch (Exception ex)
                {
                    System.Windows.MessageBox.Show("An error was encountered when preparing this confirmation.  The Confirmation may have failed.  ", "Confirmation Error", MessageBoxButton.OK, MessageBoxImage.Error);

                    if (App.Log != null) App.Log.WriteEntry("Method " + System.Reflection.MethodBase.GetCurrentMethod().Name + " had an exception: " + ex.Message + "\n\n" + ex.StackTrace, EventLogEntryType.Error);

                    throw ex;
                }
            }));

            try
            {
                resultToConfirm.Curations.Add(new Curation()
                {
                    UserID = Environment.UserName,
                    UserName = Environment.UserName,
                    UserEmail = string.Empty,
                    CreatedDate = DateTime.Now,
                    IsValid = true,
                    ValidatedSequence = sequenceWithMods ?? resultToConfirm.ValidatedSequence, //.Sequence, // txtValidateSequenceWithSpectrum.Text,
                    Accession = resultToConfirm.Accession,  // start with the AutoScan values, but keep separate to allow editing
                    Description = resultToConfirm.Description
                //BandYIonPercent = 0,
                //ParentMass = 0
            });

            }
            catch (Exception ex)
            {
                System.Windows.MessageBox.Show("An error was encountered when adding this confirmation.  The Confirmation may have failed.  ", "Confirmation Error", MessageBoxButton.OK, MessageBoxImage.Error);

                if (App.Log != null) App.Log.WriteEntry("Method " + System.Reflection.MethodBase.GetCurrentMethod().Name + " had an exception: " + ex.Message + "\n\n" + ex.StackTrace, EventLogEntryType.Error);

                throw ex;
            }
            //resultToConfirm.OnPropertyChanged("IsValid");


            DechargerVM.ConfirmedSequencesView.Refresh();  // this is cheating, it should be handled by a property changed notification
            DechargerVM.ProteinView.Refresh();  // this has to be refreshed to updated the state of the confirmed buttons...
        }








        //private void btnConfirmSequence_Click(object sender, RoutedEventArgs e)
        //{
        //    // Add a new Curation object to the current search result
        //    if (e != null && ((System.Windows.FrameworkElement)e.Source).DataContext is SearchResult)
        //    {
        //        AddConfirmation(((System.Windows.FrameworkElement)e.Source).DataContext as SearchResult);
        //    }
        //}

        //private void AddConfirmation(SearchResult resultToConfirm, string sequenceWithMods = null)
        //{
        //    string filename = DechargerVM.SpectralDataFilename != null ? DechargerVM.SpectralDataFilename : DechargerVM.WorkspaceFilename;

        //    if (filename == null)
        //    {
        //        // Will this ever happen????
        //        System.Windows.MessageBox.Show("Warning: Confirmation not saved.  Invalid data file?  ", "Invalid file", MessageBoxButton.OK, MessageBoxImage.Warning);

        //        return;
        //    }

        //    List<SearchResult> sqss = new List<SearchResult>();


        //    //Dispatcher.Invoke((Action)(() =>
        //    //{
        //    //    lblExperimentalMass.Text = Convert.ToString(Math.Round(ParentMass, 4));
        //    //    Dictionary<double, double> crntmnmonomasses = new Dictionary<double, double>();

        //    //    string[] scnnmbs = resultToConfirm.ScanNumbers.Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);

        //    //    crntmnmonomasses = FindCrntMonos(resultToConfirm);

        //    //    List<PossibleModSequences.PossibleMods> psdms = new List<PossibleModSequences.PossibleMods>();
        //    //    string SequenceText = PossibleModSequences.ValidateProteinSequence(resultToConfirm, AminoAcidHelpers.AminoAcidMass3, resultToConfirm.ParentMass, crntmnmonomasses, Properties.Settings.Default.HaveKnownMods, ref psdms);

        //    //    resultToConfirm.DeltaMass = resultToConfirm.ParentMass - Math.Round(CalculateBYCZIons.sequencelengthwithmodifications(SequenceText) + Molecules.Water, 5);

        //    //    resultToConfirm.ValidatedSequence = SequenceText;

        //    //    currentparent.ScanNumber = resultToConfirm.ScanNumbers;

        //    //    User usr = new User();
        //    //    //resultToConfirm.User_ID = usr.UserID;
        //    //    //resultToConfirm.User_Name = usr.DisplayName;

        //    //    var proteinmonomasses = resultToConfirm.CurntIons.Select(a => a.MonoMass).ToList();

        //    //    var bandyions = CalculateBYCZIons.CalculateBYCZIon(resultToConfirm.ValidatedSequence, proteinmonomasses, resultToConfirm.ParentMass, DechargerVM.ActivationType, App.AllValidationModifications, Properties.Settings.Default.MatchTolerancePPM, AminoAcidHelpers.AminoAcidMass3);

        //    //    double bandyionpercent = Math.Round(((double)bandyions.Count(a => a.yioncolor || a.bioncolor) / (double)bandyions.Count) * 100, 2);

        //    //    List<SearchResult> localsequencesearches = new List<SearchResult>();

        //    //    var localsearchresult = DechargerVM.SearchResults.First(a => a.ScanNumbers == currentparent.ScanNumber);

        //    //    localsearchresult.BandYIonPercent = bandyionpercent;
        //    //    localsearchresult.DeltaMass = localsearchresult.ParentMass - Math.Round(CalculateBYCZIons.sequencelengthwithmodifications(SequenceText) + Molecules.Water, 5);
        //    //    localsearchresult.ValidatedSequence = SequenceText;


        //    //    //localsearchresult.User_ID = usr.UserID;
        //    //    //localsearchresult.User_Name = usr.DisplayName;

        //    //}));



        //    resultToConfirm.Curations.Add(new Curation()
        //    {
        //        UserID = DechargerVM.CurrentUser.UserID,
        //        UserName = DechargerVM.CurrentUser.DisplayName,
        //        UserEmail = DechargerVM.CurrentUser.EMailAddress.Address,
        //        CreatedDate = DateTime.Now,
        //        IsValid = true,
        //        ValidatedSequence = sequenceWithMods ?? resultToConfirm.Sequence, // txtValidateSequenceWithSpectrum.Text,
        //        Accession = resultToConfirm.Accession,  // start with the AutoScan values, but keep separate to allow editing
        //        Description = resultToConfirm.Description,
        //        ScanNumbers = resultToConfirm.ScanNumbers,
        //        //BandYIonPercent = 0,
        //        //ParentMass = 0
        //    });

        //    //resultToConfirm.OnPropertyChanged("IsValid");

        //    DechargerVM.ConfirmedSequencesView.Refresh();  // this is cheating, it should be handled by a property changed notification
        //    DechargerVM.ProteinView.Refresh();  // this has to be refreshed to updated the state of the confirmed buttons...
        //}


        /// <summary>
        /// Validate the current sequence in the validate tab
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void btnValidateConfirm_Click(object sender, RoutedEventArgs e)
        {
            if (App.Log != null && Properties.Settings.Default.DebugLoggingEnabled) App.Log.WriteEntry("Executing Method " + System.Reflection.MethodBase.GetCurrentMethod().Name, EventLogEntryType.Information);

            if (txtValidateSequenceWithSpectrum.Text == string.Empty)
            {
                System.Windows.MessageBox.Show("Valid Sequence required.");
                return;
            }

            // Add a new Curation object to the current search result.  Ideally, we should get the search result from the data context of the validate tab
            if (DechargerVM.LastSelectedItem != null) // && ((System.Windows.FrameworkElement)e.Source).DataContext is SearchResult)
                if (tbValidate.DataContext is SearchResult)
                {
                    var theSearchResult = tbValidate.DataContext as SearchResult; //DechargerVM.LastSelectedItem;

                    if (theSearchResult.Curations.Any())
                    {
                        var messageboxresult = System.Windows.MessageBox.Show("Warning: A Curated identification for that scan already exists.  Do you want to overwrite?", "Duplicate identification", MessageBoxButton.YesNo, MessageBoxImage.Question);

                        if (messageboxresult == MessageBoxResult.No) return;  // do nothing! 
                    }

                    AddConfirmation(theSearchResult, txtValidateSequenceWithSpectrum.Text);
                }

        }

        /// <summary>
        /// Add the current sequence from the Validate tab to Confirmed Sequence Tab.
        /// </summary>
        void ConfirmCurrentSequencefromValidateTab()
        {
            Dispatcher.Invoke((Action)(() =>
            {
                var resultToConfirm = DechargerVM.SearchResults.First(a => a.ScanNumbers == currentparent.ScanNumber);

                //sqssconfirmed.Add(currentparent.ScanNumber);
                //SearchResult temporarysqssrch = new SearchResult();
                //var localvalidatedsequence = DechargerVM.SearchResults.First(a => a.ScanNumbers == currentparent.ScanNumber);
                ////var resultToConfirm = localvalidatedsequence;

                //txtbxSequenceParentZs.Text = App.ParentDetails != null ? Convert.ToString(App.ParentDetails.ParentZ) : "";
                //localvalidatedsequence.Parentz_s = txtbxSequenceParentZs.Text;

                //txtbxSequenceScanNumbers.Text = App.ParentDetails != null ? App.ParentDetails.ScanNumber : "";
                //localvalidatedsequence.ScanNumbers = txtbxSequenceScanNumbers.Text;


                //User usr = new User();

                //localvalidatedsequence.ParentMass = string.IsNullOrEmpty(lblExperimentalMass.Text) ? 0 : Math.Round(Convert.ToDouble(lblExperimentalMass.Text), 4);
                //localvalidatedsequence.BandYIonPercent = (lblbandyionpercentagehidden.Content != null && lblbandyionpercentagehidden.Content != "") ? Convert.ToDouble(lblbandyionpercentagehidden.Content) : 0;
                //localvalidatedsequence.ValidatedSequence = txtValidateSequenceWithSpectrum.Text;
                //localvalidatedsequence.User_ID = usr.UserID;
                //localvalidatedsequence.User_Name = usr.DisplayName;

                //if (localvalidatedsequence.BandYIonPercent == 0)
                //{
                //    var tempIonsInternal = new List<Cluster>();

                //    string[] splitstring = { "," };

                //    var splitscannumbers = localvalidatedsequence.ScanNumbers.Split(splitstring, StringSplitOptions.RemoveEmptyEntries);

                //    foreach (var scannumber in splitscannumbers)
                //    {
                //        tempIonsInternal.AddRange(MainPointProvider.DetectIons(Convert.ToInt32(scannumber), 1, (App.ParentDetails.ParentZ.HasValue ? App.ParentDetails.ParentZ.Value : 30)).Where(ion => ion.Score > 100));
                //    }
                //    var consolidatedIons = SignalProcessor.ConsolidateIons(tempIonsInternal);
                //    localvalidatedsequence.CurntIons = consolidatedIons;
                //}


                resultToConfirm.Curations.Add(new Curation()
                {
                    UserID = Environment.UserName,
                    UserName = Environment.UserName,
                    UserEmail = string.Empty,
                    CreatedDate = DateTime.Now,
                    IsValid = true,
                    ValidatedSequence = resultToConfirm.Sequence, // txtValidateSequenceWithSpectrum.Text,
                    Accession = resultToConfirm.Accession,  // start with the AutoScan values, but keep separate to allow editing
                    Description = resultToConfirm.Description,
                });


                DechargerVM.ConfirmedSequencesView.Refresh();  // this is cheating, it should be handled by a property changed notification
                DechargerVM.ProteinView.Refresh();  // this has to be refreshed to updated the state of the confirmed buttons...
                //tbConfirmedSequenceTab.Focus();
            }));
        }



        private void btnProteinVerifyCurrentSequence_Click(object sender, RoutedEventArgs e)
        {
            if (App.Log != null && Properties.Settings.Default.DebugLoggingEnabled) App.Log.WriteEntry(System.Reflection.MethodBase.GetCurrentMethod().Name, EventLogEntryType.Information);

            try
            {
                CurrentValidatedSequence = (SearchResult)dtgrdSearchSequence.SelectedItem;
                if (dtgrdSearchSequence.SelectedItem is SearchResult && (SearchResult)dtgrdSearchSequence.SelectedItem != null && ((SearchResult)dtgrdSearchSequence.SelectedItem).CoveredSequence != null && ((SearchResult)dtgrdSearchSequence.SelectedItem).CoveredSequence != "")
                {
                    var protein = dtgrdSearchSequence.SelectedItem as SearchResult;

                    lblExperimentalMass.Text = Convert.ToString(Math.Round(protein.ParentMass, 4));
                    Dictionary<double, double> crntmnmonomasses = new Dictionary<double, double>();
                    for (int i = 0; i < CurrentMonoMasses.Count; i++)
                    {
                        if (crntmnmonomasses.ContainsKey(Convert.ToDouble(CurrentMonoMasses[i].XValue)))
                        {
                            continue;
                        }
                        crntmnmonomasses.Add(Convert.ToDouble(CurrentMonoMasses[i].XValue), CurrentMonoMasses[i].YValue);
                    }

                    List<PossibleModSequences.PossibleMods> psdms = new List<PossibleModSequences.PossibleMods>();

                    if (protein.ParentMass == 0)
                    {
                        return;
                    }

                    if (crntmnmonomasses != null && crntmnmonomasses.Count == 0)
                    {
                        return;
                    }

                    string SequenceText = PossibleModSequences.ValidateProteinSequence(protein, AminoAcidHelpers.AminoAcids, protein.ParentMass, crntmnmonomasses, Properties.Settings.Default.HaveKnownMods, ref psdms, false, CurrentSpectrum.Activation);
                    Dispatcher.Invoke((Action)(() =>
                    {
                        BindProteintSequence(SequenceText);
                        btnshowmorevalidations.Visibility = System.Windows.Visibility.Hidden;
                        BindtoValidatedSequences(psdms);
                        CalculateTheoreticalMass(SequenceText);
                        txtbxSequenceSet.Text = protein.Sequence;
                        double bandyionpercent = 0;
                        BindBandYIons(SequenceText, ref bandyionpercent, protein.ParentMass, crntmnmonomasses.Select(a => a.Key).ToList());
                        tbValidate.Focus();
                        ((SearchResult)dtgrdSearchSequence.SelectedItem).BandYIonPercent = bandyionpercent;
                        //fromautoscantab = true;
                    }));
                }
            }
            catch (Exception ex)
            {
                string exp = ex.Message;
                int eeeeeeee = exp.Length;
                double eee = Math.Sqrt(eeeeeeee);
            }
        }

        /// <summary>
        /// Export all the Columns to an excel document
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void btnCnfrmdSqExporttoExcel_Click(object sender, RoutedEventArgs e)
        {
            // Ideally, we want to have a function that takes any datagrid and dumps it to Excel.  
            // What we see on screen is what we should get in Excel

            // dtgridConfirmedSequences

            if (DechargerVM.ConfirmedSequencesView.IsEmpty) return;

            List<string> AllHeaders = new List<string>();

            //Create the header columns
            AllHeaders.Add("Scan(s)");
            AllHeaders.Add("Mass");
            AllHeaders.Add("Z");
            AllHeaders.Add("Tag");
            AllHeaders.Add("Accession");
            AllHeaders.Add("Description");
            AllHeaders.Add("Start");
            AllHeaders.Add("End");
            AllHeaders.Add("Hits");
            AllHeaders.Add("Delta Mass");
            AllHeaders.Add("Average Error");
            AllHeaders.Add("BandYIonPercent");
            AllHeaders.Add("Sequence");

            //var ListConfirmedSequences = dtgridConfirmedSequences.ItemsSource as List<SearchResult>;

            List<List<string>> columns = new List<List<string>>();

            List<string> column = new List<string>();
            //Create the rest of columns
            //for (int i = 0; i < ListConfirmedSequences.Count; i++)
            foreach (SearchResult aResult in DechargerVM.ConfirmedSequencesView)
            {
                column = new List<string>();
                column.Add(string.Join(" , ", aResult.ScanNumbers.Split(',')));
                column.Add(Convert.ToString(Math.Round(aResult.ParentMass, 3)));
                column.Add(Convert.ToString(aResult.ParentZ));
                column.Add(aResult.BlastTagforTopProtein);
                column.Add(Convert.ToString(aResult.Accession));
                column.Add(aResult.Description);
                column.Add(Convert.ToString(aResult.Start));
                column.Add(Convert.ToString(aResult.End));
                column.Add(Convert.ToString(aResult.YellowandGreenTagHits));
                column.Add(Convert.ToString(Math.Round(aResult.DeltaMass, 3)));
                column.Add(Convert.ToString(Math.Round(aResult.AverageErrors, 3)));
                column.Add(Convert.ToString(Math.Round(aResult.BandYIonPercent, 3)));
                column.Add(aResult.ValidatedSequence);
                columns.Add(column);
            }

            ExportToExcel.ExportToexcel(AllHeaders, columns);

        }

        private void mnuExporttoExcel_Click(object sender, RoutedEventArgs e)
        {

            Dictionary<string, string> sequencenumbers = new Dictionary<string, string>(); ///Scan numbers of all the scans in the Auto Scan tab.

            List<SearchResult> SearchSequences = new List<SearchResult>();

            if (dtgridSearchResults.ItemsSource != null) //If the Autoscan tab is empty don't loop through.
            {
                foreach (var item in dtgridSearchResults.ItemsSource)
                {
                    if (item is SearchResult)
                    {
                        SearchSequences.Add(item as SearchResult);
                    }
                }
            }

            if (SearchSequences != null)
            {
                List<string> AllHeaders = new List<string>();

                AllHeaders.Add("Scan(s)");
                AllHeaders.Add("Mass");
                AllHeaders.Add("Z");
                AllHeaders.Add("Tag");
                AllHeaders.Add("Description");
                AllHeaders.Add("Start");
                AllHeaders.Add("End");
                AllHeaders.Add("tStart");
                AllHeaders.Add("tEnd");
                AllHeaders.Add("Hits");
                AllHeaders.Add("Delta Mass");
                AllHeaders.Add("Sequence");

                List<List<string>> columns = new List<List<string>>();

                List<string> column = new List<string>();

                for (int i = 0; i < SearchSequences.Count; i++)
                {
                    if (SearchSequences[i].InternalMT != null && SearchSequences[i].InternalMT.Count != 0 && SearchSequences[i].YellowandGreenTagHits != 0)
                    {
                        column = new List<string>();
                        column.Add(string.Join(" , ", SearchSequences[i].ScanNumbers.Split(',')));
                        column.Add(Convert.ToString(Math.Round(SearchSequences[i].ParentMass, 3)));
                        column.Add(Convert.ToString(SearchSequences[i].ParentZ));
                        column.Add(SearchSequences[i].BlastTagforTopProtein);
                        column.Add(SearchSequences[i].Description);
                        column.Add(Convert.ToString(SearchSequences[i].Start));
                        column.Add(Convert.ToString(SearchSequences[i].End));
                        column.Add(Convert.ToString(SearchSequences[i].tStart));
                        column.Add(Convert.ToString(SearchSequences[i].tEnd));
                        column.Add(Convert.ToString(SearchSequences[i].YellowandGreenTagHits));
                        column.Add(Convert.ToString(Math.Round(SearchSequences[i].DeltaMassVersusProtein, 3)));
                        column.Add(SearchSequences[i].Sequence);
                        columns.Add(column);
                    }
                }
                ExportToExcel.ExportToexcel(AllHeaders, columns);
            }
        }

        /// <summary>
        /// Exporting the Proteins table to an excel file
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void mnuProteinsExporttoExcel_Click(object sender, RoutedEventArgs e)
        {
            if (dtgrdSearchSequence.ItemsSource is List<SearchResult>)
            {
                List<string> AllHeaders = new List<string>();

                AllHeaders.Add("Accession");
                AllHeaders.Add("Description");
                AllHeaders.Add("Species");
                AllHeaders.Add("Expect");
                AllHeaders.Add("Start");
                AllHeaders.Add("End");
                AllHeaders.Add("Hits");
                AllHeaders.Add("Delta Mass");
                AllHeaders.Add("PPM");
                AllHeaders.Add("Sequences");

                var ListConfirmedSequences = dtgrdSearchSequence.ItemsSource as List<SearchResult>;

                List<List<string>> columns = new List<List<string>>();

                List<string> column = new List<string>();

                for (int i = 0; i < ListConfirmedSequences.Count; i++)
                {
                    column = new List<string>();

                    column.Add(ListConfirmedSequences[i].Accession);
                    column.Add(ListConfirmedSequences[i].Description);
                    column.Add(ListConfirmedSequences[i].Species);
                    column.Add(Convert.ToString(ListConfirmedSequences[i].ExpectValue));
                    column.Add(Convert.ToString(ListConfirmedSequences[i].Start));
                    column.Add(Convert.ToString(ListConfirmedSequences[i].End));
                    column.Add(Convert.ToString(ListConfirmedSequences[i].YellowandGreenTagHits));
                    column.Add(Convert.ToString(ListConfirmedSequences[i].DeltaMassVersusProtein));
                    column.Add(Convert.ToString(ListConfirmedSequences[i].PPM));
                    column.Add(ListConfirmedSequences[i].Sequence);

                    columns.Add(column);
                }

                ExportToExcel.ExportToexcel(AllHeaders, columns);
            }
        }

        private void mnuDeleteAllConfirmedSequences_Click(object sender, RoutedEventArgs e)
        {
            //sqssconfirmed.Clear();
            //if (App.ScanNumber == null)
            //{
            //    return;
            //}

            //if (dtgridConfirmedSequences.ItemsSource is List<SearchResult>)
            //{
            Window DeleteAllConfirmedSequencesornot = new Window();
            DeleteAllConfirmedSequencesornot.Height = 120;
            DeleteAllConfirmedSequencesornot.Width = 440;
            DeleteAllConfirmedSequencesornot.Owner = this;
            DeleteAllConfirmedSequencesornot.ResizeMode = System.Windows.ResizeMode.NoResize;
            DeleteAllConfirmedSequencesornot.Content = new Prompt(BooleanValues.YesorNo, "Do you want to delete all the Confirmed Sequences?");
            DeleteAllConfirmedSequencesornot.Title = "Delete All Confirmed Sequences?";
            DeleteAllConfirmedSequencesornot.WindowStartupLocation = System.Windows.WindowStartupLocation.CenterOwner;
            DeleteAllConfirmedSequencesornot.Closing += DeleteAllConfirmedSequencesornot_Closing;
            DeleteAllConfirmedSequencesornot.Activate();
            DeleteAllConfirmedSequencesornot.ShowDialog();
            //}
        }

        void DeleteAllConfirmedSequencesornot_Closing(object sender, CancelEventArgs e)
        {
            if (TrueorFalse.trueorfalse)
            {
                // Delete Valid Curations?  
                foreach (var aResult in DechargerVM.SearchResults)
                {
                    // instead of deleting the curations, just mark as no longer valid...
                    //aResult.Curations.ForEach(c => c.IsValid = false);
                    foreach (var aCuration in aResult.Curations) aCuration.IsValid = false;
                }

                DechargerVM.ConfirmedSequencesView.Refresh();  //TODO: This is cheating, it should be automatically updated by a property changed event...
                DechargerVM.ProteinView.Refresh();

            }
        }

        private void mnuDeleteOneConfirmedSequence_Click(object sender, RoutedEventArgs e)
        {
            if (e != null && (((MSViewer.DeChargerViewModel)((System.Windows.FrameworkElement)e.Source).DataContext).LastSelectedItem) is SearchResult)
            {

                DechargerVM.LastSelectedItem.LastCuration.IsValid = false;

                DechargerVM.ConfirmedSequencesView.Refresh();  //TODO: This is cheating, it should be automatically updated by a property changed event...
                DechargerVM.ProteinView.Refresh();
            }
        }

        static SetParentMass setprntms = new SetParentMass();


        private void btnSetManualParentMass_Click(object sender, RoutedEventArgs e)
        {
            SetManualParentMass();
        }

        void SetManualParentMass()
        {
            if (App.ScanNumber == null)
                return;
            Window stprnt = new Window();
            if (CurrentSpectrum.ParentIon == null)
            {
                stprnt.Content = new SetParentMass();
            }
            else
            {
                stprnt.Content = new SetParentMass(CurrentSpectrum.ParentCharge.Value, CurrentSpectrum.ParentIon.MonoMass, CurrentSpectrum.ParentIon.MonoMZ);
            }
            SetParentMass.SetParentM.SaveParentOrNot = false;
            stprnt.Title = "Parent Mass";
            stprnt.Height = 220;
            stprnt.Width = 320;
            stprnt.ResizeMode = ResizeMode.NoResize;
            stprnt.Closed += stprnt_Closed;
            stprnt.Owner = this;
            stprnt.WindowStartupLocation = System.Windows.WindowStartupLocation.CenterOwner;
            stprnt.Activate();
            stprnt.ShowDialog();
        }



        void stprnt_Closed(object sender, EventArgs e)
        {
            if (SetParentMass.SetParentM.SaveParentOrNot)
            {
                if (CurrentSpectrum.ParentIon == null)
                {
                    CurrentSpectrum.ParentIon = new Cluster();
                    if (CurrentIons.Count > 0)
                    {
                        CurrentSpectrum.ParentIon.Intensity = CurrentIons.Max(a => a.Intensity);
                    }
                    else
                    {
                        CurrentSpectrum.ParentIon.Intensity = 5000;
                    }
                }
                if (mgrspectra != null)
                {
                    if (mgrspectra.Any(a => a.ScanNumber == CurrentSpectrum.ScanNumber))
                    {
                        var prnt = new Cluster();
                        prnt.Z = SetParentMass.ParentMass.Charge;
                        prnt.MonoMZ = SetParentMass.ParentMass.ParentMZ;
                        prnt.MonoMass = SetParentMass.ParentMass.Mass;
                        if (CurrentSpectrum.Any())
                        {
                            prnt.Intensity = CurrentSpectrum.MaxBy(a => a.Intensity).Intensity;
                        }
                        else
                        {
                            prnt.Intensity = 5000;
                        }
                        mgrspectra.Where(a => a.ScanNumber == CurrentSpectrum.ScanNumber).First().ParentIon = prnt;

                        mgrspectra.Where(a => a.ScanNumber == CurrentSpectrum.ScanNumber).First().ParentMass = SetParentMass.ParentMass.Mass;
                        mgrspectra.Where(a => a.ScanNumber == CurrentSpectrum.ScanNumber).First().ParentZ = SetParentMass.ParentMass.Charge;
                    }
                }
                else
                {
                    mgrspectra = new ObservableCollection<SpectrumInfo>();
                    InitialParentMassSetup(Convert.ToInt32(App.ScanNumber));
                }
                addparentmassfromMergeSpectra = true;
                currentparent.ParentZ = SetParentMass.ParentMass.Charge;
                CurrentSpectrum.ScanNumber = App.ScanNumber.Contains(",") ? 0 : Convert.ToInt32(App.ScanNumber);
                CurrentSpectrum.ParentIon.MonoMass = SetParentMass.ParentMass.Mass;
                CurrentSpectrum.ParentMZ = SetParentMass.ParentMass.ParentMZ;
                CurrentSpectrum.ParentIon.MonoMZ = SetParentMass.ParentMass.ParentMZ;
                CurrentSpectrum.ParentIon.Description = "MZ = " + SetParentMass.ParentMass.ParentMZ + "\nZ = " + SetParentMass.ParentMass.Charge;
                CurrentSpectrum.ParentMass = SetParentMass.ParentMass.Mass;
                ParentMass = SetParentMass.ParentMass.Mass;
                SetParentManual();
            }
        }

        void SetParentManual()
        {
            BackgroundWorker bgsetparentmassmanual = new BackgroundWorker();
            bgsetparentmassmanual.DoWork += bgsetparentmassmanual_DoWork;
            bgsetparentmassmanual.RunWorkerCompleted += bgsetparentmassmanual_RunWorkerCompleted;
            bgsetparentmassmanual.RunWorkerAsync();
        }

        void bgsetparentmassmanual_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            try
            {
                Dispatcher.Invoke(new Action(() =>
                {
                    grdMerge1.Items.Refresh();
                }));
            }
            catch (Exception exxxx)
            {

            }
        }

        void bgsetparentmassmanual_DoWork(object sender, DoWorkEventArgs e)
        {
            Dispatcher.Invoke(new Action(() =>
            {
                ParentMonoSeries.DataSource = new Cluster[] { CurrentSpectrum.ParentIon };

                setdbmonointensity = CurrentSpectrum.ParentIon.Intensity != null ? CurrentSpectrum.ParentIon.Intensity : CurrentSpectrum.MaxBy(a => a.Intensity).Intensity;

                CurrentSpectrum.Title += " (" + CurrentSpectrum.ParentIon.MonoMass.ToString("0.000") + ") ";

                double min = 0;
                double max = CurrentSpectrum.ParentMass.Value;

                min = min - (max - min) * 0.035;  // This gives us a buffer on the ends of the X axis
                max = max + (max - min) * 0.035;  // This gives us a buffer on the ends of the X axis

                CurrentSpectrum.Add(new ClusterPeak() { Mass = min, Intensity = 0 });
                CurrentSpectrum.Add(new ClusterPeak() { Mass = max, Intensity = 0 });

                BottomChart.AxesX[0].AxisMinimum = min;
                BottomChart.AxesX[0].AxisMaximum = max;

                ZeroMonomass zm = new ZeroMonomass();
                zm.Intensity = CurrentSpectrum.ParentIon.Intensity;
                zm.MonoMass = 0;
                ZeroSeries.DataSource = new ZeroMonomass[] { zm };
                setdbmonointensity = CurrentSpectrum.ParentIon.Intensity;

                var reverseions = (from d in CurrentSpectrum.Where(a => a.Mass <= CurrentSpectrum.ParentMass)
                                   select new ClusterPeak
                                   {
                                       Parent = d.Parent,
                                       Intensity = d.Intensity,
                                       MZ = d.MZ,
                                       //Z = d.Z,
                                       Delta = d.Delta,
                                       IsCorePeak = d.IsCorePeak,
                                       Mass = CurrentSpectrum.ParentMass.Value - d.Mass
                                   });
                ReverseCurrentSpectrum = new Spectrum(reverseions);
                ReverseSeries.DataSource = ReverseCurrentSpectrum.Range(min, max, (int)BottomChart.AxesX[0].ActualWidth * (Properties.Settings.Default.HighBin ? 2 : 1));

                BottomChart.AxesX[0].Zoom(min, max, min, max);

                BottomChart.AxesX[0].AxisMinimum = min;
                BottomChart.AxesX[0].AxisMaximum = max;

                string currenttitle = CurrentSpectrum.Title;
                if (currenttitle.IndexOf("(") > -1)
                {
                    currenttitle = currenttitle.Substring(0, currenttitle.IndexOf("(") - 1);
                }

                currenttitle += "(" + CurrentSpectrum.ParentMass.Value + ")";
                CurrentSpectrum.Title = currenttitle;
                BottomChart.Titles[0].Text = CurrentSpectrum.Title;
            }));
        }

        /// <summary>
        /// Add ParentMass to all the MSMS spectra
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void btnmrgspecSetParentMass_Click(object sender, RoutedEventArgs e)
        {
            Window setprnt = new Window();
            if (CurrentSpectrum.ParentIon == null)
            {
                setprnt.Content = new SetParentMass();
            }
            else
            {
                setprnt.Content = new SetParentMass(CurrentSpectrum.ParentCharge.Value, CurrentSpectrum.ParentIon.MonoMass, CurrentSpectrum.ParentIon.MonoMZ);
            }
            SetParentMass.SetParentM.SaveParentOrNot = false;
            setprnt.Title = "Parent Mass";
            setprnt.Height = 220;
            setprnt.Width = 320;
            setprnt.ResizeMode = ResizeMode.NoResize;
            setprnt.Closing += AddParentMass_Closing;
            setprnt.Owner = this;
            setprnt.WindowStartupLocation = System.Windows.WindowStartupLocation.CenterOwner;
            setprnt.Activate();
            setprnt.ShowDialog();
        }

        bool addparentmassfromMergeSpectra = false;

        bool settingparentmassfromMergeSpectra = false;

        /// <summary>
        /// Adds ParentMass and ParentZ to all the MSMS spectra
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void AddParentMass_Closing(object sender, CancelEventArgs e)
        {
            if (SetParentMass.SetParentM.SaveParentOrNot)
            {
                settingparentmassfromMergeSpectra = true;
                var newmgrspectra = mgrspectra.Where(a => a.MsLevel == SpecMsLevel.MS).ToList(); //Adding all the MS spectra.

                newmgrspectra.AddRange(mgrspectra.
                        Where(a => a.MsLevel == SpecMsLevel.MSMS).
                        Select(c =>
                        {
                            c.ParentMass = SetParentMass.ParentMass.Mass; // AddParentMassforMergeSpectra.MergeParentMass.ParentMass;
                            c.ParentZ = SetParentMass.ParentMass.Charge; //AddParentMassforMergeSpectra.MergeParentMass.ParentZ;
                            c.ParentIon = new Cluster();
                            c.ParentIon.Z = SetParentMass.ParentMass.Charge;
                            c.ParentIon.MonoMZ = SetParentMass.ParentMass.ParentMZ;
                            c.ParentIon.MonoMass = SetParentMass.ParentMass.Mass;
                            c.ParentIon.Intensity = 1;
                            return c;
                        }).ToList()); //Adding all the MSMS spectra

                mgrspectra.Clear();

                newmgrspectra = newmgrspectra.OrderBy(a => a.ScanNumber).ToList(); //Sorting the MS spectra based on the scan number

                for (int i = 0; i < newmgrspectra.Count; i++)
                {
                    mgrspectra.Add(newmgrspectra[i]);
                }

                mergeView = new ListCollectionView(mgrspectra);

                // Based on: http://social.msdn.microsoft.com/Forums/en-US/915db4e8-0ccf-4c5b-97d3-b8898fcf4bac/filtering-observable-collection-using-collectionview?forum=wpf
                mergeView.Filter = (item) =>
                {
                    if (item == null) return false;
                    if (item is SpectrumInfo == false) return false;

                    // This is the filter to make the correct scans show up                    
                    return (item as SpectrumInfo).IsVisible;
                };
                this.grdMerge1.ItemsSource = mergeView;
                grdMerge1.DataContext = mergeView;
                addparentmassfromMergeSpectra = true;
                SetParentMass.SetParentM.SaveParentOrNot = false;

                CurrentSpectrum.ParentIon = new Cluster();

                CurrentSpectrum.ParentIon.Z = SetParentMass.ParentMass.Charge;
                CurrentSpectrum.ParentIon.MonoMZ = SetParentMass.ParentMass.ParentMZ;
                CurrentSpectrum.ParentIon.MonoMass = SetParentMass.ParentMass.Mass;
                //CurrentSpectrum.ParentCharge = SetParentMass.ParentMass.Charge;
            }
        }

        /// <summary>
        /// Copy all the BandYions from the datagrid, the error chart and the Spectrum to a Excel Document.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void mnuitmgridBandYIonsCopyExcel_Click(object sender, RoutedEventArgs e)
        {
            if (dtgridBandYIons.ItemsSource is List<CalculateBYCZIons.BYCZIons>)
            {
                List<string> AllHeaders = new List<string>();
                AllHeaders.Add("b-H2O");
                AllHeaders.Add("b Ions");
                AllHeaders.Add("bIon #");
                AllHeaders.Add("Amino Acid");
                AllHeaders.Add("yIon#");
                AllHeaders.Add("y Ions");
                AllHeaders.Add("y-H2O");
                AllHeaders.Add("y-NH3");
                var ListBandYions = dtgridBandYIons.ItemsSource as List<CalculateBYCZIons.BYCZIons>;

                string currentfilepath = App.AssemblyLocation;  //FindCurrentAssemblyPath.GetAssemblyPath();

                CreateBitMap.CreateBitmapFromVisual(ErrorPlot, currentfilepath + "\\" + "ErrorPlot.jpeg");

                CreateBitMap.CreateBitmapFromVisual(BottomChart, currentfilepath + "\\" + "Spectrum.jpeg");

                string currenttext = "Theoretical Mass = " + convertotdouble(lblTheoreticalMass.Content) + " Experimental Mass = " + convertotdouble(lblExperimentalMass.Text) + "  Delta Mass = " + convertotdouble(lblValidationDeltaMass.Content) + "  " + lblbandyionspercent.Content;

                ExportToExcel.ExportToexcel(AllHeaders, new List<List<string>>(), true, ListBandYions, currenttext);
            }
        }

        /// <summary>
        /// Convert an Object to Double with accuracy upto 4 decimal points
        /// </summary>
        /// <param name="value"></param>
        /// <returns></returns>
        double convertotdouble(object value)
        {
            if (value != null && Convert.ToString(value) != "")
            {
                return Math.Round(Convert.ToDouble(value), 4);
            }
            return 0;
        }

        private void btnshowmorevalidations_Click(object sender, RoutedEventArgs e)
        {
            if (dtgrdValidateSequences.Visibility == System.Windows.Visibility.Hidden)
            {
                dtgrdValidateSequences.Visibility = System.Windows.Visibility.Visible;
            }
            else if (dtgrdValidateSequences.Visibility == System.Windows.Visibility.Visible)
            {
                dtgrdValidateSequences.Visibility = System.Windows.Visibility.Hidden;
            }
        }

        private void dtgrdValidateSequences_MouseDoubleClick(object sender, MouseButtonEventArgs e)
        {
            if (dtgrdValidateSequences.SelectedItem != null)
            {
                if (dtgrdValidateSequences.SelectedItem is PossibleModSequences.PossibleMods)
                {
                    txtValidateSequenceWithSpectrum.Text = (dtgrdValidateSequences.SelectedItem as PossibleModSequences.PossibleMods).Sequence;
                    dtgrdValidateSequences.Visibility = System.Windows.Visibility.Hidden;
                }
            }
        }

        string experimentalmass = string.Empty;

        private void tbValidate_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            if (dtgridBandYIons.ItemsSource == null)
            {
                dtgrdValidateSequences.Visibility = System.Windows.Visibility.Hidden;
            }
        }

        private void txtMolecules_TextChanged(object sender, TextChangedEventArgs e)
        {
            if (btnSaveMatchList.Visibility == System.Windows.Visibility.Hidden)
            {
                btnSaveMatchList.IsEnabled = true;
                btnSaveMatchList.Visibility = System.Windows.Visibility.Visible;
                savingfromthedefaultlist = true;
            }
            if (btnSaveMatchList.IsEnabled == false)
            {
                btnSaveMatchList.IsEnabled = true;
            }
        }

        private void lblExperimentalMass_MouseDoubleClick(object sender, MouseButtonEventArgs e)
        {
            lblExperimentalMass.IsReadOnly = false;
            experimentalmass = lblExperimentalMass.Text;
        }

        private void lblExperimentalMass_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.Key == Key.Enter || e.Key == Key.Tab)
            {
                txtValidateSequenceWithSpectrum.Focus();
                CalculateTheoreticalMass(txtValidateSequenceWithSpectrum.Text, Convert.ToDouble(lblExperimentalMass.Text));

                var currentmnms = CurrentIons.Select(a => a.MonoMass).ToList();
                CalculateandDisplayBandYIons(txtValidateSequenceWithSpectrum.Text, currentmnms, Convert.ToDouble(lblExperimentalMass.Text));

                experimentalmass = lblExperimentalMass.Text;
            }
            else if (e.Key == Key.Escape)
            {
                lblExperimentalMass.Text = experimentalmass;
                txtValidateSequenceWithSpectrum.Focus();
            }
        }

        /// <summary>
        /// Export contents of Merged Scans grid to Excel
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void mnuitmMrgSpectra_Click(object sender, RoutedEventArgs e)
        {
            BackgroundWorker bgworkerCopyMergeSpec = new BackgroundWorker();
            bgworkerCopyMergeSpec.DoWork += bgworkerCopyMergeSpec_DoWork;
            bgworkerCopyMergeSpec.RunWorkerCompleted += bgworkerCopyMergeSpec_RunWorkerCompleted;
            bgworkerCopyMergeSpec.RunWorkerAsync();
        }

        private void mnuDetectParentSelected_Click(object sender, RoutedEventArgs e)
        {

            Dispatcher.Invoke(new Action(() =>
            {
                if (grdMerge1.ItemsSource != null)
                {
                    forceparentmassfrommgrspectra = true;
                    DetectParentMasses(grdMerge1.SelectedItems.Cast<SpectrumInfo>());
                }
            }));
        }

        /// <summary>
        /// Checks if there any ParentMass setup.
        /// Returns true if it any spectrum already has a Mass setup or returns false
        /// </summary>
        /// <returns></returns>
        bool AnyParentIons()
        {
            if (grdMerge1.ItemsSource != null)
            {
                (grdMerge1.ItemsSource as ListCollectionView).MoveCurrentToFirst(); /// Goes to the first item in the grid

                var crntitm = ((grdMerge1.ItemsSource as ListCollectionView).CurrentItem as SpectrumInfo);

                if (crntitm.ParentMass != null && crntitm.ParentMass != 0)
                    return true;

                while ((grdMerge1.ItemsSource as ListCollectionView).MoveCurrentToNext()) // Looping through all the items in the grid
                {
                    crntitm = (grdMerge1.ItemsSource as ListCollectionView).CurrentItem as SpectrumInfo;
                    if (crntitm.ParentMass != null && crntitm.ParentMass != 0) ///If it is not null then it has a parent mass.
                    {
                        return true;
                    }
                }
                return false;
            }
            return false;
        }

        void bckgExportMergeSpectraGridToExcel_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {

        }

        //void ExportMergeSpectraGridToExcel()
        //{
        //    Dispatcher.Invoke(new Action(() =>
        //    {
        //        Dispatcher.Invoke(new Action(() =>
        //        {
        //            this.busyTic.IsBusy = true;
        //            this.BusyProgressText = "Creating Excel Sheet";
        //            btnDetectParents.IsEnabled = false;
        //        }));

        //        if (grdMerge1.ItemsSource != null) ///&& grdMerge1.ItemsSource is List<SpectrumInfo>
        //        {
        //            List<string> AllHeaders = new List<string>();
        //            AllHeaders.Add("Scan Number");
        //            AllHeaders.Add("Title");
        //            AllHeaders.Add("Time");
        //            AllHeaders.Add("Mass");
        //            AllHeaders.Add("Z");
        //            AllHeaders.Add("Relative Intensity %");

        //            List<List<String>> Columns = new List<List<string>>();

        //            List<string> clm = new List<string>();

        //            (grdMerge1.ItemsSource as ListCollectionView).MoveCurrentToFirst();

        //            var curntitem = ((grdMerge1.ItemsSource as ListCollectionView).CurrentItem as SpectrumInfo);

        //            clm.Add(Convert.ToString(curntitem.ScanNumber));
        //            clm.Add(curntitem.Title);
        //            clm.Add(Convert.ToString(curntitem.RetentionTime));
        //            clm.Add(Convert.ToString(curntitem.ParentMass));
        //            clm.Add(Convert.ToString(curntitem.ParentZ));
        //            clm.Add(Convert.ToString(curntitem.RelativeIntensity));

        //            Columns.Add(clm);

        //            while ((grdMerge1.ItemsSource as ListCollectionView).MoveCurrentToNext())
        //            {
        //                List<string> column = new List<string>();
        //                curntitem = ((grdMerge1.ItemsSource as ListCollectionView).CurrentItem as SpectrumInfo);

        //                column.Add(Convert.ToString(curntitem.ScanNumber));
        //                column.Add(curntitem.Title);
        //                column.Add(Convert.ToString(curntitem.RetentionTime));
        //                column.Add(Convert.ToString(curntitem.ParentMass));
        //                column.Add(Convert.ToString(curntitem.ParentZ));
        //                column.Add(Convert.ToString(Math.Round(curntitem.RelativeIntensity * 100, 2)));
        //                Columns.Add(column);
        //            }

        //            ExportToExcel.ExportToexcel(AllHeaders, Columns);
        //        }
        //    }));
        //    CompletedExportMergeSpectraGridToExcel();
        //}

        //void CompletedExportMergeSpectraGridToExcel()
        //{
        //    Dispatcher.Invoke(new Action(() =>
        //    {
        //        this.busyTic.IsBusy = false;
        //        this.BusyProgressText = " ";
        //        btnDetectParents.IsEnabled = true;
        //    }));
        //}

        /// <summary>
        /// Create the excel sheet and display the busy indicator and open the excel document.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void bckgExportMergeSpectraGridToExcel_DoWork(object sender, DoWorkEventArgs e)
        {
            //Dispatcher.Invoke(new Action(() =>
            //{
            //    this.busyTic.IsBusy = false;
            //    this.BusyProgressText = " ";
            //    btnDetectParents.IsEnabled = false;
            //}));

            Dispatcher.Invoke(new Action(() =>
            {
                if (grdMerge1.ItemsSource != null)
                {
                    List<string> AllHeaders = new List<string>();
                    AllHeaders.Add("Scan Number");
                    AllHeaders.Add("Title");
                    AllHeaders.Add("Time");
                    AllHeaders.Add("Mass");
                    AllHeaders.Add("Z");
                    AllHeaders.Add("Relative Intensity %");

                    List<List<String>> Columns = new List<List<string>>();

                    List<string> clm = new List<string>();

                    (grdMerge1.ItemsSource as ListCollectionView).MoveCurrentToFirst(); //Go to the first item in the grid

                    var curntitem = ((grdMerge1.ItemsSource as ListCollectionView).CurrentItem as SpectrumInfo);

                    clm.Add(Convert.ToString(curntitem.ScanNumber));
                    clm.Add(curntitem.Title);
                    clm.Add(Convert.ToString(curntitem.RetentionTime));
                    clm.Add(Convert.ToString(curntitem.ParentMass));
                    clm.Add(Convert.ToString(curntitem.ParentZ));
                    clm.Add(Convert.ToString(curntitem.RelativeIntensity));

                    Columns.Add(clm);

                    while ((grdMerge1.ItemsSource as ListCollectionView).MoveCurrentToNext()) //Iterate through the items in the list in the grid
                    {
                        List<string> column = new List<string>();
                        curntitem = ((grdMerge1.ItemsSource as ListCollectionView).CurrentItem as SpectrumInfo);

                        column.Add(Convert.ToString(curntitem.ScanNumber));
                        column.Add(curntitem.Title);
                        column.Add(Convert.ToString(curntitem.RetentionTime));
                        column.Add(Convert.ToString(curntitem.ParentMass));
                        column.Add(Convert.ToString(curntitem.ParentZ));
                        column.Add(Convert.ToString(Math.Round(curntitem.RelativeIntensity * 100, 2)));
                        Columns.Add(column);
                    }
                    ExportToExcel.ExportToexcel(AllHeaders, Columns, false, null, null, true);
                }
            }));
        }

        /// <summary>
        /// After detecting parent ions should export all the values to excel.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void mgtspectradetections_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            BackgroundWorker bgworkerCopyMergeSpec = new BackgroundWorker();
            bgworkerCopyMergeSpec.DoWork += bgworkerCopyMergeSpec_DoWork;
            bgworkerCopyMergeSpec.RunWorkerCompleted += bgworkerCopyMergeSpec_RunWorkerCompleted;
            bgworkerCopyMergeSpec.RunWorkerAsync();
            //BackgroundWorker bckgExportMergeSpectraGridToExcel = new BackgroundWorker();
            //bckgExportMergeSpectraGridToExcel.DoWork += bckgExportMergeSpectraGridToExcel_DoWork;
            //bckgExportMergeSpectraGridToExcel.RunWorkerCompleted += bckgExportMergeSpectraGridToExcel_RunWorkerCompleted;
            //bckgExportMergeSpectraGridToExcel.RunWorkerAsync();
        }

        /// <summary>
        /// Find all the parent ions before populating values to excel
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        void mgtspectradetections_DoWork(object sender, DoWorkEventArgs e)
        {
            //Dispatcher.Invoke(new Action(() =>
            //{

            Dispatcher.Invoke(new Action(() =>
            {
                this.busyTic.IsBusy = true;
                this.BusyProgressText = "Detecting Parent Ions ...";
                //this.ShowStopButton = System.Windows.Visibility.Visible;
                btnDetectParents.IsEnabled = false;
            }));

            if (bgDetectParents.IsBusy)
            {
                Debug.Print("Cancelling old worker. " + bgDetectParents.GetHashCode());
                bgDetectParents.CancelAsync();
                Thread.Sleep(20);
            }

            //busymergespectra.IsBusy = true;
            //busymergespectra.Content = "Detecting Parent Ions";

            try
            {
                var specCount = mgrspectra.Count;
                float i = 0;
                // Populate all the Parent Ion Mass and Charge details
                foreach (var aScanInfo in mgrspectra)
                {

                    this.BusyProgressValue = (i++ / (float)specCount) * 100;

                    MainPointProvider.SetParentInfo(aScanInfo);
                }

                // Calculate TimeSort Values
                mgrspectra.PopulateTimeSort();
            }
            catch (Exception ex)
            {
                //args.Result = ex;
            }
            //}));
        }

        private void btnMergeSpectraCopy_Click(object sender, RoutedEventArgs e)
        {
            //if (!AnyParentIons()) ///(!ParentIonsDetected) ///If parent ions are not detected need to find the parent ions and then export them to excel
            //{
            //    BackgroundWorker mgtspectradetections = new BackgroundWorker();
            //    mgtspectradetections.DoWork += mgtspectradetections_DoWork;
            //    mgtspectradetections.RunWorkerCompleted += mgtspectradetections_RunWorkerCompleted;
            //    mgtspectradetections.RunWorkerAsync();
            //}
            //else  /// If parent ions are already detected then get all the values from the datagrid and then populate the excel
            {
                BackgroundWorker bgworkerCopyMergeSpec = new BackgroundWorker();
                bgworkerCopyMergeSpec.DoWork += bgworkerCopyMergeSpec_DoWork;
                bgworkerCopyMergeSpec.RunWorkerCompleted += bgworkerCopyMergeSpec_RunWorkerCompleted;
                bgworkerCopyMergeSpec.RunWorkerAsync();
                ///ExportMergeSpectraGridToExcel();
                //BackgroundWorker bckgExportMergeSpectraGridToExcel = new BackgroundWorker();
                //bckgExportMergeSpectraGridToExcel.DoWork += bckgExportMergeSpectraGridToExcel_DoWork;
                //bckgExportMergeSpectraGridToExcel.RunWorkerCompleted += bckgExportMergeSpectraGridToExcel_RunWorkerCompleted;
                //bckgExportMergeSpectraGridToExcel.RunWorkerAsync();
            }
            //BackgroundWorker bgworkerCopyMergeSpec = new BackgroundWorker();
            //bgworkerCopyMergeSpec.DoWork += bgworkerCopyMergeSpec_DoWork;
            //bgworkerCopyMergeSpec.RunWorkerCompleted += bgworkerCopyMergeSpec_RunWorkerCompleted;
            //bgworkerCopyMergeSpec.RunWorkerAsync();
        }

        void bgworkerCopyMergeSpec_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            //string csvFileName = (string)(e.Result);
            //System.Diagnostics.Process.Start(csvFileName);
            //var openCSVFile = System.Windows.MessageBox.Show("Export Complete. CSV file saved as: " + csvFileName + ". \n\n Open File Now?", "CSV Exported", MessageBoxButton.YesNo, MessageBoxImage.Information);
            //if (openCSVFile == MessageBoxResult.Yes)
            //{
            //    // NEED TO OPEN THE CSV FILE IN EXCEL....?
            //    File.Open(csvFileName, FileMode.Open);
            //}
            //string csvFileName = (string)(e.Result);
            //File.Open(csvFileName, FileMode.Open);
        }




        void bgworkerCopyMergeSpec_DoWork(object sender, DoWorkEventArgs e)
        {
            //Dispatcher.Invoke(new Action(() =>
            //{
            //    this.busyTic.IsBusy = false;
            //    this.BusyProgressText = " ";
            //    btnDetectParents.IsEnabled = false;
            //}));

            Dispatcher.Invoke(new Action(() =>
           {
               if (grdMerge1.ItemsSource != null)
               {
                   (grdMerge1.ItemsSource as ListCollectionView).MoveCurrentToFirst(); //Go to the first item in the grid
                   var curntitem = ((grdMerge1.ItemsSource as ListCollectionView).CurrentItem as SpectrumInfo);

                   if (curntitem == null) return;

                   List<string> AllHeaders = new List<string>();
                   AllHeaders.Add("Scan Number");
                   AllHeaders.Add("Title");
                   AllHeaders.Add("Time");
                   AllHeaders.Add("Mass");
                   AllHeaders.Add("Z");
                   AllHeaders.Add("Relative Intensity %");

                   List<List<String>> Columns = new List<List<string>>();

                   List<string> clm = new List<string>();




                   clm.Add(Convert.ToString(curntitem.ScanNumber));
                   clm.Add(curntitem.Title);
                   clm.Add(Convert.ToString(curntitem.RetentionTime));
                   clm.Add(Convert.ToString(curntitem.ParentMass));
                   clm.Add(Convert.ToString(curntitem.ParentZ));
                   clm.Add(Convert.ToString(curntitem.RelativeIntensity));

                   Columns.Add(clm);

                   while ((grdMerge1.ItemsSource as ListCollectionView).MoveCurrentToNext()) //Iterate through the items in the list in the grid
                   {
                       List<string> column = new List<string>();
                       curntitem = ((grdMerge1.ItemsSource as ListCollectionView).CurrentItem as SpectrumInfo);

                       column.Add(Convert.ToString(curntitem.ScanNumber));
                       column.Add(curntitem.Title);
                       column.Add(Convert.ToString(curntitem.RetentionTime));
                       column.Add(Convert.ToString(curntitem.ParentMass));
                       column.Add(Convert.ToString(curntitem.ParentZ));
                       column.Add(Convert.ToString(Math.Round(curntitem.RelativeIntensity * 100, 2)));
                       Columns.Add(column);
                   }

                   //if (!Directory.Exists(@"C:\TEMP\"))
                   //{
                   //    Directory.CreateDirectory(@"C:\temp\");
                   //}
                   //if (!Directory.Exists(@"C:\temp\Exported CSV Files\"))
                   //{
                   //    Directory.CreateDirectory(@"C:\temp\Exported CSV Files\");
                   //}

                   //string csvPath = @"C:\temp\Exported CSV Files\";
                   //string csvFileName = csvPath + DateTime.Now.ToString("yyyy-MM-dd-hh.mm.ss.ffffff") + ".csv";
                   //e.Result = csvFileName;

                   ExportToCSV.ExportTOCSV(AllHeaders, Columns);

               }
           }));
        }

        private void dtgridConfirmedSequences_MouseDoubleClick(object sender, MouseButtonEventArgs e)
        {
            try
            {
                string filename = DechargerVM.SpectralDataFilename != null ? DechargerVM.SpectralDataFilename : DechargerVM.WorkspaceFilename;

                if (filename == null)
                    return;

                fromautoscanvalidate = true;
                BackgroundWorker bgworkerconfirmedsequencesdoubleclick = new BackgroundWorker();
                bgworkerconfirmedsequencesdoubleclick.DoWork += bgworkerconfirmedsequencesdoubleclick_DoWork;
                bgworkerconfirmedsequencesdoubleclick.RunWorkerCompleted += bgworkerconfirmedsequencesdoubleclick_RunWorkerCompleted;
                bgworkerconfirmedsequencesdoubleclick.RunWorkerAsync();
            }
            catch (Exception ex)
            {
                string stacktrace = ex.StackTrace;
                stacktrace += (dtgridConfirmedSequences.SelectedItem is SearchResult && (SearchResult)dtgridConfirmedSequences.SelectedItem != null) ?
                              ("\nSequence Tag: " + (dtgridConfirmedSequences.SelectedItem as SearchResult).Sequence + "\t Scan Number: " + scannumbers + "\t Description: " + (dtgridConfirmedSequences.SelectedItem as SearchResult).Description) :
                              "";
                App.Laststacktrace = stacktrace;
                Action throwException = () => { throw ex; };
                Dispatcher.CurrentDispatcher.BeginInvoke(throwException);
            }
            finally
            {

            }

        }

        void bgworkerconfirmedsequencesdoubleclick_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            Dispatcher.Invoke((Action)(() =>
            {
                if (dtgridConfirmedSequences.SelectedItem is SearchResult && (SearchResult)dtgridConfirmedSequences.SelectedItem != null)
                {
                    bsyAutoScanTopProteinResults.IsBusy = false;
                    var item = dtgridConfirmedSequences.SelectedItem as SearchResult;

                    if (item.ScanNumbers == App.ScanNumber) return;

                    string filename = App.FileName;

                    if (filename == null)  // Conflict resolved, but this if statement may not be needed anymore
                    {
                        DisplayNewSpectrumNoFile(item);
                        return;
                    }

                    if ((item as SearchResult).ScanNumbers.Contains(","))
                    {
                        fromvalidateautoscan = true;
                        DisplayNewSpectrum((item as SearchResult).allspectrums);
                    }
                    else
                    {
                        fromvalidateautoscan = true;
                        var rt = MainPointProvider.RetentionTime(Convert.ToInt32((item as SearchResult).ScanNumbers));
                        DisplayNewSpectrum(rt);
                    }
                }
            }));
        }

        void bgworkerconfirmedsequencesdoubleclick_DoWork(object sender, DoWorkEventArgs e)
        {
            Dispatcher.Invoke((Action)(() =>
            {
                if (dtgridConfirmedSequences.SelectedItem is SearchResult && (SearchResult)dtgridConfirmedSequences.SelectedItem != null)
                {
                    Dispatcher.Invoke((Action)(() =>
                    {
                        bsyAutoScanTopProteinResults.IsBusy = true;
                    }));

                    //fromautoscantab = true;
                    var protein = dtgridConfirmedSequences.SelectedItem as SearchResult;
                    SetActivationTypes(protein);
                    Dictionary<double, double> crntmnmonomasses = new Dictionary<double, double>();
                    //bsyAutoScanTopProteinResults.IsBusy = true;
                    //bsyAutoScanTopProteinResults.Content = "Validating";
                    List<Cluster> crntmns = new List<Cluster>();
                    var sqssearch = dtgridConfirmedSequences.SelectedItem as SearchResult;

                    var scannumbers = sqssearch.ScanNumbers.Split(new char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);

                    //crntmnmonomasses = FindCrntMonos(scannumbers, sqssearch.ParentZ, dtgridConfirmedSequences.SelectedItem as SearchResult);
                    crntmnmonomasses = FindCrntMonos(dtgridConfirmedSequences.SelectedItem as SearchResult);
                    List<PossibleModSequences.PossibleMods> psdms = new List<PossibleModSequences.PossibleMods>();
                    string SequenceText = (dtgridConfirmedSequences.SelectedItem is SearchResult) ? (dtgridConfirmedSequences.SelectedItem as SearchResult).ValidatedSequence : string.Empty;
                    txtbxValidateTabAccession.Text = protein.Accession;

                    lblExperimentalMass.Text = protein.ParentMass.ToString(MassValueFormat);

                    txtbxSequenceScanNumbers.Text = (dtgridConfirmedSequences.SelectedItem as SearchResult).ScanNumbers;
                    txtbxSequenceParentZs.Text = (dtgridConfirmedSequences.SelectedItem as SearchResult).Parentz_s;

                    CurrentValidatedSequence = protein;
                    txtbxSequenceSet.Text = protein.Sequence;
                    BindProteintSequence(SequenceText);
                    BindtoValidatedSequences(psdms);
                    CalculateTheoreticalMass(SequenceText);
                    double bandyionpercent = 0;
                    BindBandYIons(SequenceText, ref bandyionpercent, protein.ParentMass, protein.CurntIons.Select(a => a.MonoMass).ToList());
                    Dispatcher.Invoke((Action)(() =>
                    {
                        tbValidate.Focus();
                    }));
                }
            }));
        }

        private void mnuClrRdGrnMarkers_Click(object sender, RoutedEventArgs e)
        {
            btnClearMarkers1_Click(null, null);
            btnClearMarkers2_Click(null, null);
            GreenMarkersSeriesLite.DataPoints.Clear();
            RedMarkersSeriesLite.DataPoints.Clear();
            btnClearSpectrumAll.IsOpen = false;
        }

        private void mnuclrRdMarkers_Click(object sender, RoutedEventArgs e)
        {
            btnClearMarkers1_Click(null, null);
            RedMarkersSeriesLite.DataPoints.Clear();
            btnClearSpectrumAll.IsOpen = false;
        }

        private void mnuclrGreenMarkers_Click(object sender, RoutedEventArgs e)
        {
            btnClearMarkers2_Click(null, null);
            GreenMarkersSeriesLite.DataPoints.Clear();
            btnClearSpectrumAll.IsOpen = false;
        }

        /// <summary>
        /// Need to select the datagrid item when right click on the textblock of the datagrid.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void TextBlock_MouseRightButtonDown(object sender, MouseButtonEventArgs e)
        {
            ///This is a work around as the textblock right mouse button doesn't select the correct datagrid item.
            if (sender != null)
            {
                if (((dtgrdSearchSequence.ItemsSource as List<SearchResult>).Any(a => a.AccessionandTagstartends == ((System.Windows.Controls.TextBlock)(sender)).Uid)))
                {
                    dtgrdSearchSequence.SelectedValue = ((dtgrdSearchSequence.ItemsSource as List<SearchResult>).First(a => a.AccessionandTagstartends == ((System.Windows.Controls.TextBlock)(sender)).Uid));     ///The Uid is bounded to the accession and tag start ends, hence comparing it with the accession of the datagrid itemssource to get the correct item
                }
                else if (((dtgrdSearchSequence.ItemsSource as List<SearchResult>).Any(a => a.Accession == ((System.Windows.Controls.TextBlock)(sender)).Uid)))
                {
                    dtgrdSearchSequence.SelectedValue = (((dtgrdSearchSequence.ItemsSource as List<SearchResult>).First(a => a.Accession == ((System.Windows.Controls.TextBlock)(sender)).Uid)));
                }
            }
        }

        private void txtblockAutoScanSequence_MouseRightButtonDown(object sender, MouseButtonEventArgs e)
        {
            if (sender != null)
            {
                List<SearchResult> lstsqssearch = new List<SearchResult>();
                foreach (var item in dtgridSearchResults.ItemsSource)
                {
                    lstsqssearch.Add(item as SearchResult);
                }
                try
                {
                    dtgridSearchResults.SelectedValue = lstsqssearch.First(a => a.ScanNumbers.Replace(" ", "") == ((System.Windows.Controls.TextBlock)(sender)).Uid);                                     ///The Uid is bounded to the accession and scan number, hence comparing it with the accession of the datagrid itemssource to get the correct item            
                    //dtgridSearchResults.SelectedValue = lstsqssearch.First(a => a.ScanNumbers == ((System.Windows.Controls.TextBlock)(sender)).Uid);                                     ///The Uid is bounded to the accession and scan number, hence comparing it with the accession of the datagrid itemssource to get the correct item            

                }
                catch (Exception ex)
                {
                    Debug.Print(ex.Message);

                }
            }
        }

        private void Image_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            Process.Start("https://www.lilly.com/");
        }


        //Based on: http://www.dotnetcurry.com/wpf/1130/wpf-commanding-enable-button

        //public RelayActionCommand SaveCommand { get; set; }
        //public IRelayCommand SaveCommand { get; protected set; }

        //private void CreateSaveCommand()
        //{
        //    SaveCommand = new RelayActionCommand()
        //    {
        //        CanExecuteAction = n => dtgridSearchResults.ItemsSource != null && (dtgridSearchResults is IEnumerable<SequenceSearch>) && (dtgridSearchResults as IEnumerable<SequenceSearch>).Any(),
        //        ExecuteAction = n => SaveWorkspace()
        //    };

        //    //SaveCommand = new RelayCommand(n => SaveWorkspace(), n => CanExecuteSave());

        //}

        //private bool CanExecuteSave()
        //{
        //    return dtgridSearchResults.ItemsSource != null && (dtgridSearchResults is IEnumerable<SearchResult>) && (dtgridSearchResults as IEnumerable<SearchResult>).Any();
        //}


        /// <summary>
        /// Save Auto scan results based on the filelocation and the datagrid
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void SaveWorkspace_Click(bool SaveAs = false)
        {
            //if (dtgridSearchResults.ItemsSource == null && dtgridConfirmedSequences.ItemsSource == null) return;

            //bool SaveAs = false;



            //sqssearchlst.SpectralDataFileHash = sha256_hash(DechargerVM.SpectralDataFilename);
            //string sourcepath = saveflgdl.FileName; //Need the complete file name

            // if any part of the path is missing,
            // if saveAs is set to true
            // if the file is read only
            // then prompt for a new file path.  

            if (string.IsNullOrWhiteSpace(DechargerVM.WorkspaceDirectory)
                || string.IsNullOrWhiteSpace(DechargerVM.WorkspaceFilename)
                || SaveAs
                || ((File.GetAttributes(System.IO.Path.Combine(DechargerVM.WorkspaceDirectory, DechargerVM.WorkspaceFilename)) & FileAttributes.ReadOnly) == FileAttributes.ReadOnly))
            {
                // Save As...  -- prompt user for filename

                SaveFileDialog saveflgdl = new SaveFileDialog();
                saveflgdl.InitialDirectory = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);

                saveflgdl.FileName = (string.IsNullOrWhiteSpace(DechargerVM.SpectralDataFilename) ? DechargerVM.WorkspaceFilename : DechargerVM.SpectralDataFilename) + ".ssr"; // Default file name
                saveflgdl.DefaultExt = ".ssr"; // Default file extension
                saveflgdl.Filter = "Sequence Search Results (.ssr)|*.ssr"; // Filter files by extension

                if (saveflgdl.ShowDialog().Value == false)
                {
                    return;  // user failed to provide a file name exit before saving!  
                }

                DechargerVM.WorkspaceFilename = System.IO.Path.GetFileName(saveflgdl.FileName);
                DechargerVM.WorkspaceDirectory = System.IO.Path.GetDirectoryName(saveflgdl.FileName);
            }

            //  prepare objects for serialization
            SearchSummary sqssearchlst = new SearchSummary();
            sqssearchlst.VersionNumber = Properties.Settings.Default.SequenceSearchFileVersion;
            sqssearchlst.SearchResults = DechargerVM.SearchResults;  //new ObservableCollection<SearchResult>(GenerateSearchResults()); //Get the SequenceSearch list generated for AutoScan results
            sqssearchlst.SpectralDataFilename = DechargerVM.SpectralDataFilename;
            sqssearchlst.SpectralDataFileHash = DechargerVM.SpectralDataFileHash;
            sqssearchlst.MachineName = Environment.MachineName;
            sqssearchlst.UserID = Environment.UserName;

            if (DechargerVM.SearchEndTime.HasValue)
            {
                sqssearchlst.SearchStartTime = DechargerVM.SearchStartTime.Value;
                sqssearchlst.SearchEndTime = DechargerVM.SearchEndTime.Value;
            }

            sqssearchlst = ApplySettings(sqssearchlst);

            // Save!!
            SaveWorkspace(new FileInfo(System.IO.Path.Combine(DechargerVM.WorkspaceDirectory, DechargerVM.WorkspaceFilename)), sqssearchlst);
        }

        /// <summary>
        /// Generate the Sequencesearch list from the source
        /// </summary>
        /// <param name="Path"></param>
        IEnumerable<SearchResult> GenerateSearchResults()
        {
            List<SearchResult> ListConfirmedSequences = new List<SearchResult>();

            Dictionary<string, string> sequencenumbers = new Dictionary<string, string>(); ///Scan numbers of all the scans in the Auto Scan tab.

            if (dtgridSearchResults.ItemsSource != null) //If the Autoscan tab is empty don't loop through.
            {
                foreach (var item in dtgridSearchResults.ItemsSource)
                {
                    if (item is SearchResult)
                    {
                        ListConfirmedSequences.Add(item as SearchResult);

                        string localscannumber = (item as SearchResult).ScanNumbers;
                        sequencenumbers.Add(localscannumber, localscannumber);
                    }
                }
            }

            if (ListConfirmedSequences.Count == 0)
            {
                if (dtgridConfirmedSequences.ItemsSource != null)
                {
                    foreach (var item in dtgridConfirmedSequences.ItemsSource)
                    {
                        if (item is SearchResult)
                        {
                            ListConfirmedSequences.Add(item as SearchResult);
                        }
                    }
                }
            }

            // Resolved Conflixt: may need this code: 
            //if (dtgridSearchResultsDeNovo.ItemsSource != null) ///Adding De Novo results. To reduce the data to be written into the SSR file only add the sequence search results which are not part of the Auto Scan tab.
            //{
            //    foreach (var item in dtgridSearchResultsDeNovo.ItemsSource)
            //    {
            //        if (item is SequenceSearch) /// && sequencenumbers.ContainsKey()
            //        {
            //            string localscannumber = (item as SequenceSearch).ScanNumbers;
            //            if (!sequencenumbers.ContainsKey(localscannumber))
            //            {
            //                ListConfirmedSequences.Add(item as SequenceSearch);
            //            }
            //        }
            //    }
            //}


            List<SearchResult> sequencesearchlst = new List<SearchResult>();

            for (int i = 0; i < ListConfirmedSequences.Count; i++)
            {
                if (ListConfirmedSequences[i].IsIdentifiedYesNo == "No") //If not identified add it to the list
                {
                    sequencesearchlst.Add(ListConfirmedSequences[i]);
                }
                else if (ListConfirmedSequences[i].InternalMT != null && ListConfirmedSequences[i].InternalMT.Count != 0 && ListConfirmedSequences[i].YellowandGreenTagHits != 0)
                {

                    sequencesearchlst.Add(ListConfirmedSequences[i]);
                }
            }

            return sequencesearchlst;
        }


        /// <summary>
        /// Save the Sequencesearchlist to a XML file (or zipped XML file) based on the file location
        /// </summary>
        /// <param name="Path"></param>
        /// <param name="sqssrchlst"></param>
        void SaveWorkspace(FileInfo file, SearchSummary sqssrchlst, bool useCompression = true)
        {
            //SequenceSearchList sqssrchlst = new SequenceSearchList();



            //if (DeChargerModel.SpectralDataFilename != null && File.Exists(DeChargerModel.SpectralDataFilename))
            //{
            //    sqssrchlst.SpectralDataFilename = DeChargerModel.SpectralDataFilename;
            //    sqssrchlst.SpectralDataFileHash = sha256_hash(sqssrchlst.SpectralDataFilename);
            //}



            // the zml results file should be named *.ssr.xml, but if zipped, the .xml should be trimmed from the zip, but the xml file within retains the.xml extension

            XmlSerializer serializer;
            var serializedXmlName = file.Name;
            DechargerVM.WorkspaceFilename = serializedXmlName;

            serializedXmlName = serializedXmlName.ToLower().EndsWith(".xml") ? serializedXmlName : serializedXmlName + ".xml";

            //            using (var fs = useCompression ? new ZipOutputStream(new FileStream(Path, FileMode.Create)) { CompressionLevel = Ionic.Zlib.CompressionLevel.BestCompression, CompressionMethod = CompressionMethod.BZip2 } as Stream : new FileStream(serializedXmlName, FileMode.Create))

            //JavaScriptSerializer jsserializer = new JavaScriptSerializer();

            //string jssqs = jsserializer.Serialize(jsserializer);
            //string jssqs = JsonConvert.SerializeObject(jsserializer);

            //C: \Users\C173791\Documents
            //System.IO.File.WriteAllText(@"C:\Users\C173791\Documents\jsonserializer.txt", jssqs);

            //useCompression = false;

            using (var fs = useCompression ? new ZipOutputStream(file.Open(FileMode.Create, FileAccess.Write)) { CompressionLevel = Ionic.Zlib.CompressionLevel.BestCompression, CompressionMethod = CompressionMethod.BZip2 } as Stream : new FileStream(System.IO.Path.Combine(file.DirectoryName, serializedXmlName), FileMode.Create))
            {
                serializer = new XmlSerializer(typeof(SearchSummary));
                if (fs is ZipOutputStream) (fs as ZipOutputStream).PutNextEntry(serializedXmlName);
                serializer.Serialize(fs, sqssrchlst);
                fs.Close();
            }

            UpdateWorkspaceTitle(sqssrchlst.SearchEndTime);


        }

        public void UpdateWorkspaceTitle(DateTime endTime = default(DateTime))
        {
            dockTools.Title = ToolsDockTitleRoot + (DechargerVM.WorkspaceFilename == null ? string.Empty : (" - " + DechargerVM.WorkspaceFilename)) + (endTime.Year > 2015 ? (" @ " + endTime.ToString("h:mm tt on MMM d, yyyy")) : string.Empty);
        }


        /// <summary>
        /// Apply all the settings for Sequence Search
        /// </summary>
        /// <param name="sqssrlst"></param>
        /// <returns></returns>
        SearchSummary ApplySettings(SearchSummary sqssrlst)
        {
            sqssrlst.CurrentSettings = new Settings();

            sqssrlst.CurrentSettings.AgilentAgreed = Properties.Settings.Default.AgilentAgreed;
            sqssrlst.CurrentSettings.AgilentEULA = Properties.Settings.Default.AgilentEULA;
            sqssrlst.CurrentSettings.BinnedLabels = Properties.Settings.Default.BinnedLabels;
            sqssrlst.CurrentSettings.ConnectionString = Properties.Settings.Default.ConnectionString;
            sqssrlst.CurrentSettings.CountBlastHits = Properties.Settings.Default.CountBlastHits;
            sqssrlst.CurrentSettings.DaltonErrorPlot = Properties.Settings.Default.DaltonErrorPlot;
            sqssrlst.CurrentSettings.Emails = Properties.Settings.Default.Emails;
            sqssrlst.CurrentSettings.FragementIonTolerance = Properties.Settings.Default.FragementIonTolerance;
            sqssrlst.CurrentSettings.Genus = Properties.Settings.Default.Genus;
            sqssrlst.CurrentSettings.HaveKnownMods = Properties.Settings.Default.HaveKnownMods;
            sqssrlst.CurrentSettings.HighBin = Properties.Settings.Default.HighBin;
            sqssrlst.CurrentSettings.JumpToXIC = Properties.Settings.Default.JumpToXIC;
            sqssrlst.CurrentSettings.Labels = Properties.Settings.Default.Labels;
            sqssrlst.CurrentSettings.MassTolerancePPM = App.FileName != null ? Properties.Settings.Default.MassTolerancePPM : (App.XMLFileName != null ? App.SSRXMLMassTolerancePPM : 0);
            sqssrlst.CurrentSettings.MassTolerancePPMBasedonFileType = Properties.Settings.Default.MassTolerancePPMBasedonFileType;
            sqssrlst.CurrentSettings.MassTolerancePPMs = Properties.Settings.Default.MassTolerancePPMs;
            sqssrlst.CurrentSettings.MatchList = Properties.Settings.Default.MatchList;
            sqssrlst.CurrentSettings.MatchListProfile = Properties.Settings.Default.MatchListProfile;
            sqssrlst.CurrentSettings.MatchTolerancePPMBasedonFileType = Properties.Settings.Default.MatchTolerancePPMBasedonFileType;
            sqssrlst.CurrentSettings.MatchTolerancePPM = App.FileName != null ? Properties.Settings.Default.MatchTolerancePPM : (App.XMLFileName != null ? App.SSRXMLMatchTolerancePPM : 0); ///Properties.Settings.Default.MatchTolerancePPM;
            sqssrlst.CurrentSettings.MatchTolerancePPMs = Properties.Settings.Default.MatchTolerancePPMs;
            sqssrlst.CurrentSettings.MaximumModifications = Properties.Settings.Default.MaximumModifications;
            sqssrlst.CurrentSettings.MinAgilentThresholdMS1 = Properties.Settings.Default.MinAgilentThresholdMS1;
            sqssrlst.CurrentSettings.MinAgilentThresholdMS2 = Properties.Settings.Default.MinAgilentThresholdMS2;
            sqssrlst.CurrentSettings.MinPeak = Properties.Settings.Default.MinPeak;
            sqssrlst.CurrentSettings.MinThresholdMS1 = Properties.Settings.Default.MinThresholdMS1;
            sqssrlst.CurrentSettings.MinThresholdMS2 = Properties.Settings.Default.MinThresholdMS2;
            sqssrlst.CurrentSettings.ModifiedAminoAcids = Properties.Settings.Default.ModifiedAminoAcids;
            sqssrlst.CurrentSettings.PPMErrorAxisMax = Properties.Settings.Default.PPMErrorAxisMax;
            sqssrlst.CurrentSettings.PPMErrorAxisMin = Properties.Settings.Default.PPMErrorAxisMin;
            sqssrlst.CurrentSettings.PPMErrorPlot = Properties.Settings.Default.PPMErrorPlot;
            sqssrlst.CurrentSettings.SearchAllSpecies = Properties.Settings.Default.SearchAllSpecies;
            sqssrlst.CurrentSettings.SequenceDetectionMode = Properties.Settings.Default.SequenceDetectionMode;
            sqssrlst.CurrentSettings.SequenceTagLength = Properties.Settings.Default.SequenceTagLength;
            sqssrlst.CurrentSettings.ShowHitsWithNoProteinID = Properties.Settings.Default.ShowHitsWithNoProteinID;
            sqssrlst.CurrentSettings.ShowMassTips = Properties.Settings.Default.ShowMassTips;
            sqssrlst.CurrentSettings.ShowOnlyFTMS = Properties.Settings.Default.ShowOnlyFTMS;
            sqssrlst.CurrentSettings.ShowThermo = Properties.Settings.Default.ShowThermo;
            sqssrlst.CurrentSettings.SortByDBHits = Properties.Settings.Default.SortByDBHits;
            sqssrlst.CurrentSettings.SortByScore = Properties.Settings.Default.SortByScore;
            sqssrlst.CurrentSettings.Species = Properties.Settings.Default.Species;
            sqssrlst.CurrentSettings.UnimodModifications = Properties.Settings.Default.UnimodModifications;
            sqssrlst.CurrentSettings.UseBlast = Properties.Settings.Default.UseBlast;
            sqssrlst.CurrentSettings.UseHybridIntensities = Properties.Settings.Default.UseHybridIntensities;
            sqssrlst.CurrentSettings.UseThoroughSearch = Properties.Settings.Default.UseThoroughSearch;
            sqssrlst.CurrentSettings.ValidationModificationsList = Properties.Settings.Default.ValidationModificationsList;
            sqssrlst.CurrentSettings.ValidationModificationsListAminoAcids = Properties.Settings.Default.ValidationModificationsListAminoAcids;

            return sqssrlst;
        }

        private void btnDebug_Click(object sender, RoutedEventArgs e)
        {
            //Debug.WriteLine(DechargerVM.SearchResults);
            if (tbValidate.DataContext == null)
                Debug.WriteLine("context is null");
            else
                Debug.WriteLine(tbValidate.DataContext);
        }

        private void Button_Click_1(object sender, RoutedEventArgs e)
        {
            //RootElement_Drop(null, null, @"C:\Users\c074884\Documents\CEMS_CY_LY_U_MY_CA_RED_20kV_MSMS_040913_01.raw.ssr");
            //RootElement_Drop(null, null, @"/dechargerbeta/DeCharger.Beta.application");

            ForceSpectrumRedraw();

        }

        private void ForceSpectrumRedraw()
        {
            // This is a total hack, but it works.... ugh.  

            // toggle width by one pixel to force a redraw???

            if (BottomChart.Margin.Right != 5)
                BottomChart.Margin = new Thickness(BottomChart.Margin.Left, BottomChart.Margin.Top, 5, BottomChart.Margin.Bottom);
            else
                BottomChart.Margin = new Thickness(BottomChart.Margin.Left, BottomChart.Margin.Top, 4, BottomChart.Margin.Bottom);

            //BottomChart.UpdateLayout();

        }

        /// <summary>
        /// Export the current Sequence Tag to Excel
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void ExportSequenceTagsToExcel_Click(object sender, RoutedEventArgs e)
        {
            if (dtgridsequences.ItemsSource != null) ///If the list is not empty
            {
                if (dtgridsequences.ItemsSource is List<FindSequenceTags.SequenceTag>)  ///If the ItemsSource is of type List of SequenceTag
                {
                    var sequencetags = dtgridsequences.ItemsSource as List<FindSequenceTags.SequenceTag>;
                    List<string> Headers = new List<string>();
                    List<List<String>> Columns = new List<List<string>>();
                    Headers.Add("Sequence Tag");
                    Headers.Add("Score");
                    Headers.Add("Start");
                    Headers.Add("ScanNumber");
                    Headers.Add("M/Z");
                    Headers.Add("Retentiontime");
                    Headers.Add("Z");
                    Headers.Add("Parentmass");
                    SequenceTagHeadersandColumns(sequencetags, ref Columns, CurrentScanNumber.Value);
                    ExportToExcel.ExportToexcel(Headers, Columns);
                }
            }
        }

        /// <summary>
        /// Based on Sequencetags create Headers and Columns
        /// </summary>
        /// <param name="sequencetags"></param>
        /// <param name="Headers"></param>
        /// <param name="Columns"></param>
        public void SequenceTagHeadersandColumns(List<FindSequenceTags.SequenceTag> sequencetags, ref List<List<string>> Columns, int CurrentScanNumber = 0, double ParentMass = 0, int ParentZ = 0, string ScanNumber = null, string RetentionTime = null)
        {
            List<string> column = new List<string>();

            double mz = 0;

            SpectrumInfo parentdetails = new SpectrumInfo();
            if (CurrentScanNumber != 0)
            {
                parentdetails = MainPointProvider.GetParentInfo(CurrentScanNumber);
                mz = MassSpecExtensions.ToMZ(parentdetails.ParentMass.Value, parentdetails.ParentZ.Value);
            }
            else
            {
                mz = MassSpecExtensions.ToMZ(ParentMass, ParentZ);
            }
            foreach (var sequencetag in sequencetags)
            {
                column = new List<string>(); //Clear the Strings before adding the new Column
                column.Add(sequencetag.RawSequence);
                column.Add(Convert.ToString(sequencetag.Score));
                column.Add(Convert.ToString(sequencetag.Start));
                if (CurrentScanNumber != 0)
                {
                    column.Add(App.ScanNumber);
                    column.Add(Convert.ToString(Math.Round(mz, 4)));
                    column.Add(Convert.ToString(Math.Round(parentdetails.RetentionTime.Value, 4)));
                    column.Add(Convert.ToString(parentdetails.ParentZ));
                    column.Add(Convert.ToString(Math.Round(parentdetails.ParentMass.Value, 4)));
                }
                else
                {
                    column.Add(ScanNumber);
                    column.Add(Convert.ToString(Math.Round(mz, 4)));
                    column.Add(RetentionTime);
                    column.Add(Convert.ToString(ParentZ));
                    column.Add(Convert.ToString(Math.Round(ParentMass, 4)));
                }
                Columns.Add(column);
            }

        }

        /// <summary>
        /// Export all the Sequence Tags for all the Sequence Search Results to Excel
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void mnuExportSequenceTagstoExcel_Click(object sender, RoutedEventArgs e)
        {
            if (dtgridSearchResults.ItemsSource != null)
            {
                List<SearchResult> ListOfSearchResults = new List<SearchResult>();
                foreach (var item in dtgridSearchResults.ItemsSource)
                {
                    if (item is SearchResult)
                    {
                        ListOfSearchResults.Add(item as SearchResult);
                    }
                }


                List<string> Headers = new List<string>();
                List<List<String>> Columns = new List<List<string>>();
                Headers.Add("Sequence Tag");
                Headers.Add("Score");
                Headers.Add("Start");
                Headers.Add("ScanNumber");
                Headers.Add("M/Z");
                Headers.Add("Retention Time");
                Headers.Add("Z");
                Headers.Add("Parentmass");

                foreach (var SearchResults in ListOfSearchResults)
                {
                    SequenceTagHeadersandColumns(SearchResults.AllsqsTags, ref Columns, 0, SearchResults.ParentMass, SearchResults.ParentZ, SearchResults.ScanNumbers, SearchResults.RetentionTime);
                }

                ExportToExcel.ExportToexcel(Headers, Columns);
            }
        }

        private void mainWindow_ContentRendered(object sender, EventArgs e)
        {
            if (LaunchArgument != null) RootElement_Drop(null, null, LaunchArgument);
        }

        private void btnShowInfo_Click(object sender, RoutedEventArgs e)
        {
            Window feedback = new Window();
            feedback.Height = 645;
            feedback.Width = 800;
            feedback.Owner = this;
            feedback.ResizeMode = ResizeMode.NoResize;
            feedback.Content = new InfoLegend();
            feedback.Title = "Info";
            feedback.WindowStartupLocation = System.Windows.WindowStartupLocation.CenterOwner;
            feedback.Activate();
            feedback.ShowDialog();
        }




        //private void btnLoadfromXML_Click(object sender, RoutedEventArgs e)
        //{
        //    SequenceSearchList sqsssrlst = new SequenceSearchList();

        //    XmlSerializer serializer = new XmlSerializer(typeof(SequenceSearchList));

        //    FileStream fs = new FileStream("SequenceSearchList.ssr.xml", FileMode.Open);
        //    sqsssrlst = (SequenceSearchList)serializer.Deserialize(fs);

        //    var sqssearchlst = sqsssrlst.SequenceSearches;

        //    ///Looping through the collection to set the Parent
        //    ///since the Parent couldn't be serialized.
        //    foreach (var sqs in sqssearchlst)
        //    {
        //        foreach (var crnti in sqs.CurntIons)
        //        {
        //            foreach (var crntp in crnti.Peaks)
        //            {
        //                crntp.Parent = crnti;
        //            }
        //        }
        //    }

        //    dtgridSearchResults.ItemsSource = sqssearchlst;

        //    //dtgridSearchResults.ItemsSource
        //}

        //private void btnClearAutoScanDatagrid_Click(object sender, RoutedEventArgs e)
        //{
        //    dtgridSearchResults.ItemsSource = null;
        //}


    }

    public sealed class QuantitationItem
    {
        public string Area { get; set; }
        public string RT { get; set; }
        public string RtStart { get; set; }
        public string RtEnd { get; set; }
        public string XicMzStart { get; set; }
        public string XicMzEnd { get; set; }
        public string Z { get; set; }
        public string Mass { get; set; }

        public string MzRange { get { return XicMzStart + " - " + XicMzEnd; } }
        public string RtRange { get { return RtStart + " - " + RtEnd; } }


        public override string ToString()
        {
            return Area + "\t" + Mass + "\t" + Z + "\t" + RtStart + "\t" + RtEnd + "\t" + XicMzStart + "\t" + XicMzEnd;
        }
    }


    public enum ChartMode { Mass, MZ };


    public class NonKeyNavigationTabItem : TabItem
    {
        protected override void OnKeyDown(KeyEventArgs e)
        {
            switch (e.Key)
            {
                case Key.Left:
                case Key.Right:
                case Key.Up:
                case Key.Down:
                    //e.Handled = true;
                    return;
                    break;
                default:
                    break;
            }

            base.OnKeyDown(e);
        }
    }


    public class SpectrumModel
    {
        public PointSet Spectrum { get; set; }
        public ObservableCollection<SignalProcessing.Point> MonoMasses { get; set; }
    }


    public static partial class Extensions
    {
        public static void TryAdd(this IDictionary<int, string> lookup, int key, string value)
        {
            if (!lookup.ContainsKey(key)) lookup.Add(key, value);
        }

        public static bool HasMethod(this object objectToCheck, string methodName)
        {
            var type = objectToCheck.GetType();
            return type.GetMethod(methodName) != null;
        }

        public static IEnumerable<int> IndexesOf(this string toBeSearched, string target, int start = 0)
        {
            var results = new List<int>();
            int result = -1;

            do
            {
                result = toBeSearched.IndexOf(target, start);
                if (result > -1)
                {
                    results.Add(result);
                    start = result + target.Length;
                }

            } while (result > -1 && start < toBeSearched.Length);

            return results;
        }
    }

    public class FilterSequenceSearch
    {
        public FilterAccessions Accessions { get; set; }
        public FilterDescription Description { get; set; }
        public FilterSpecies Species { get; set; }
        public FilterSequences Sequences { get; set; }
    }

    public class FilterAccessions
    {
        public bool Selected
        {
            get;
            set;
        }
        public string Value { get; set; }
        public bool AlreadySelected { get; set; }
        public string FilterType { get; set; }
    }

    public class FilterDescription
    {
        public bool Selected
        {
            get;
            set;
        }
        public string Value { get; set; }
        public bool AlreadySelected { get; set; }
        public string FilterType { get; set; }
    }

    public class FilterSpecies
    {
        public bool Selected
        {
            get;
            set;
        }
        public string Value { get; set; }
        public bool AlreadySelected { get; set; }
        public string FilterType { get; set; }
    }

    public class FilterSequences
    {
        public bool Selected
        {
            get;
            set;
        }
        public string Value { get; set; }
        public bool AlreadySelected { get; set; }
        public string FilterType { get; set; }
    }

    public class AnnotationBar
    {
        public double Start { get; set; }
        public double End { get; set; }
        public string Name { get; set; }
        public string Index { get; set; }
        public double StartScore { get; set; }
        public double EndScore { get; set; }
    }

    public class InitialAA
    {
        public string Name { get; set; }
        public float Delta { get; set; }
        public float StartDelta { get; set; }
        public double Start { get; set; }
        public double End { get; set; }
        public string Index { get; set; }
        public float EndDelta { get; set; }
        public string NameIndex
        {
            get
            {
                return Convert.ToString(Start) + Convert.ToString(End);
            }
            //set; 
        }
        //public List<double> StartValues { get; set; }
        //public List<double> EndValues { get; set; }
        //public List<float> StartDeltaValues { get; set; }
        //public List<float> EndDeltaValues { get; set; }
        public override string ToString() { return "Seq: " + Name + "; Start: " + Start.ToString("0.00") + "; End: " + End.ToString("0.00"); }

        public double AverageMonoMassIntensity { get; set; }

        public double SumofMonoMassIntensities { get; set; }
    }

    public enum Colour
    {
        Blue,
        Green,
        Orange
    };

    public class SequenceMatching
    {
        public int start { get; set; }
        public int end { get; set; }
        public string sequence { get; set; }
        public bool match { get; set; }
        public Colour color { get; set; }
    }



    public static partial class Extensions
    {
        public static void ApplyConfidence(this InlineCollection inlines, bool isBlastTag = false)
        {
            foreach (var anInline in inlines) ApplyConfidence(anInline, (AminAcidConfidence)anInline.Tag, isBlastTag);
        }


        public static void ApplyConfidence(this Inline theRun, AminAcidConfidence confidence, bool isBlastTag = false)
        {
            confidence = (AminAcidConfidence)(Math.Abs((int)confidence) * (isBlastTag ? -1 : 1));
            
            switch (confidence)
            {
                case AminAcidConfidence.BlastTagMatch:
                    theRun.FontSize = 12;
                    theRun.FontWeight = FontWeights.Bold;
                    break;
                case AminAcidConfidence.BlastTagHigh:
                    theRun.FontSize = 12;
                    theRun.Foreground = System.Windows.Media.Brushes.DarkSlateGray;
                    theRun.FontWeight = FontWeights.Bold;
                    break;
                case AminAcidConfidence.BlastTagMisMatch:
                    theRun.FontSize = 12;
                    theRun.Foreground = System.Windows.Media.Brushes.Red;
                    theRun.FontWeight = FontWeights.Bold;
                    break;
                case AminAcidConfidence.BlastTagPossible:
                    theRun.FontSize = 12;
                    theRun.Foreground = System.Windows.Media.Brushes.RoyalBlue;
                    theRun.FontWeight = FontWeights.Bold;
                    break;
                case AminAcidConfidence.Sure:
                    theRun.FontSize = 12;
                    theRun.Foreground = System.Windows.Media.Brushes.Snow;
                    theRun.Background = System.Windows.Media.Brushes.Black;
                    theRun.FontWeight = FontWeights.Bold;
                    break;
                case AminAcidConfidence.High:
                    theRun.FontSize = 12;
                    theRun.Foreground = System.Windows.Media.Brushes.DarkGray;
                    theRun.Background = System.Windows.Media.Brushes.White;
                    theRun.FontWeight = FontWeights.Bold;
                    break;
                case AminAcidConfidence.Medium:
                    theRun.FontSize = 12;
                    theRun.Foreground = System.Windows.Media.Brushes.Gray;
                    theRun.Background = System.Windows.Media.Brushes.White;
                    theRun.FontWeight = FontWeights.Bold;
                    break;
                case AminAcidConfidence.Low:
                    theRun.FontSize = 12;
                    theRun.Foreground = System.Windows.Media.Brushes.Snow;
                    theRun.Background = System.Windows.Media.Brushes.RoyalBlue;
                    theRun.FontWeight = FontWeights.Bold;
                    break;
                case AminAcidConfidence.Possible:
                    theRun.FontSize = 12;
                    theRun.Foreground = System.Windows.Media.Brushes.Black;
                    theRun.Background = System.Windows.Media.Brushes.White;
                    theRun.FontWeight = FontWeights.Bold;
                    break;
                case AminAcidConfidence.NotSure:
                    theRun.FontSize = 12;
                    theRun.Foreground = System.Windows.Media.Brushes.Black;
                    theRun.Background = System.Windows.Media.Brushes.White;
                    theRun.FontWeight = FontWeights.Bold;
                    break;
                case AminAcidConfidence.NotPossible:
                    theRun.FontSize = 12;
                    theRun.Foreground = System.Windows.Media.Brushes.Gray;
                    theRun.Background = System.Windows.Media.Brushes.White;
                    break;
                case AminAcidConfidence.Gap:
                    theRun.FontSize = 12;
                    theRun.Foreground = System.Windows.Media.Brushes.Snow;
                    theRun.Background = System.Windows.Media.Brushes.DarkRed;
                    theRun.FontWeight = FontWeights.Bold;
                    break;
                case AminAcidConfidence.Reallybad:
                    theRun.FontSize = 12;
                    theRun.Foreground = System.Windows.Media.Brushes.Gray;
                    theRun.Background = System.Windows.Media.Brushes.White;
                    break;
                case AminAcidConfidence.SearchHit:
                    theRun.FontSize = 12;
                    theRun.Foreground = System.Windows.Media.Brushes.Purple;
                    theRun.Background = System.Windows.Media.Brushes.White;
                    break;
                default:
                    break;
            }

        }


        private class AminoAcidWithConfidence
        {
            public int Index;
            public char Symbol;
            public AminAcidConfidence Confidence;

            public override string ToString()
            {
                return Symbol.ToString() + Confidence.ToString();
            }
        }

        public static void ApplyBlastHighlight(this InlineCollection inlines, SearchResult searchResult)
        {
            inlines.Clear();

            var scores = searchResult.ComputeQueryTagScores();

            if (scores.Count != searchResult.QueryTag.Length) return;

            Run currentRun = null;
            //double currentRunMass = 0;

            for (int i = 0; i < scores.Count; i++)
            {
                if (currentRun == null || ((AminAcidConfidence)currentRun.Tag != scores[i]))
                {
                    if (currentRun != null)
                    {
                        inlines.Add(currentRun);
                    }
                    currentRun = new Run();
                    currentRun.Tag = scores[i];
                }

                currentRun.Text += searchResult.QueryTag[i];
                //fragmentQueryMass += searchResult.QueryTag[i];
            }

            if (currentRun != null) inlines.Add(currentRun);  // add the last one

            // this takes the confidence values stored in the tags and applies a color to the runs  
            inlines.ApplyConfidence(true);

            //var theRun2 = new Run(aa.SequenceTag);
            //theRun2.ApplyConfidence(aa.confidence);
            //inlines.Add(theRun2);

            //foreach (var aa in tags.Where(t => !string.IsNullOrWhiteSpace(t.SequenceTag)))
            //{
            //    var theRun2 = new Run(aa.SequenceTag);
            //    theRun2.ApplyConfidence(aa.confidence);
            //    inlines.Add(theRun2);
            //}
        }


        public static void ApplyBlastHighlight(this InlineCollection inlines, string ProteinSequence, List<MSViewer.MatchStartEnds> tags)
        {
            inlines.Clear();
            foreach (var aa in tags.Where(t => !string.IsNullOrWhiteSpace(t.SequenceTag)))
            {
                var theRun2 = new Run(aa.SequenceTag);
                theRun2.ApplyConfidence(aa.confidence);
                inlines.Add(theRun2);
            }
        }

        public static void ApplyHighlight(this InlineCollection inlines, string ProteinSequence, List<MSViewer.MatchStartEnds> tags)
        {
            var sequenceWithConfidence = new List<AminoAcidWithConfidence>();
            int currentIndex = 0;

            // Create an ordered list of all amino acids in the protein with default Confidence of None for that Amino Acid
            foreach (var aChar in ProteinSequence)
                sequenceWithConfidence.Add(new AminoAcidWithConfidence() { Index = currentIndex++, Symbol = aChar, Confidence = AminAcidConfidence.None });

            bool Dontshowall = false;
            if (tags.Where(a => a.DontShowall).Any())
                Dontshowall = true;
            // Assigns the highest confidence value to each amino acid based on the confidence of the passed in tags
            foreach (var aMatch in tags.OrderBy(t => t.confidence))
            {
                if (aMatch.End - aMatch.Start < 1) continue;

                foreach (var aa in sequenceWithConfidence.Where(a => a.Index >= aMatch.Start && a.Index < (aMatch.Start + aMatch.Length)))
                    aa.Confidence = aMatch.confidence;
            }

            var currentConfidence = sequenceWithConfidence.First().Confidence;
            var runStart = 0;

            if (Dontshowall)
            {
                List<AminoAcidWithConfidence> grayarea = sequenceWithConfidence.Where(a => a.Confidence == AminAcidConfidence.NotPossible || a.Confidence == AminAcidConfidence.Reallybad).ToList(); //Checking if there is any gray area
                                                                                                                                                                                                                   //var notgrayarea = sequenceWithConfidence.Where(a => a.Confidence != Confidence.NotPossible && a.Confidence != Confidence.Reallybad).ToList();

                //int startnotgrayarea = notgrayarea.Min(a => a.Index);
                //int endnotgrayarea = notgrayarea.Max(a => a.Index);
                if (grayarea.Any()) //If there is any gray area then the following logic should be applied
                {
                    var notgrayarea = sequenceWithConfidence.Where(a => a.Confidence != AminAcidConfidence.NotPossible && a.Confidence != AminAcidConfidence.Reallybad).ToList(); //Area which is not gray
                    if (!notgrayarea.Any()) return;
                    int startnotgrayarea = notgrayarea.Min(a => a.Index);

                    int endnotgrayarea = notgrayarea.Max(a => a.Index);

                    if (grayarea.Where(a => a.Index < (startnotgrayarea - 30)).Any())
                    {
                        ProteinSequence = "←" + ProteinSequence.Substring(startnotgrayarea - 30);
                        sequenceWithConfidence = sequenceWithConfidence.Where(a => a.Index >= (startnotgrayarea - 30)).ToList();
                        //sequenceWithConfidence.Add(new AminoAcidWithConfidence
                        //{
                        //    Index = startnotgrayarea - 31,
                        //    Confidence = Confidence.NotPossible,
                        //    Symbol = '-'
                        //});
                        sequenceWithConfidence.Add(new AminoAcidWithConfidence
                        {
                            Index = startnotgrayarea - 31,
                            Confidence = AminAcidConfidence.NotPossible,
                            Symbol = '←'
                        });
                        sequenceWithConfidence = sequenceWithConfidence.OrderBy(a => a.Index).ToList();
                        List<AminoAcidWithConfidence> seq = new List<AminoAcidWithConfidence>();
                        int cseq = 0;
                        foreach (var se in sequenceWithConfidence)
                        {
                            seq.Add(new AminoAcidWithConfidence
                            {
                                Symbol = se.Symbol,
                                Index = cseq,
                                Confidence = se.Confidence
                            });
                            cseq++;
                        }
                        sequenceWithConfidence = seq.ToList();
                        endnotgrayarea = sequenceWithConfidence.Where(a => a.Confidence != AminAcidConfidence.NotPossible && a.Confidence != AminAcidConfidence.Reallybad).ToList().Max(a => a.Index);
                        grayarea = sequenceWithConfidence.Where(a => a.Confidence == AminAcidConfidence.NotPossible || a.Confidence == AminAcidConfidence.Reallybad).ToList();
                    }

                    if (grayarea.Where(a => a.Index > (endnotgrayarea + 30)).Any())
                    {
                        ProteinSequence = ProteinSequence.Substring(0, endnotgrayarea + 31) + "→";
                        sequenceWithConfidence = sequenceWithConfidence.Where(a => a.Index <= (endnotgrayarea + 30)).ToList();
                        sequenceWithConfidence.Add(new AminoAcidWithConfidence
                        {
                            Index = endnotgrayarea + 31,
                            Confidence = AminAcidConfidence.NotPossible,
                            Symbol = '→'
                        });
                        List<AminoAcidWithConfidence> seq = new List<AminoAcidWithConfidence>();
                        int cseq = 0;
                        foreach (var se in sequenceWithConfidence)
                        {
                            seq.Add(new AminoAcidWithConfidence
                            {
                                Symbol = se.Symbol,
                                Index = cseq,
                                Confidence = se.Confidence
                            });
                            cseq++;
                        }
                        sequenceWithConfidence = seq.ToList();
                    }
                }
            }
            inlines.Clear();

            foreach (var aa in sequenceWithConfidence)
            {
                if (aa.Confidence != currentConfidence)
                {
                    var theRun = new Run(ProteinSequence.Substring(runStart, (aa.Index - runStart)));
                    theRun.ApplyConfidence(currentConfidence);

                    if (aa.Index - runStart > 0) inlines.Add(theRun);

                    runStart = aa.Index;
                    currentConfidence = aa.Confidence;
                }
            }

            var lastAA = sequenceWithConfidence.Last();

            var theRun2 = new Run(ProteinSequence.Substring(runStart, (lastAA.Index - runStart) + 1));

            theRun2.ApplyConfidence(currentConfidence);

            if ((lastAA.Index - runStart) + 1 > 0) inlines.Add(theRun2);
        }
    }

    public class Sequences : INotifyPropertyChanged
    {
        public event PropertyChangedEventHandler PropertyChanged;

        private bool check;

        public bool Check
        {
            get
            {
                return check;
            }
            set
            {
                check = value;
                if (this.PropertyChanged != null)
                {
                    OnPropertyChanged("Check");
                }
            }
        }

        public string Sequence { get; set; }
        public float Score { get; set; }


        private void OnPropertyChanged(string info)
        {
            PropertyChangedEventHandler handler = PropertyChanged;
            if (handler != null)
            {
                handler(this, new PropertyChangedEventArgs(info));
            }
        }
    }


    //public class DoubleFormatter : IValueConverter
    //{
    //    // This converts the DateTime object to the string to display.
    //    public object Convert(object value, Type targetType, object parameter,
    //        System.Globalization.CultureInfo culture)
    //    {
    //        if (value != null && (value is double || value is float))
    //            return Math.Round((double)value, 4);
    //        else
    //            return 0;
    //    }

    //    // No need to implement converting back on a one-way binding 
    //    public object ConvertBack(object value, Type targetType,
    //        object parameter, System.Globalization.CultureInfo culture)
    //    {
    //        return 0;
    //    }
    //}

    public class MonoPeak
    {
        public double Score
        {
            get;
            set;
        }
        public double XValue
        {
            get;
            set;
        }
        public int Index
        {
            get;
            set;
        }
        public int Charge
        {
            get;
            set;
        }
    }

    /// <summary>
    /// While tracing the sequence from one direction
    /// from the parent mass, the Name of the Amino Acid and
    /// the sum of the sequence till this current Amino Acid
    /// is counted. 
    /// Once this is obtained we trace the sequence from the
    /// start looking for the Monos if there is any match for the 
    /// current value.
    /// If there is a match to the current value then the Sequence 
    /// is strong at that point.
    /// </summary>
    public class AminoAcidIndex
    {
        public string Value
        {
            get;
            set;
        }
        public double Totaltillnow
        {
            get;
            set;
        }
        public double Start
        {
            get;
            set;
        }
        public double End
        {
            get;
            set;
        }
        public int StartCharge
        {
            get;
            set;
        }
        public int EndCharge
        {
            get;
            set;
        }
    }


    /// <summary>
    /// The AminoAcidGap is the part of the sequence
    /// which is missing.
    /// The AminoAcidGap from the reverse direction is
    /// compared to the one in the forward direction to
    /// see if there is any sequence.
    /// </summary>
    public class AminoAcidGap
    {
        public double StartValue
        {
            get;
            set;
        }
        public double EndValue
        {
            get;
            set;
        }
        public double Gap
        {
            get;
            set;
        }
        public double EndPosition
        {
            get;
            set;
        }
        public double StartPosition
        {
            get;
            set;
        }
        public int StartCharge
        {
            get;
            set;
        }
        public int EndCharge
        {
            get;
            set;
        }
    }

    public class MonoLabelAction
    {
        public bool Show { get; set; }
        public double Mass { get; set; }
        public float Intensity { get; set; }
        public int Z { get; set; }
    }

    public class AminoAcidMatch
    {
        public string Name { get; set; }
        public double Mass { get; set; }
        public Cluster Start { get; set; }
        public Cluster End { get; set; }
        public double ScoreBooster { get; set; }

        public double Delta
        {
            get
            {
                return Math.Abs(Mass - Math.Abs(Start.MonoMass - End.MonoMass));
            }
        }

        public override string ToString()
        {
            return "Amino Acid = " + Name + ", Delta = " + (Mass - Math.Abs(Start.MonoMass - End.MonoMass)).ToString("0.000") + ", End = " + End.MonoMass.ToString("0.0000");
        }
    }


}